<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>C++ Object Persistence with ODB</title>

  <meta name="copyright" content="&copy; 2009-2011 Code Synthesis Tools CC"/>
  <meta name="keywords" content="odb,c++,object,persistence,ORM,relational,database,RDBMS,ODBMS,OODBMS"/>
  <meta name="description" content="C++ Object Persistence with ODB"/>
  <meta name="revision" content="1.6"/>
  <meta name="version" content="1.6.0"/>

<!--

If you make changes to this document, follow these stylistic rules
for consistency.

 - Don't use 'object' for instances of non-persistent classes. Use
   'instance' instead.

 - Each overloaded function should still be referred to as function.
   When saying that a function is overloaded, use term 'version',
   for example The persist() function has two overloaded versions.
   Don't use version to refer to individual functions, use function
   instead. The same holds for constructors.

 - Use 'object id' and 'object's identifier'. But not other combinations
   of the two.

@@ Check that parts TOCs are up to date.

-->

  <link rel="stylesheet" type="text/css" href="default.css" />

<style type="text/css">
  pre {
    padding    : 0 0 0 0em;
    margin     : 0em 0em 0em 0;

    font-size  : 102%
  }

  body {
    min-width: 48em;
  }

  h1 {
    font-weight: bold;
    font-size: 200%;
    line-height: 1.2em;
  }

  h2 {
    font-weight : bold;
    font-size   : 150%;

    padding-top : 0.8em;
  }

  h3 {
    font-size   : 140%;
    padding-top : 0.8em;
  }

  /* Force page break for both PDF and HTML (when printing). */
  hr.page-break {
    height: 0;
    width: 0;
    border: 0;
    visibility: hidden;

    page-break-after: always;
  }

  /* Adjust indentation for three levels. */
  #container {
    max-width: 48em;
  }

  #content {
    padding: 0 0.1em 0 4em;
    /*background-color: red;*/
  }

  #content h1 {
    margin-left: -2.06em;
  }

  #content h2 {
    margin-left: -1.33em;
  }

  /* Title page */

  #titlepage {
    padding: 2em 0 1em 0;
    border-bottom: 1px solid black;
  }

  #titlepage .title {
    font-weight: bold;
    font-size: 200%;
    text-align: center;
    padding: 1em 0 2em 0;
  }

  #titlepage p {
    padding-bottom: 1em;
  }

  #titlepage #revision {
    padding-bottom: 0em;
  }

  /* Lists */
  ul.list li, ol.list li {
    padding-top      : 0.3em;
    padding-bottom   : 0.3em;
  }

  div.img {
    text-align: center;
    padding: 2em 0 2em 0;
  }

  /*  */
  dl dt {
    padding   : 0.8em 0 0 0;
  }

  /* TOC */
  table.toc {
    border-style      : none;
    border-collapse   : separate;
    border-spacing    : 0;

    margin            : 0.2em 0 0.2em 0;
    padding           : 0 0 0 0;
  }

  table.toc tr {
    padding           : 0 0 0 0;
    margin            : 0 0 0 0;
  }

  table.toc * td, table.toc * th {
    border-style      : none;
    margin            : 0 0 0 0;
    vertical-align    : top;
  }

  table.toc * th {
    font-weight       : normal;
    padding           : 0em 0.1em 0em 0;
    text-align        : left;
    white-space       : nowrap;
  }

  table.toc * table.toc th {
    padding-left      : 1em;
  }

  table.toc * td {
    padding           : 0em 0 0em 0.7em;
    text-align        : left;
  }

  /* operators table */
  #operators {
    margin: 2em 0 2em 0;

    border-collapse   : collapse;
    border            : 1px solid;
    border-color      : #000000;

    font-size        : 11px;
    line-height      : 14px;
  }

  #operators th, #operators td {
    border: 1px solid;
    padding           : 0.9em 0.9em 0.7em 0.9em;
  }

  #operators th {
    background : #cde8f6;
  }

  #operators td {
    text-align: left;
  }

  /* specifiers table */
  .specifiers {
    margin: 2em 0 2em 0;

    border-collapse   : collapse;
    border            : 1px solid;
    border-color      : #000000;

    font-size        : 11px;
    line-height      : 14px;
  }

  .specifiers th, .specifiers td {
    border: 1px solid;
    padding           : 0.9em 0.9em 0.7em 0.9em;
  }

  .specifiers th {
    background : #cde8f6;
  }

  .specifiers td {
    text-align: left;
  }

  /* mapping table */
  #mapping {
    margin: 2em 0 2em 0;

    border-collapse   : collapse;
    border            : 1px solid;
    border-color      : #000000;

    font-size        : 11px;
    line-height      : 14px;
  }

  #mapping th, #mapping td {
    border: 1px solid;
    padding           : 0.9em 0.9em 0.7em 0.9em;
  }

  #mapping th {
    background : #cde8f6;
  }

  #mapping td {
    text-align: left;
  }

</style>


</head>

<body>
<div id="container">
  <div id="content">

  <div class="noprint">

  <div id="titlepage">
    <div class="title">C++ Object Persistence with ODB</div>

    <p>Copyright &copy; 2009-2011 Code Synthesis Tools CC</p>

    <p>Permission is granted to copy, distribute and/or modify this
    document under the terms of the
    <a href="http://www.codesynthesis.com/licenses/fdl-1.3.txt">GNU Free
    Documentation License, version 1.3</a>; with no Invariant Sections,
    no Front-Cover Texts and no Back-Cover Texts.</p>

    <!-- REMEMBER TO CHANGE VERSIONS IN THE META TAGS ABOVE! -->
    <p id="revision">Revision 1.6, October 2011</p>
    <p>This revision of the manual describes ODB 1.6.0 and is available
    in the following formats:
    <a href="http://www.codesynthesis.com/products/odb/doc/manual.xhtml">XHTML</a>,
    <a href="http://www.codesynthesis.com/products/odb/doc/odb-manual.pdf">PDF</a>, and
    <a href="http://www.codesynthesis.com/products/odb/doc/odb-manual.ps">PostScript</a>.</p>
  </div>

  <hr class="page-break"/>
  <h1>Table of Contents</h1>

  <table class="toc">
    <tr>
      <th></th><td><a href="#0">Preface</a>
        <table class="toc">
          <tr><th></th><td><a href="#0.1">About This Document</a></td></tr>
	  <tr><th></th><td><a href="#0.2">More Information</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th colspan="2"><a href="#I">PART I OBJECT-RELATIONAL MAPPING</a></th>
    </tr>

    <tr>
      <th>1</th><td><a href="#1">Introduction</a>
        <table class="toc">
          <tr><th>1.1</th><td><a href="#1.1">Architecture and Workflow</a></td></tr>
	  <tr><th>1.2</th><td><a href="#1.2">Benefits</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>2</th><td><a href="#2">Hello World Example</a>
        <table class="toc">
          <tr><th>2.1</th><td><a href="#2.1">Declaring a Persistent Class</a></td></tr>
          <tr><th>2.2</th><td><a href="#2.2">Generating Database Support Code</a></td></tr>
          <tr><th>2.3</th><td><a href="#2.3">Compiling and Running</a></td></tr>
          <tr><th>2.4</th><td><a href="#2.4">Making Objects Persistent</a></td></tr>
          <tr><th>2.5</th><td><a href="#2.5">Querying the Database for Objects</a></td></tr>
          <tr><th>2.6</th><td><a href="#2.6">Updating Persistent Objects</a></td></tr>
	  <tr><th>2.7</th><td><a href="#2.7">Defining and Using Views</a></td></tr>
          <tr><th>2.8</th><td><a href="#2.8">Deleting Persistent Objects</a></td></tr>
          <tr><th>2.9</th><td><a href="#2.9">Summary</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>3</th><td><a href="#3">Working with Persistent Objects</a>
        <table class="toc">
          <tr><th>3.1</th><td><a href="#3.1">Concepts and Terminology</a></td></tr>
	  <tr><th>3.2</th><td><a href="#3.2">Object and View Pointers</a></td></tr>
          <tr><th>3.3</th><td><a href="#3.3">Database</a></td></tr>
          <tr><th>3.4</th><td><a href="#3.4">Transactions</a></td></tr>
	  <tr><th>3.5</th><td><a href="#3.5">Connections</a></td></tr>
	  <tr><th>3.6</th><td><a href="#3.6">Error Handling and Recovery</a></td></tr>
          <tr><th>3.7</th><td><a href="#3.7">Making Objects Persistent</a></td></tr>
          <tr><th>3.8</th><td><a href="#3.8">Loading Persistent Objects</a></td></tr>
          <tr><th>3.9</th><td><a href="#3.9">Updating Persistent Objects</a></td></tr>
          <tr><th>3.10</th><td><a href="#3.10">Deleting Persistent Objects</a></td></tr>
	  <tr><th>3.11</th><td><a href="#3.11">Executing Native SQL Statements</a></td></tr>
          <tr><th>3.12</th><td><a href="#3.12">ODB Exceptions</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>4</th><td><a href="#4">Querying the Database</a>
        <table class="toc">
          <tr><th>4.1</th><td><a href="#4.1">ODB Query Language</a></td></tr>
          <tr><th>4.2</th><td><a href="#4.2">Parameter Binding</a></td></tr>
          <tr><th>4.3</th><td><a href="#4.3">Executing a Query</a></td></tr>
          <tr><th>4.4</th><td><a href="#4.4">Query Result</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>5</th><td><a href="#5">Containers</a>
        <table class="toc">
          <tr><th>5.1</th><td><a href="#5.1">Ordered Containers</a></td></tr>
          <tr><th>5.2</th><td><a href="#5.2">Set and Multiset Containers</a></td></tr>
          <tr><th>5.3</th><td><a href="#5.3">Map and Multimap Containers</a></td></tr>
          <tr><th>5.4</th><td><a href="#5.4">Using Custom Containers</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>6</th><td><a href="#6">Relationships</a>
        <table class="toc">
          <tr>
            <th>6.1</th><td><a href="#6.1">Unidirectional Relationships</a>
              <table class="toc">
                <tr><th>6.1.1</th><td><a href="#6.1.1">To-One Relationships</a></td></tr>
		<tr><th>6.1.2</th><td><a href="#6.1.2">To-Many Relationships</a></td></tr>
              </table>
            </td>
          </tr>
	  <tr>
            <th>6.2</th><td><a href="#6.2">Bidirectional Relationships</a>
              <table class="toc">
                <tr><th>6.2.1</th><td><a href="#6.2.1">One-to-One Relationships</a></td></tr>
		<tr><th>6.2.2</th><td><a href="#6.2.2">One-to-Many Relationships</a></td></tr>
		<tr><th>6.2.3</th><td><a href="#6.2.3">Many-to-Many Relationships</a></td></tr>
              </table>
            </td>
          </tr>
          <tr><th>6.3</th><td><a href="#6.3">Lazy Pointers</a></td></tr>
          <tr><th>6.4</th><td><a href="#6.4">Using Custom Smart Pointers</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>7</th><td><a href="#7">Value Types</a>
        <table class="toc">
	  <tr><th>7.1</th><td><a href="#7.1">Simple Value Types</a></td></tr>
	  <tr>
            <th>7.2</th><td><a href="#7.2">Composite Value Types</a>
              <table class="toc">
                <tr><th>7.2.1</th><td><a href="#7.2.1">Composite Value Column and Table Names</a></td></tr>
              </table>
            </td>
          </tr>
	  <tr><th>7.3</th><td><a href="#7.3">Pointers and <code>NULL</code> Value Semantics</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>8</th><td><a href="#8">Inheritance</a>
        <table class="toc">
          <tr><th>8.1</th><td><a href="#8.1">Reuse Inheritance</a></td></tr>
	  <tr><th>8.2</th><td><a href="#8.2">Polymorphism Inheritance</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>9</th><td><a href="#9">Views</a>
        <table class="toc">
          <tr><th>9.1</th><td><a href="#9.1">Object Views</a></td></tr>
	  <tr><th>9.2</th><td><a href="#9.2">Table Views</a></td></tr>
	  <tr><th>9.3</th><td><a href="#9.3">Mixed Views</a></td></tr>
	  <tr><th>9.4</th><td><a href="#9.4">View Query Conditions</a></td></tr>
	  <tr><th>9.5</th><td><a href="#9.5">Native Views</a></td></tr>
	  <tr><th>9.6</th><td><a href="#9.6">Other View Features and Limitations</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>10</th><td><a href="#10">Session</a>
        <table class="toc">
          <tr><th>10.1</th><td><a href="#10.1">Object Cache</a></td></tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>11</th><td><a href="#11">ODB Pragma Language</a>
        <table class="toc">
          <tr>
            <th>11.1</th><td><a href="#11.1">Object Type Pragmas</a>
              <table class="toc">
                <tr><th>11.1.1</th><td><a href="#11.1.1"><code>table</code></a></td></tr>
		<tr><th>11.1.2</th><td><a href="#11.1.2"><code>pointer</code></a></td></tr>
		<tr><th>11.1.3</th><td><a href="#11.1.3"><code>abstract</code></a></td></tr>
		<tr><th>11.1.4</th><td><a href="#11.1.4"><code>readonly</code></a></td></tr>
		<tr><th>11.1.5</th><td><a href="#11.1.5"><code>id</code></a></td></tr>
		<tr><th>11.1.6</th><td><a href="#11.1.6"><code>callback</code></a></td></tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>11.2</th><td><a href="#11.2">View Type Pragmas</a>
              <table class="toc">
		<tr><th>11.2.1</th><td><a href="#11.2.1"><code>object</code></a></td></tr>
                <tr><th>11.2.2</th><td><a href="#11.2.2"><code>table</code></a></td></tr>
		<tr><th>11.2.3</th><td><a href="#11.2.3"><code>query</code></a></td></tr>
		<tr><th>11.2.4</th><td><a href="#11.2.4"><code>pointer</code></a></td></tr>
		<tr><th>11.2.5</th><td><a href="#11.2.5"><code>callback</code></a></td></tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>11.3</th><td><a href="#11.3">Value Type Pragmas</a>
              <table class="toc">
                <tr><th>11.3.1</th><td><a href="#11.3.1"><code>type</code></a></td></tr>
		<tr><th>11.3.2</th><td><a href="#11.3.2"><code>id_type</code></a></td></tr>
		<tr><th>11.3.3</th><td><a href="#11.3.3"><code>null</code>/<code>not_null</code></a></td></tr>
		<tr><th>11.3.4</th><td><a href="#11.3.4"><code>default</code></a></td></tr>
		<tr><th>11.3.5</th><td><a href="#11.3.5"><code>options</code></a></td></tr>
		<tr><th>11.3.6</th><td><a href="#11.3.6"><code>readonly</code></a></td></tr>
		<tr><th>11.3.7</th><td><a href="#11.3.7"><code>unordered</code></a></td></tr>
		<tr><th>11.3.8</th><td><a href="#11.3.8"><code>index_type</code></a></td></tr>
		<tr><th>11.3.9</th><td><a href="#11.3.9"><code>key_type</code></a></td></tr>
		<tr><th>11.3.10</th><td><a href="#11.3.10"><code>value_type</code></a></td></tr>
		<tr><th>11.3.11</th><td><a href="#11.3.11"><code>value_null</code>/<code>value_not_null</code></a></td></tr>
		<tr><th>11.3.12</th><td><a href="#11.3.12"><code>id_options</code></a></td></tr>
		<tr><th>11.3.13</th><td><a href="#11.3.13"><code>index_options</code></a></td></tr>
		<tr><th>11.3.14</th><td><a href="#11.3.14"><code>key_options</code></a></td></tr>
		<tr><th>11.3.15</th><td><a href="#11.3.15"><code>value_options</code></a></td></tr>
		<tr><th>11.3.16</th><td><a href="#11.3.16"><code>id_column</code></a></td></tr>
		<tr><th>11.3.17</th><td><a href="#11.3.17"><code>index_column</code></a></td></tr>
		<tr><th>11.3.18</th><td><a href="#11.3.18"><code>key_column</code></a></td></tr>
		<tr><th>11.3.19</th><td><a href="#11.3.19"><code>value_column</code></a></td></tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>11.4</th><td><a href="#11.4">Data Member Pragmas</a>
              <table class="toc">
                <tr><th>11.4.1</th><td><a href="#11.4.1"><code>id</code></a></td></tr>
                <tr><th>11.4.2</th><td><a href="#11.4.2"><code>auto</code></a></td></tr>
                <tr><th>11.4.3</th><td><a href="#11.4.3"><code>type</code></a></td></tr>
		<tr><th>11.4.4</th><td><a href="#11.4.4"><code>null</code>/<code>not_null</code></a></td></tr>
		<tr><th>11.4.5</th><td><a href="#11.4.5"><code>default</code></a></td></tr>
		<tr><th>11.4.6</th><td><a href="#11.4.6"><code>options</code></a></td></tr>
		<tr><th>11.4.7</th><td><a href="#11.4.7"><code>column</code> (object, composite value)</a></td></tr>
		<tr><th>11.4.8</th><td><a href="#11.4.8"><code>column</code> (view)</a></td></tr>
		<tr><th>11.4.9</th><td><a href="#11.4.9"><code>transient</code></a></td></tr>
		<tr><th>11.4.10</th><td><a href="#11.4.10"><code>readonly</code></a></td></tr>
		<tr><th>11.4.11</th><td><a href="#11.4.11"><code>inverse</code></a></td></tr>
		<tr><th>11.4.12</th><td><a href="#11.4.12"><code>unordered</code></a></td></tr>
		<tr><th>11.4.13</th><td><a href="#11.4.13"><code>table</code></a></td></tr>
		<tr><th>11.4.14</th><td><a href="#11.4.14"><code>index_type</code></a></td></tr>
		<tr><th>11.4.15</th><td><a href="#11.4.15"><code>key_type</code></a></td></tr>
		<tr><th>11.4.16</th><td><a href="#11.4.16"><code>value_type</code></a></td></tr>
		<tr><th>11.4.17</th><td><a href="#11.4.17"><code>value_null</code>/<code>value_not_null</code></a></td></tr>
		<tr><th>11.4.18</th><td><a href="#11.4.18"><code>id_options</code></a></td></tr>
		<tr><th>11.4.19</th><td><a href="#11.4.19"><code>index_options</code></a></td></tr>
		<tr><th>11.4.20</th><td><a href="#11.4.20"><code>key_options</code></a></td></tr>
		<tr><th>11.4.21</th><td><a href="#11.4.21"><code>value_options</code></a></td></tr>
		<tr><th>11.4.22</th><td><a href="#11.4.22"><code>id_column</code></a></td></tr>
		<tr><th>11.4.23</th><td><a href="#11.4.23"><code>index_column</code></a></td></tr>
		<tr><th>11.4.24</th><td><a href="#11.4.24"><code>key_column</code></a></td></tr>
		<tr><th>11.4.25</th><td><a href="#11.4.25"><code>value_column</code></a></td></tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>11.5</th><td><a href="#11.5">C++ Compiler Warnings</a>
              <table class="toc">
                <tr><th>11.5.1</th><td><a href="#11.5.1">GNU C++</a></td></tr>
                <tr><th>11.5.2</th><td><a href="#11.5.2">Visual C++</a></td></tr>
                <tr><th>11.5.3</th><td><a href="#11.5.3">Sun C++</a></td></tr>
		<tr><th>11.5.4</th><td><a href="#11.5.4">IBM XL C++</a></td></tr>
		<tr><th>11.5.5</th><td><a href="#11.5.5">HP aC++</a></td></tr>
              </table>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <tr>
      <th colspan="2"><a href="#II">PART II DATABASE SYSTEMS</a></th>
    </tr>

    <tr>
      <th>12</th><td><a href="#12">MySQL Database</a>
        <table class="toc">
          <tr><th>12.1</th><td><a href="#12.1">MySQL Type Mapping</a></td></tr>
          <tr><th>12.2</th><td><a href="#12.2">MySQL Database Class</a></td></tr>
          <tr><th>12.3</th><td><a href="#12.3">MySQL Connection and Connection Factory</a></td></tr>
	  <tr><th>12.4</th><td><a href="#12.4">MySQL Exceptions</a></td></tr>
	  <tr>
            <th>12.5</th><td><a href="#12.5">MySQL Limitations</a>
              <table class="toc">
                <tr><th>12.5.1</th><td><a href="#12.5.1">Foreign Key Constraints</a></td></tr>
              </table>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>13</th><td><a href="#13">SQLite Database</a>
        <table class="toc">
          <tr><th>13.1</th><td><a href="#13.1">SQLite Type Mapping</a></td></tr>
          <tr><th>13.2</th><td><a href="#13.2">SQLite Database Class</a></td></tr>
          <tr><th>13.3</th><td><a href="#13.3">SQLite Connection and Connection Factory</a></td></tr>
	  <tr><th>13.4</th><td><a href="#13.4">SQLite Exceptions</a></td></tr>
          <tr>
            <th>13.5</th><td><a href="#13.5">SQLite Limitations</a>
              <table class="toc">
                <tr><th>13.5.1</th><td><a href="#13.5.1">Query Result Caching</a></td></tr>
		<tr><th>13.5.2</th><td><a href="#13.5.2">Automatic Assignment of Object Ids</a></td></tr>
		<tr><th>13.5.3</th><td><a href="#13.5.3">Foreign Key Constraints</a></td></tr>
		<tr><th>13.5.4</th><td><a href="#13.5.4">Constraint Violations</a></td></tr>
		<tr><th>13.5.5</th><td><a href="#13.5.5">Sharing of Queries</a></td></tr>
              </table>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>14</th><td><a href="#14">PostgreSQL Database</a>
        <table class="toc">
          <tr><th>14.1</th><td><a href="#14.1">PostgreSQL Type Mapping</a></td></tr>
          <tr><th>14.2</th><td><a href="#14.2">PostgreSQL Database Class</a></td></tr>
          <tr><th>14.3</th><td><a href="#14.3">PostgreSQL Connection and Connection Factory</a></td></tr>
	  <tr><th>14.4</th><td><a href="#14.4">PostgreSQL Exceptions</a></td></tr>
          <tr>
            <th>14.5</th><td><a href="#14.5">PostgreSQL Limitations</a>
              <table class="toc">
                <tr><th>14.5.1</th><td><a href="#14.5.1">Query Result Caching</a></td></tr>
                <tr><th>14.5.2</th><td><a href="#14.5.2">Foreign Key Constraints</a></td></tr>
		<tr><th>14.5.3</th><td><a href="#14.5.3">Date-Time Format</a></td></tr>
		<tr><th>14.5.4</th><td><a href="#14.5.4">Timezones</a></td></tr>
		<tr><th>14.5.5</th><td><a href="#14.5.5"><code>NUMERIC</code> Type Support</a></td></tr>
              </table>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <tr>
      <th colspan="2"><a href="#III">PART III PROFILES</a></th>
    </tr>

    <tr>
      <th>15</th><td><a href="#15">Profiles Introduction</a></td>
    </tr>

    <tr>
      <th>16</th><td><a href="#16">Boost Profile</a>
        <table class="toc">
          <tr><th>16.1</th><td><a href="#16.1">Smart Pointers Library</a></td></tr>
          <tr><th>16.2</th><td><a href="#16.2">Unordered Containers Library</a></td></tr>
	  <tr><th>16.3</th><td><a href="#16.3">Optional Library</a></td></tr>
          <tr>
	    <th>16.4</th><td><a href="#16.4">Date Time Library</a>
	      <table class="toc">
	        <tr><th>16.4.1</th><td><a href="#16.4.1">MySQL Database Type Mapping</a></td></tr>
		<tr><th>16.4.2</th><td><a href="#16.4.2">SQLite Database Type Mapping</a></td></tr>
		<tr><th>16.4.3</th><td><a href="#16.4.3">PostgreSQL Database Type Mapping</a></td></tr>
	      </table>
	    </td>
	  </tr>
        </table>
      </td>
    </tr>

    <tr>
      <th>17</th><td><a href="#17">Qt Profile</a>
        <table class="toc">
          <tr>
	    <th>17.1</th><td><a href="#17.1">Basic Types Library</a>
	      <table class="toc">
	        <tr><th>17.1.1</th><td><a href="#17.1.1">MySQL Database Type Mapping</a></td></tr>
		<tr><th>17.1.2</th><td><a href="#17.1.2">SQLite Database Type Mapping</a></td></tr>
		<tr><th>17.1.3</th><td><a href="#17.1.3">PostgreSQL Database Type Mapping</a></td></tr>	      </table>
	    </td>
	  </tr>
          <tr><th>17.2</th><td><a href="#17.2">Smart Pointers Library</a></td></tr>
          <tr><th>17.3</th><td><a href="#17.3">Containers Library</a></td></tr>
          <tr>
	    <th>17.4</th><td><a href="#17.4">Date Time Library</a>
	      <table class="toc">
	        <tr><th>17.4.1</th><td><a href="#17.4.1">MySQL Database Type Mapping</a></td></tr>
		<tr><th>17.4.2</th><td><a href="#17.4.2">SQLite Database Type Mapping</a></td></tr>
		<tr><th>17.4.3</th><td><a href="#17.4.3">PostgreSQL Database Type Mapping</a></td></tr>
	      </table>
	    </td>
	  </tr>
        </table>
      </td>
    </tr>

  </table>
  </div>

  <hr class="page-break"/>
  <h1><a name="0">Preface</a></h1>

  <p>As more critical aspects of our lives become dependant on software
     systems, more and more applications are required to save the data
     they work on in persistent and reliable storage. Database management
     systems and, in particular, relational database management systems
     (RDBMS) are commonly used for such storage. However, while the
     application development techniques and programming languages have
     evolved significantly over the past decades, the relational database
     technology in this area stayed relatively unchanged. In particular,
     this led to the now infamous mismatch between the object-oriented
     model used by many modern applications and the relational model still
     used by RDBMS.</p>

  <p>While relational databases may be inconvenient to use from modern
     programming languages, they are still the main choice for many
     applications due to their maturity, reliability, as well as the
     availability of tools and alternative implementations.</p>

  <p>To allow application developers to utilize relational databases
     from their object-oriented applications, a technique called
     object-relational mapping (ORM) is often used. It involves a
     conversion layer that maps between objects in the application's
     memory and their relational representation in the database. While
     the object-relational mapping code can be written manually,
     automated ORM systems are available for most object-oriented
     programming languages in use today.</p>

  <p>ODB is an ORM system for the C++ programming language. It was
     designed and implemented with the following main goals:</p>

  <ul class="list">
    <li>Provide a fully-automatic ORM system. In particular, the
        application developer should not have to manually write any
        mapping code, neither for persistent classes nor for their
        data member. </li>

    <li>Provide clean and easy to use object-oriented persistence
        model and database APIs that support the development of realistic
        applications for a wide variety of domains.</li>

    <li>Provide a portable and thread-safe implementation. ODB should be
        written in standard C++ and capable of persisting any standard
        C++ classes.</li>

    <li>Provide profiles that integrate ODB with type systems of
        widely-used frameworks and libraries such as Qt and Boost.</li>

    <li>Provide a high-performance and low overhead implementation. ODB
        should make efficient use of database and application resources.</li>

  </ul>


  <h2><a name="0.1">About This Document</a></h2>

  <p>The goal of this manual is to provide you with an understanding
     of the object persistence model and APIs which are implemented by ODB.
     As such, this document is intended for C++ application developers and
     software architects who are looking for a C++ object persistence
     solution. Prior experience with C++ is required to understand
     this document. A basic understanding of relational database systems
     is advantageous but not expected or required.</p>


  <h2><a name="0.2">More Information</a></h2>

  <p>Beyond this manual, you may also find the following sources of
     information useful:</p>

  <ul class="list">
    <li><a href="http://www.codesynthesis.com/products/odb/doc/odb.xhtml">ODB
        Compiler Command Line Manual.</a></li>

    <li>The <code>INSTALL</code> files in the ODB source packages provide
        build instructions for various platforms.</li>

    <li>The <code>odb-examples</code> package contains a collection of
        examples and a README file with an overview of each example.</li>

    <li>The <a href="http://www.codesynthesis.com/mailman/listinfo/odb-users">odb-users</a>
        mailing list is the place to ask technical questions about ODB.
        Furthermore, the searchable
        <a href="http://www.codesynthesis.com/pipermail/odb-users/">archives</a>
        may already have answers to some of your questions.</li>

  </ul>


  <!-- PART -->


  <hr class="page-break"/>
  <h1><a name="I">PART I&nbsp;&nbsp;
      <span style="font-weight: normal;">OBJECT-RELATIONAL MAPPING</span></a></h1>

  <p>Part I describes the essential database concepts, APIs, and tools that
     together comprise the object-relational mapping for C++ as implemented
     by ODB. It consists of the following chapters.</p>

  <table class="toc">
    <tr><th>1</th><td><a href="#1">Introduction</a></td></tr>
    <tr><th>2</th><td><a href="#2">Hello World Example</a></td></tr>
    <tr><th>3</th><td><a href="#3">Working with Persistent Objects</a></td></tr>
    <tr><th>4</th><td><a href="#4">Querying the Database</a></td></tr>
    <tr><th>5</th><td><a href="#5">Containers</a></td></tr>
    <tr><th>6</th><td><a href="#6">Relationships</a></td></tr>
    <tr><th>7</th><td><a href="#7">Value Types</a></td></tr>
    <tr><th>8</th><td><a href="#8">Inheritance</a></td></tr>
    <tr><th>9</th><td><a href="#9">Views</a></td></tr>
    <tr><th>10</th><td><a href="#10">Session</a></td></tr>
    <tr><th>11</th><td><a href="#11">ODB Pragma Language</a></td></tr>
  </table>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="1">1 Introduction</a></h1>

  <p>ODB is an object-relational mapping (ORM) system for C++. It provides
     tools, APIs, and library support that allow you to persist C++ objects
     to a relational database (RDBMS) without having to deal with tables,
     columns, or SQL and without manually writing any of the mapping code.</p>

  <p>ODB is highly flexible and customizable. It can either completely
     hide the relational nature of the underlying database or expose
     some of the details as required. For example, you can automatically
     map basic C++ types to suitable SQL types, generate the relational
     database schema for your persistent classes, and use simple, safe,
     and yet powerful object query language instead of SQL. Or you can
     assign SQL types to individual data members, use the existing
     database schema, and run native SQL <code>SELECT</code> queries.
     In fact, at an extreme, ODB can be used as <em>just</em> a convenient
     way to handle results of native SQL queries.</p>

  <p>ODB is not a framework. It does not dictate how you should write
     your application. Rather, it is designed to fit into your
     style and architecture by only handling object persistence
     and not interfering with any other functionality. There is
     no common base type that all persistent classes should derive
     from nor are there any restrictions on the data member types
     in persistent classes. Existing classes can be made persistent
     with a few or no modifications.</p>

  <p>ODB has been designed for high performance and low memory
     overhead. Prepared statements are used to send and receive
     object state in binary format instead of text which reduces
     the load on the application and the database server. Extensive
     caching of connections, prepared statements, and buffers saves
     time and resources on connection establishment, statement parsing
     and memory allocations. For each supported database system the
     native C API is used instead of ODBC or higher-level wrapper
     APIs to reduce overhead and provide the most efficient implementation
     for each database operation. Finally, persistent classes have
     zero memory overhead. There are no hidden "database" members
     that each class must have nor are there per-object data structures
     allocated by ODB.</p>

  <p>In this chapter we present a high-level overview of ODB.
     We will start with the ODB architecture and then outline the
     workflow of building an application that uses ODB. We will
     conclude the chapter by contrasting the drawbacks of
     the traditional way of saving C++ objects to relational
     databases with the benefits of using ODB for object
     persistence. The next chapter takes a more hands-on approach
     and shows the concrete steps necessary to implement object
     persistence in a simple "Hello World" application.</p>

  <h2><a name="1.1">1.1 Architecture and Workflow</a></h2>

  <p>From the application developer's perspective, ODB
     consists of three main components: the ODB compiler, the common
     runtime library, called <code>libodb</code>, and the
     database-specific runtime libraries, called
     <code>libodb-&lt;database></code>, where &lt;database> is
     the name of the database system  this runtime
     is for, for example, <code>libodb-mysql</code>. For instance,
     if the application is going to use the MySQL database for
     object persistence, then the three ODB components that this
     application will use are the ODB compiler, <code>libodb</code>
     and <code>libodb-mysql</code>.</p>

  <p>The ODB compiler generates the database support code for
     persistent classes in your application. The input to the ODB
     compiler is one or more C++ header files defining C++ classes
     that you want to make persistent. For each input header file
     the ODB compiler generates a set of C++ source files implementing
     conversion between persistent C++ classes defined in this
     header and their database representation. The ODB compiler
     can also generate a database schema file that creates tables
     necessary to store the persistent classes.</p>

  <p>The ODB compiler is a real C++ compiler except that it produces
     C++ instead of assembly or machine code. In particular, it is not
     an ad-hoc header pre-processor that is only capable of recognizing
     a subset of C++. ODB is capable of parsing any standard C++ code.</p>

  <p>The common runtime library defines database system-independent
     interfaces that your application can use to manipulate persistent
     objects. The database-specific runtime library provides implementations
     of these interfaces for a concrete database as well as other
     database-specific utilities that are used by the generated code.
     Normally, the application does not use the database-specific
     runtime library directly but rather works with it via the common
     interfaces from <code>libodb</code>. The following diagram shows
     the object persistence architecture of an application that uses
     MySQL as the underlying database system:</p>

  <!-- align=center is needed for html2ps -->
  <div class="img" align="center"><img src="odb-arch.png"/></div>

  <p>The ODB system also defines two special-purpose languages:
     the ODB Pragma Language and ODB Query Language. The ODB Pragma
     Language is used to communicate various properties of persistent
     classes to the ODB compiler by means of special <code>#pragma</code>
     directives embedded in the C++ header files. It controls aspects
     of the object-relational mapping such as names of tables and columns
     that are used for persistent classes and their members or mapping between
     C++ types and database types.</p>

  <p>The ODB Query Language is an object-oriented database query
     language that can be used to search for objects matching
     certain criteria. It is modeled after and is integrated into
     C++ allowing you to write expressive and safe queries that look
     and feel like ordinary C++.</p>

  <p>The use of the ODB compiler to generate database support code
     adds an additional step to your application build sequence. The
     following diagram outlines the typical build workflow of an
     application that uses ODB:</p>

  <!-- align=center is needed for html2ps -->
  <div class="img" align="center"><img src="odb-flow.png"/></div>

  <h2><a name="1.2">1.2 Benefits</a></h2>

  <p>The traditional way of saving C++ objects to relational databases
     requires that you manually write code which converts between the database
     and C++ representations of each persistent class. The actions that
     such code usually performs include conversion between C++ values and
     strings or database types, preparation and execution of SQL queries,
     as well as handling the result sets. Writing this code manually has
     the following drawbacks:</p>

  <ul class="list">
    <li><b>Difficult and time consuming.</b> Writing database conversion
        code for any non-trivial application requires extensive
        knowledge of the specific database system and its APIs.
        It can also take a considerable amount of time to write
        and maintain. Supporting multi-threaded applications can
        complicate this task even further.</li>

    <li><b>Suboptimal performance.</b> Optimal conversion often
        requires writing large amounts of extra code, such as
        parameter binding for prepared statements and caching
        of connections, statements, and buffers. Writing code
        like this in an ad-hoc manner is often too difficult
        and time consuming.</li>

    <li><b>Database vendor lock-in.</b> The conversion code is written for
        a specific database which makes it hard to switch to another
        database vendor.</li>

    <li><b>Lack of type safety.</b> It is easy to misspell column names or
        pass incompatible values in SQL queries. Such errors will
        only be detected at runtime.</li>

    <li><b>Complicates the application.</b> The database conversion code
        often ends up interspersed throughout the application making it
        hard to debug, change, and maintain.</li>
  </ul>

  <p>In contrast, using ODB for C++ object persistence has the
     following benefits:</p>

  <ul class="list">
    <li><b>Ease of use.</b> ODB automatically generates database conversion
        code from your C++ class declarations and allows you to manipulate
        persistent objects using simple and thread-safe object-oriented
        database APIs.</li>

    <li><b>Concise code.</b> With ODB hiding the details of the underlying
        database, the application logic is written using the natural object
        vocabulary instead of tables, columns and SQL. The resulting code
        is simpler and thus easier to read and understand.</li>

    <li><b>Optimal performance.</b> ODB has been designed for high performance
        and low memory overhead. All the available optimization techniques,
        such as prepared statements and extensive connection, statement,
        and buffer caching, are used to provide the most efficient
        implementation for each database operation.</li>

    <li><b>Database portability.</b> Because the database conversion code
        is automatically generated, it is easy to switch from one database
        vendor to another. In fact, it is possible to test your application
        on several database systems before making a choice.</li>

    <li><b>Safety.</b> The ODB object persistence and query APIs are
        statically typed. You use C++ identifiers instead of strings
        to refer to object members and the generated code makes sure
        database and C++ types are compatible. All this helps catch
        programming errors at compile-time rather than at runtime.</li>

    <li><b>Maintainability.</b> Automatic code generation minimizes the
        effort needed to adapt the application to changes in persistent
        classes. The database support code is kept separately from the
        class declarations and application logic. This makes the
        application easier to debug and maintain.</li>
  </ul>

  <p>Overall, ODB provides an easy to use yet flexible and powerful
     object-relational mapping (ORM) system for C++. Unlike other
     ORM implementations for C++ that still require you to write
     database conversion or member registration code for each
     persistent class, ODB keeps persistent classes purely
     declarative. The functional part, the database conversion
     code, is automatically generated by the ODB compiler from
     these declarations.</p>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="2">2 Hello World Example</a></h1>

  <p>In this chapter we will show how to create a simple C++
     application that relies on ODB for object persistence using
     the traditional "Hello World" example. In particular, we will
     discuss how to declare persistent classes, generate database
     support code, as well as compile and run our application. We
     will also learn how to make objects persistent, load, update
     and delete persistent objects, as well as query the database
     for persistent objects that match certain criteria. The example
     also shows how to define and use views, a mechanism that allows
     us to create projections of persistent objects, database tables,
     or to handle results of native SQL queries.</p>

  <p>The code presented in this chapter is based on the
     <code>hello</code> example which can be found in the
     <code>odb-examples</code> package of the ODB distribution.</p>

  <h2><a name="2.1">2.1 Declaring a Persistent Class</a></h2>

  <p>In our "Hello World" example we will depart slightly from
     the norm and say hello to people instead of the world. People
     in our application will be represented as objects of C++ class
     <code>person</code> which is saved in <code>person.hxx</code>:</p>

  <pre class="c++">
// person.hxx
//

#include &lt;string>

class person
{
public:
  person (const std::string&amp; first,
          const std::string&amp; last,
          unsigned short age);

  const std::string&amp;
  first () const;

  const std::string&amp;
  last () const;

  unsigned short
  age () const;

  void
  age (unsigned short);

private:
  std::string first_;
  std::string last_;
  unsigned short age_;
};
  </pre>

  <p>In order not to miss anyone whom we need to greet, we would like
  to save the <code>person</code> objects in a database. To achieve this
  we declare the <code>person</code> class as persistent:</p>

  <pre class="c++">
// person.hxx
//

#include &lt;string>

#include &lt;odb/core.hxx>     // (1)

#pragma db object           // (2)
class person
{
  ...

private:
  person () {}              // (3)

  friend class odb::access; // (4)

  #pragma db id auto        // (5)
  unsigned long id_;        // (5)

  std::string first_;
  std::string last_;
  unsigned short age_;
};
  </pre>

  <p>To be able to save the <code>person</code> objects in the database
     we had to make five changes, marked with (1) to (5), to the original
     class definition. The first change is the inclusion of the ODB
     header <code>&lt;odb/core.hxx></code>. This header provides a number
     of core ODB declarations, such as <code>odb::access</code>, that
     are used to define persistent classes.</p>

  <p>The second change is the addition of <code>db&nbsp;object</code>
     pragma just before the class definition. This pragma tells the
     ODB compiler that the class that follows is persistent. Note
     that making a class persistent does not mean that all objects
     of this class will automatically be stored in the database.
     You would still create ordinary or <em>transient</em> instances
     of this class just as you would before. The difference is that
     now you can make such transient instances persistent, as we will
     see shortly.</p>

  <p>The third change is the addition of the default constructor.
     The ODB-generated database support code will use this constructor
     when instantiating an object from the persistent state. Just as we have
     done for the <code>person</code> class, you can make the default
     constructor private or protected if you don't want to make it
     available to the users of your class.</p>

  <p>With the fourth change we make the <code>odb::access</code> class a
     friend of our <code>person</code> class. This is necessary to make
     the default constructor and the data members accessible to the
     ODB support code. If your class has public default constructor and
     public data members, then the <code>friend</code> declaration is
     unnecessary.</p>

  <p>The final change adds a data member called <code>id_</code> which
     is preceded by another pragma. In ODB every persistent object must
     have a unique, within its class, identifier. Or, in other words,
     no two persistent instances of the same type have equal
     identifiers. For our class we use an integer id. The
     <code>db&nbsp;id auto</code> pragma that precedes the <code>id_</code>
     member tells the ODB compiler that the following member is the
     object's identifier. The <code>auto</code> specifier indicates that it
     is a database-assigned id. A unique id will be automatically generated
     by the database and assigned to the object when it is made
     persistent.</p>

  <p>In this example we chose to add an identifier because none of
     the existing members could serve the same purpose. However, if
     a class already has a member with suitable properties, then it
     is natural to use that member as an identifier. For example,
     if our <code>person</code> class contained some form of personal
     identification (SSN in the United States or ID/passport number
     in other countries), then we could use that as an id. Or, if
     we stored an email associated with each person, then we could
     have used that since each person is presumed to have a unique
     email address, for example:</p>

  <pre class="c++">
class person
{
  ...

  #pragma db id
  std::string email_;

  std::string first_;
  std::string last_;
  unsigned short age_;
};
  </pre>

  <p>Now that we have the header file with the persistent class, let's
     see how we can generate that database support code.</p>

  <h2><a name="2.2">2.2 Generating Database Support Code</a></h2>

  <p>The persistent class definition that we created in the previous
     section was particularly light on any code that could actually
     do the job and store the person's data to a database. There
     was no serialization or deserialization code, not even data member
     registration, that you would normally have to write by hand in
     other ORM libraries for C++. This is because in ODB code
     that translates between the database and C++ representations
     of an object is automatically generated by the ODB compiler.</p>

  <p>To compile the <code>person.hxx</code> header we created in the
     previous section and generate the support code for the MySQL
     database, we invoke the ODB compiler from a terminal (UNIX) or
     a command prompt (Windows):</p>

  <pre class="terminal">
odb -d mysql --generate-query person.hxx
  </pre>

  <p>We will use MySQL as the database of choice in the remainder of
     this chapter, though other supported database systems can be used
     instead.</p>

  <p>If you haven't installed the common ODB runtime library
     (<code>libodb</code>) or installed it into a directory where
     C++ compilers don't search for headers by default,
     then you may get the following error:</p>

  <pre class="terminal">
person.hxx:10:24: fatal error: odb/core.hxx: No such file or directory
  </pre>

  <p>To resolve this you will need to specify the <code>libodb</code> headers
     location with the <code>-I</code> preprocessor option, for example:</p>

  <pre class="terminal">
odb -I.../libodb -d mysql --generate-query person.hxx
  </pre>

  <p>Here <code>.../libodb</code> represents the path to the
     <code>libodb</code> directory.</p>

  <p>The above invocation of the ODB compiler produces three C++ files:
     <code>person-odb.hxx</code>, <code>person-odb.ixx</code>,
     <code>person-odb.cxx</code>. You normally don't use types
     or functions contained in these files directly. Rather, all
     you have to do is include <code>person-odb.hxx</code> in
     C++ files where you are performing database operations
     with classes from <code>person.hxx</code> as well as compile
     <code>person-odb.cxx</code> and link the resulting object
     file to your application.</p>

  <p>You may be wondering what the <code>--generate-query</code>
     option is for. It instructs the ODB compiler to generate
     optional query support code that we will use later in our
     "Hello World" example. Another option that we will find
     useful is <code>--generate-schema</code>. This option
     makes the ODB compiler generate a fourth file,
     <code>person.sql</code>, which is the database schema
     for the persistent classes defined in <code>person.hxx</code>:</p>

  <pre class="terminal">
odb -d mysql --generate-query --generate-schema person.hxx
  </pre>

  <p>The database schema file contains SQL statements that creates
     tables necessary to store the persistent classes. We will learn
     how to use it in the next section.</p>

  <p>If you would like to see a list of all the available ODB compiler
     options, refer to the
     <a href="http://www.codesynthesis.com/products/odb/doc/odb.xhtml">ODB
     Compiler Command Line Manual</a>.</p>

  <p>Now that we have the persistent class and the database support
     code, the only part that is left is the application code that
     does something useful with all of this. But before we move on to
     the fun part, let's first learn how to build and run an application
     that uses ODB. This way when we have some application code
     to try, there are no more delays before we can run it.</p>

  <h2><a name="2.3">2.3 Compiling and Running</a></h2>

  <p>Assuming that the <code>main()</code> function with the application
     code is saved in <code>driver.cxx</code> and the database support
     code and schema are generated as described in the previous section,
     to build our application we will first need to compile all the C++
     source files and then link them with two ODB runtime libraries.</p>

  <p>On UNIX, the compilation part can be done with the following commands
     (substitute <code>c++</code> with your C++ compiler name; for Microsoft
     Visual Studio setup, see the <code>odb-examples</code> package):</p>

  <pre class="terminal">
c++ -c driver.cxx
c++ -c person-odb.cxx
  </pre>

  <p>Similar to the ODB compilation, if you get an error stating that
  a header in <code>odb/</code> or <code>odb/mysql</code> directory
  is not found, you will need to use the <code>-I</code>
  preprocessor option to specify the location of the common ODB runtime
  library (<code>libodb</code>) and MySQL ODB runtime library
  (<code>libodb-mysql</code>).</p>

  <p>Once the compilation is done, we can link the application with
  the following command:</p>

  <pre class="terminal">
c++ -o driver driver.o person-odb.o -lodb-mysql -lodb
  </pre>

  <p>Notice that we link our application with two ODB libraries:
    <code>libodb</code> which is a common runtime library and
    <code>libodb-mysql</code> which is a MySQL runtime library
    (if you use another database, then the name of this library
    will change accordingly). If you get an error saying that
    one of these libraries could not be found, then you will need
    to use the <code>-L</code> linker option to specify their locations.</p>

  <p>Before we can run our application we need to create a database
    schema using the generated <code>person.sql</code> file. For MySQL
    we can use the <code>mysql</code> client program, for example:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
  </pre>

  <p>The above command will log in to a local MySQL server as user
    <code>odb_test</code> without a password and use the database
    named <code>odb_test</code>. Beware that after executing this
    command, all the data stored in the <code>odb_test</code> database
    will be deleted.</p>

  <p>Note also that using a standalone generated SQL file is not the
     only way to create a database schema in ODB. We can also embed
     the schema directly into our application or use custom schemas
     that were not generated by the ODB compiler. Refer to
     <a href="#3.3">Section 3.3, "Database"</a> for details.</p>

  <p>Once the database schema is ready, we run our application
  using the same login and database name:</p>

  <pre class="terminal">
./driver --user odb_test --database odb_test
  </pre>


  <h2><a name="2.4">2.4 Making Objects Persistent</a></h2>

  <p>Now that we have the infrastructure work out of the way, it
  is time to see our first code fragment that interacts with the
  database. In this section we will learn how to make <code>person</code>
  objects persistent:</p>

  <pre class="c++">
// driver.cxx
//

#include &lt;memory>   // std::auto_ptr
#include &lt;iostream>

#include &lt;odb/database.hxx>
#include &lt;odb/transaction.hxx>

#include &lt;odb/mysql/database.hxx>

#include "person.hxx"
#include "person-odb.hxx"

using namespace std;
using namespace odb::core;

int
main (int argc, char* argv[])
{
  try
  {
    auto_ptr&lt;database> db (new odb::mysql::database (argc, argv));

    unsigned long john_id, jane_id, joe_id;

    // Create a few persistent person objects.
    //
    {
      person john ("John", "Doe", 33);
      person jane ("Jane", "Doe", 32);
      person joe ("Joe", "Dirt", 30);

      transaction t (db->begin ());

      // Make objects persistent and save their ids for later use.
      //
      john_id = db->persist (john);
      jane_id = db->persist (jane);
      joe_id = db->persist (joe);

      t.commit ();
    }
  }
  catch (const odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl;
    return 1;
  }
}
  </pre>

  <p>Let's examine this code piece by piece. At the beginning we include
     a bunch of headers. After the standard C++ headers we include
     <code>&lt;odb/database.hxx></code>
     and <code>&lt;odb/transaction.hxx></code> which define database
     system-independent <code>odb::database</code> and
     <code>odb::transaction</code> interfaces. Then we include
     <code>&lt;odb/mysql/database.hxx></code> which defines the
     MySQL implementation of the <code>database</code> interface. Finally,
     we include <code>person.hxx</code> and <code>person-odb.hxx</code>
     which define our persistent <code>person</code> class.</p>

  <p>Then we have two <code>using namespace</code> directives. The first
     one brings in the names from the standard namespace and the second
     brings in the ODB declarations which we will use later in the file.
     Notice that in the second directive we use the <code>odb::core</code>
     namespace instead of just <code>odb</code>. The former only brings
     into the current namespace the essential ODB names, such as the
     <code>database</code> and <code>transaction</code> classes, without
     any of the auxiliary objects. This minimizes the likelihood of name
     conflicts with other libraries. Note also that you should continue
     using the <code>odb</code> namespace when qualifying individual names.
     For example, you should write <code>odb::database</code>, not
     <code>odb::core::database</code>.</p>

  <p>Once we are in <code>main()</code>, the first thing we do is create
     the MySQL database object. Notice that this is the last line in
     <code>driver.cxx</code> that mentions MySQL explicitly; the rest
     of the code works through the common interfaces and is database
     system-independent. We use the <code>argc</code>/<code>argv</code>
     <code>mysql::database</code> constructor which automatically
     extract the database parameters, such as login name, password,
     database name, etc., from the command line. In your own applications
     you may prefer to use other <code>mysql::database</code>
     constructors which allow you to pass this information directly
     (<a href="#12.2">Section 12.2, "MySQL Database Class"</a>).</p>

  <p>Next, we create three <code>person</code> objects. Right now they are
     transient objects, which means that if we terminate the application
     at this point, they will be gone without any evidence of them ever
     existing. The next line starts a database transaction. We discuss
     transactions in detail later in this manual. For now, all we need
     to know is that all ODB database operations must be performed within
     a transaction and that a transaction is an atomic unit of work; all
     database operations performed within a transaction either succeed
     (committed) together or are automatically undone (rolled back).</p>

  <p>Once we are in a transaction, we call the <code>persist()</code>
     database function on each of our <code>person</code> objects.
     At this point the state of each object is saved in the database.
     However, note that this state is not permanent until and unless
     the transaction is committed. If, for example, our application
     crashes at this point, there will still be no evidence of our
     objects ever existing.</p>

  <p>In our case, one more thing happens when we call <code>persist()</code>.
     Remember that we decided to use database-assigned identifiers for our
     <code>person</code> objects. The call to <code>persist()</code> is
     where this assignment happens. Once this function returns, the
     <code>id_</code> member contains this object's unique identifier.
     As a convenience, the <code>persist()</code> function also returns
     a copy of the object's identifier that it made persistent. We
     save the returned identifier for each object in a local variable.
     We will use these identifiers later in the chapter to perform other
     database operations on our persistent objects.</p>

  <p>After we have persisted our objects, it is time to commit the
     transaction and make the changes permanent. Only after the
     <code>commit()</code> function returns successfully, are we
     guaranteed that the objects are made persistent. Continuing
     with the crash example, if our application terminates after
     the commit for whatever reason, the objects' state in the
     database will remain intact. In fact, as we will discover
     shortly, our application can be restarted and load the
     original objects from the database. Note also that a
     transaction must be committed explicitly with the
     <code>commit()</code> call. If the <code>transaction</code>
     object leaves scope without the transaction being
     explicitly committed or rolled back, it will automatically be
     rolled back. This behavior allows you not to worry about
     exceptions being thrown within a transaction; if they
     cross the transaction boundary, the transaction will
     automatically be rolled back and all the changes made
     to the database undone.</p>

  <p>The final bit of code in our example is the <code>catch</code>
     block that handles the database exceptions. We do this by catching
     the base ODB exception (<a href="#3.12">Section 3.12, "ODB
     Exceptions"</a>) and printing the diagnostics.</p>

  <p>Let's now compile (<a href="#2.3">Section 2.3, "Compiling and
     Running"</a>) and then run our first ODB application:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
./driver --user odb_test --database odb_test
  </pre>

  <p>Our first application doesn't print anything except for error
     messages so we can't really tell whether it actually stored the
     objects' state in the database. While we will make our application
     more entertaining shortly, for now we can use the <code>mysql</code>
     client to examine the database content. It will also give us a feel
     for how the objects are stored:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test

Welcome to the MySQL monitor.

mysql> select * from person;

+----+-------+------+-----+
| id | first | last | age |
+----+-------+------+-----+
|  1 | John  | Doe  |  33 |
|  2 | Jane  | Doe  |  32 |
|  3 | Joe   | Dirt |  30 |
+----+-------+------+-----+
3 rows in set (0.00 sec)

mysql> quit
  </pre>

  <p>In the next section we will see how to access persistent objects
     from our application.</p>

  <h2><a name="2.5">2.5 Querying the Database for Objects</a></h2>

  <p>So far our application doesn't resemble a typical "Hello World"
     example. It doesn't print anything except for error messages.
     Let's change that and teach our application to say hello to
     people from our database. To make it a bit more interesting,
     let's say hello only to people over 30:</p>

  <pre class="c++">
// driver.cxx
//

...

int
main (int argc, char* argv[])
{
  try
  {
    ...

    // Create a few persistent person objects.
    //
    {
      ...
    }

    typedef odb::query&lt;person> query;
    typedef odb::result&lt;person> result;

    // Say hello to those over 30.
    //
    {
      transaction t (db->begin ());

      result r (db->query&lt;person> (query::age > 30));

      for (result::iterator i (r.begin ()); i != r.end (); ++i)
      {
        cout &lt;&lt; "Hello, " &lt;&lt; i->first () &lt;&lt; "!" &lt;&lt; endl;
      }

      t.commit ();
    }
  }
  catch (const odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl;
    return 1;
  }
}
  </pre>

  <p>The first half of our application is the same as before and is
     replaced with "..." in the above listing for brevity. Again, let's
     examine the rest of it piece by piece.</p>

  <p>The two <code>typedef</code>s create convenient aliases for two
     template instantiations that will be used a lot in our application.
     The first is the query type for the <code>person</code> objects
     and the second is the result type for that query.</p>

  <p>Then we begin a new transaction and call the <code>query()</code>
     database function. We pass a query expression
     (<code>query::age > 30</code>) which limits the returned objects
     only to those with the age greater than 30. We also save the result
     of the query in a local variable.</p>

  <p>The next few lines perform a standard for-loop iteration
     over the result sequence printing hello for every returned person.
     Then we commit the transaction and that's it. Let's see what
     this application will print:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
./driver --user odb_test --database odb_test

Hello, John!
Hello, Jane!
  </pre>


  <p>That looks about right, but how do we know that the query actually
     used the database instead of just using some in-memory artifacts of
     the earlier <code>persist()</code> calls? One way to test this
     would be to comment out the first transaction in our application
     and re-run it without re-creating the database schema. This way the
     objects that were persisted during the previous run will be returned.
     Alternatively, we can just re-run the same application without
     re-creating the schema and notice that we now show duplicate
     objects:</p>

  <pre class="terminal">
./driver --user odb_test --database odb_test

Hello, John!
Hello, Jane!
Hello, John!
Hello, Jane!
  </pre>

  <p>What happens here is that the previous run of our application
     persisted a set of <code>person</code> objects and when we re-run
     the application, we persist another set with the same names but
     with different ids. When we later run the query, matches from
     both sets are returned. We can change the line where we print
     the "Hello" string as follows to illustrate this point:</p>

  <pre class="c++">
cout &lt;&lt; "Hello, " &lt;&lt; i->first () &lt;&lt; " (" &lt;&lt; i->id () &lt;&lt; ")!" &lt;&lt; endl;
  </pre>

  <p>If we now re-run this modified program, again without re-creating
     the database schema, we will get the following output:</p>

  <pre class="terminal">
./driver --user odb_test --database odb_test

Hello, John (1)!
Hello, Jane (2)!
Hello, John (4)!
Hello, Jane (5)!
Hello, John (7)!
Hello, Jane (8)!
  </pre>

  <p>The identifiers 3, 6, and 9 that are missing from the above list belong
     to the "Joe Dirt" objects which are not selected by this query.</p>

  <h2><a name="2.6">2.6 Updating Persistent Objects</a></h2>

  <p>While making objects persistent and then selecting some of them using
     queries are two useful operations, most applications will also need
     to change the object's state and then make these changes persistent.
     Let's illustrate this by updating Joe's age who just had a birthday:</p>

  <pre class="c++">
// driver.cxx
//

...

int
main (int argc, char* argv[])
{
  try
  {
    ...

    unsigned long john_id, jane_id, joe_id;

    // Create a few persistent person objects.
    //
    {
      ...

      // Save object ids for later use.
      //
      john_id = john.id ();
      jane_id = jane.id ();
      joe_id = joe.id ();
    }

    // Joe Dirt just had a birthday, so update his age.
    //
    {
      transaction t (db->begin ());

      auto_ptr&lt;person> joe (db->load&lt;person> (joe_id));
      joe->age (joe->age () + 1);
      db->update (*joe);

      t.commit ();
    }

    // Say hello to those over 30.
    //
    {
      ...
    }
  }
  catch (const odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl;
    return 1;
  }
}
  </pre>

  <p>The beginning and the end of the new transaction are the same as
     the previous two. Once within a transaction, we call the
     <code>load()</code> database function to instantiate a
     <code>person</code> object with Joe's persistent state. We
     pass Joe's object identifier that we stored earlier when we
     made this object persistent. While here we use
     <code>std::auto_ptr</code> to manage the returned object, we
     could have also used another smart pointer, for example
     <code>shared_ptr</code> from TR1 or Boost. For more information
     on the object lifetime management and the smart pointers that we
     can use for that, see <a href="#3.2">Section 3.2, "Object
     and View Pointers"</a>.</p>

  <p>With the instantiated object in hand we increment the age
     and call the <code>update()</code> function to update
     the object's state in the database. Once the transaction is
     committed, the changes are made permanent.</p>

  <p>If we now run this application, we will see Joe in the output
     since he is now over 30:</p>

  <pre class="terminal">
mysql --user=odb_test --database=odb_test &lt; person.sql
./driver --user odb_test --database odb_test

Hello, John!
Hello, Jane!
Hello, Joe!
  </pre>

  <p>What if we didn't have an identifier for Joe? Maybe this object
     was made persistent in another run of our application or by another
     application altogether. Provided that we only have one Joe Dirt
     in the database, we can use the query facility to come up with
     an alternative implementation of the above transaction:</p>

  <pre class="c++">
    // Joe Dirt just had a birthday, so update his age. An
    // alternative implementation without using the object id.
    //
    {
      transaction t (db->begin ());

      result r (db->query&lt;person> (query::first == "Joe" &amp;&amp;
                                   query::last == "Dirt"));

      result::iterator i (r.begin ());

      if (i != r.end ())
      {
        auto_ptr&lt;person> joe (i.load ());
        joe->age (joe->age () + 1);
        db->update (*joe);
      }

      t.commit ();
    }
  </pre>

  <h2><a name="2.7">2.7 Defining and Using Views</a></h2>

  <p>Suppose that we need to gather some basic statistics about the people
     stored in our database. Things like the total head count, as well as
     the minimum and maximum ages. One way to do it would be to query
     the database for all the <code>person</code> objects and then
     calculate this information as we iterate over the query result.
     While this approach may work fine for our database with just three
     people in it, it would be very inefficient if we had a large
     number of objects.</p>

  <p>While it may not be conceptually pure from the object-oriented
     programming point of view, a relational database can perform
     some computations much faster and much more economically than
     if we performed the same operations ourselves in the application's
     process.</p>

  <p>To support such cases ODB provides the notion of views. An ODB view
     is a C++ <code>class</code> that embodies a light-weight, read-only
     projection of one or more persistent objects or database tables or
     the result of a native SQL query execution.</p>

  <p>Some of the common applications of views include loading a subset of
     data members from objects or columns database tables, executing and
     handling results of arbitrary SQL queries, including aggregate
     queries, as well as joining multiple objects and/or database
     tables using object relationships or custom join conditions.</p>

  <p>While you can find a much more detailed description of views in
     <a href="#9">Chapter 9, "Views"</a>, here is how we can define
     the <code>person_stat</code> view that returns the basic statistics
     about the <code>person</code> objects:</p>

  <pre class="c++">
#pragma db view object(person)
struct person_stat
{
  #pragma db column("count(" + person::id_ + ")")
  std::size_t count;

  #pragma db column("min(" + person::age_ + ")")
  unsigned short min_age;

  #pragma db column("max(" + person::age_ + ")")
  unsigned short max_age;
};
  </pre>

  <p>To get the result of a view we use the same <code>query()</code>
     function as when querying the database for an object. Here is
     how we can load and print our statistics using the view we have
     just created:</p>

  <pre class="c++">
    // Print some statistics about all the people in our database.
    //
    {
      transaction t (db->begin ());

      odb::result&lt;person_stat> r (db->query&lt;person_stat> ());

      // The result of this query always has exactly one element.
      //
      const person_stat&amp; ps (*r.begin ());

      cout &lt;&lt; "count  : " &lt;&lt; ps.count &lt;&lt; endl
           &lt;&lt; "min age: " &lt;&lt; ps.min_age &lt;&lt; endl
           &lt;&lt; "max age: " &lt;&lt; ps.max_age &lt;&lt; endl;

      t.commit ();
    }
  </pre>

  <p>If we now add the <code>person_stat</code> view to the
     <code>person.hxx</code> header, the above transaction
     to <code>driver.cxx</code>, as well as re-compile and
     re-run our example, then we will see the following
     additional lines in the output:</p>

  <pre>
count  : 3
min age: 31
max age: 33
  </pre>

  <h2><a name="2.8">2.8 Deleting Persistent Objects</a></h2>

  <p>The last operation that we will discuss in this chapter is deleting
     the persistent object from the database. The following code
     fragment shows how we can delete an object given its identifier:</p>

  <pre class="c++">
    // John Doe is no longer in our database.
    //
    {
      transaction t (db->begin ());
      db->erase&lt;person> (john_id);
      t.commit ();
    }
  </pre>

  <p>To delete John from the database we start a transaction, call
     the <code>erase()</code> database function with John's object
     id, and commit the transaction. After the transaction is committed,
     the erased object is no longer persistent.</p>

  <p>If we don't have an object id handy, we can use queries to find
     and delete the object:</p>

  <pre class="c++">
    // John Doe is no longer in our database. An alternative
    // implementation without using the object id.
    //
    {
      transaction t (db->begin ());

      result r (db->query&lt;person> (query::first == "John" &amp;&amp;
                                   query::last == "Doe"));

      result::iterator i (r.begin ());

      if (i != r.end ())
      {
        auto_ptr&lt;person> john (i.load ());
        db->erase (*john);
      }

      t.commit ();
    }
  </pre>

  <h2><a name="2.9">2.9 Summary</a></h2>

  <p>This chapter presented a very simple application which, nevertheless,
     exercised all of the core database functions: <code>persist()</code>,
     <code>query()</code>, <code>load()</code>, <code>update()</code>,
     and <code>erase()</code>. We also saw that writing an application
     that uses ODB involves the following steps:</p>

  <ol>
    <li>Declare persistent classes in header files.</li>
    <li>Compile these headers to generate database support code.</li>
    <li>Link the application with the generated code and two ODB runtime
        libraries.</li>
  </ol>



  <p>Do not be concerned if, at this point, much appears unclear. The intent
     of this chapter is to give you only a general idea of how to persist C++
     objects with ODB. We will cover all the details throughout the remainder
     of this manual.</p>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="3">3 Working with Persistent Objects</a></h1>

  <p>The previous chapters gave us a high-level overview of ODB and
     showed how to use it to store C++ objects in a database. In this
     chapter we will examine the ODB object persistence model as
     well as the core database APIs in greater detail. We will
     start with basic concepts and terminology in <a href="#3.1">Section
     3.1</a> and <a href="#3.2">Section 3.2</a> and continue with the
     discussion of the <code>odb::database</code> class in
     <a href="#3.3">Section 3.3</a>, transactions in
     <a href="#3.4">Section 3.4</a>, and connections in
     <a href="#3.5">Section 3.5</a>. The remainder of this chapter
     deals with the core database operations and concludes with
     the discussion of ODB exceptions.</p>

  <p>In this chapter we will continue to use and expand the
     <code>person</code> persistent class that we have developed in the
     previous chapter.</p>

  <h2><a name="3.1">3.1 Concepts and Terminology</a></h2>

  <p>The term <em>database</em> can refer to three distinct things:
     a general notion of a place where an application stores its data,
     a software implementation for managing this data (for example
     MySQL), and, finally, some database software implementations
     may manage several data stores which are usually distinguished
     by name. This name is also commonly referred to as a database.</p>

  <p>In this manual, when we use the word <em>database</em>, we
     refer to the first meaning above, for example,
     "The <code>update()</code> function saves the object's state to
     the database." The term Database Management System (DBMS) is
     often used to refer to the second meaning of the word database.
     In this manual we will use the term <em>database system</em>
     for short, for example, "Database system-independent
     application code." Finally, to distinguish the third meaning
     from the other two, we will use the term <em>database name</em>,
     for example, "The second option specifies the database name
     that the application should use to store its data."</p>

  <p>In C++ there is only one notion of a type and an instance
     of a type. For example, a fundamental type, such as <code>int</code>,
     is, for the most part, treated the same as a user defined class
     type. However, when it comes to persistence, we have to place
     certain restrictions and requirements on certain C++ types that
     can be stored in the database. As a result, we divide persistent
     C++ types into two groups: <em>object types</em> and <em>value
     types</em>. An instance of an object type is called an <em>object</em>
     and an instance of a value type &mdash; a <em>value</em>.</p>

  <p>An object is an independent entity. It can be stored, updated,
     and deleted in the database independent of other objects.
     Normally, an object has an identifier, called <em>object id</em>,
     that is unique among all instances of an object type within a
     database. In contrast, a value can only be stored in the database
     as part of an object and doesn't have its own unique identifier.</p>

  <p>An object consists of data members which are either values
     (<a href="#7">Chapter 7, "Value Types"</a>), pointers
     to other objects (<a href="#6">Chapter 6, "Relationships"</a>), or
     containers of values or pointers to other objects (<a href="#5">Chapter
     5, "Containers")</a>. Pointers to other objects and containers can
     be viewed as special kinds of values since they also can only
     be stored in the database as part of an object.</p>

  <p>An object type is a C++ class. Because of this one-to-one
     relationship, we will use terms <em>object type</em>
     and <em>object class</em> interchangeably. In contrast,
     a value type can be a fundamental C++ type, such as
     <code>int</code> or a class type, such as <code>std::string</code>.
     If a value consists of other values, then it is called a
     <em>composite value</em> and its type &mdash; a
     <em>composite value type</em> (<a href="#7.2">Section 7.2,
     "Composite Value Types"</a>). Otherwise, the value is
     called <em>simple value</em> and its type &mdash; a
     <em>simple value type</em> (<a href="#7.1">Section 7.1,
     "Simple Value Types"</a>). Note that the distinction between
     simple and composite values is conceptual rather than
     representational. For example, <code>std::string</code>
     is a simple value type because conceptually string is a
     single value even though the representation of the string
     class may contain several data members each of which could be
     considered a value. In fact, the same value type can be
     viewed (and mapped) as both simple and composite by different
     applications.</p>

  <p>While not strictly necessary in a purely object-oriented application,
     practical considerations often require us to only load a
     subset of an object's data members or a combination of members
     from several objects. We may also need to factor out some
     computations to the relational database instead of performing
     them in the application's process. To support such requirements
     ODB distinguishes a third kind of C++ types, called <em>views</em>
     (<a href="#9">Chapter 9, "Views"</a>). An ODB view is a C++
     <code>class</code> that embodies a light-weight, read-only
     projection of one or more persistent objects or database
     tables or the result of a native SQL query execution.</p>

  <p>Understanding how all these concepts map to the relational model
     will hopefully make these distinctions clearer. In a relational
     database an object type is mapped to a table and a value type is
     mapped to one or more columns. A simple value type is mapped
     to a single column while a composite value type is mapped to
     several columns. An object is stored as a row in this
     table and a value is stored as one or more cells in this row.
     A simple value is stored in a single cell while a composite
     value occupies several cells. A view is not a persistent
     entity and it is not stored in the database. Rather, it is a
     data structure that is used to capture a single row of an SQL
     query result.</p>

  <p>Going back to the distinction between simple and composite
     values, consider a date type which has three integer
     members: year, month, and day. In one application it can be
     considered a composite value and each member will get its
     own column in a relational database. In another application
     it can be considered a simple value and stored in a single
     column as a number of days from some predefined date.</p>

  <p>Until now, we have been using the term <em>persistent class</em>
     to refer to object classes. We will continue to do so even though
     a value type can also be a class. The reason for this asymmetry
     is the subordinate nature of value types when it comes to
     database operations. Remember that values are never stored
     directly but rather as part of an object that contains them.
     As a result, when we say that we want to make a C++ class
     persistent or persist an instance of a class in the database,
     we invariably refer to an object class rather than a value
     class.</p>

  <p>To make a C++ class a persistent object class we declare
     it as such using the <code>db&nbsp;object</code> pragma, for
     example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
};
  </pre>

  <p>The other pragma that we often use is <code>db&nbsp;id</code>
     which designates one of the data members as an object id, for
     example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db id
  unsigned long id_;
};
  </pre>

  <p>While it is possible to declare a persistent class without an
     object id, such a class will have limited functionality
     (<a href="#11.1.5">Section 11.1.5, "<code>id</code>"</a>).</p>

  <p>The above two pragmas are the minimum required to declare a
     persistent class with an object id. Other pragmas can be used to
     fine-tune the database-related properties of a class and its
     members (<a href="#11">Chapter 11, "ODB Pragma Language"</a>).</p>

  <p>Normally, an object class should define the default constructor. The
     generated database support code uses this constructor when
     instantiating an object from the persistent state. If we add the
     default constructor only for the database support code, then we
     can make it private. It is also possible to have an object type
     without the default constructor. However, in this case, the database
     operations can only load the persistent state into an existing instance
     (<a href="#3.8">Section 3.8, "Loading Persistent Objects"</a>,
     <a href="#4.4">Section 4.4, "Query Result"</a>). <p>The object id type
     should be default-constructible.</p></p>

  <p>If an object class has private or protected non-transient data
     members or if its default constructor is not public, then the
     <code>odb::access</code> class, defined in the
     <code>&lt;odb/core.hxx></code> header, should be declared a
     friend of this object type. For example:</p>

  <pre class="c++">
#include &lt;odb/core.hxx>

#pragma db object
class person
{
  ...

private:
  friend class odb::access;

  person () {}

  #pragma db id
  unsigned long id_;
};
  </pre>

  <p>You may be wondering whether we also have to declare value types
     as persistent. We don't need to do anything special for simple value
     types such as <code>int</code> or <code>std::string</code> since the
     ODB compiler knows how to map them to suitable database system types and
     how to convert between the two. On the other hand, if a simple value
     is unknown to the ODB compiler then we will need to provide the
     mapping to the database system type and, possibly, the code to
     convert between the two. For more information on how to achieve
     this refer to the <code>db&nbsp;type</code> pragma description
     in <a href="#11.3.1">Section 11.3.1, "<code>type</code>"</a>. Similar
     to object types, composite value types have to be explicitly declared
     as persistent using the <code>db&nbsp;value</code> pragma, for example:</p>

  <pre class="c++">
#pragma db value
class name
{
  ...

  std::string first_;
  std::string last_;
};
  </pre>

  <p>Composite value types are discussed in more detail in
     <a href="#7.2">Section 7.2, "Composite Value Types"</a>.</p>

  <p>Normally, you would use object types to model real-world entities,
     things that have their own identity. For example, in the
     previous chapter we created a <code>person</code> class to model
     a person, which is a real-world entity. Name and age, which we
     used as data members in our <code>person</code> class are clearly
     values. It is hard to think of age 31 or name "Joe" as having their
     own identities.</p>

  <p>A good test to determine whether something is an object or
     a value, is to consider if other objects might reference
     it. A person is clearly an object because it can be referred
     to by other objects such as a spouse, an employer, or a
     bank. On the other hand, a person's age or name is not
     something that other objects would normally refer to.</p>

  <p>Also, when an object represents a real entity, it is easy to
     choose a suitable object id. For example, for a
     person there is an established notion of an identifier
     (SSN, student id, passport number, etc). Another alternative
     is to use a person's email address as an identifier.</p>

  <p>Note, however, that these are only guidelines. There could
     be good reasons to make something that would normally be
     a value an object. Consider, for example, a database that
     stores a vast number of people. Many of the <code>person</code>
     objects in this database have the same names and surnames and
     the overhead of storing them in every object may negatively
     affect the performance. In this case, we could make the first name
     and last name each an object and only store pointers to
     these objects in the <code>person</code> class.</p>

  <p>An instance of a persistent class can be in one of two states:
    <em>transient</em> and <em>persistent</em>. A transient
    instance only has a representation in the application's
    memory and will cease to exist when the application terminates,
    unless it is explicitly made persistent. In other words, a
    transient instance of a persistent class behaves just like an
    instance of any ordinary C++ class. A persistent instance
    has a representation in both the application's memory and the
    database. A persistent instance will remain even after the
    application terminates unless and until it is explicitly
    deleted from the database.</p>

  <h2><a name="3.2">3.2 Object and View Pointers</a></h2>

  <p>As we have seen in the previous chapter, some database operations
     create dynamically allocated instances of persistent classes and
     return pointers to these instances. As we will see in later chapters,
     pointers are also used to establish relationships between objects
     (<a href="#6">Chapter 6, "Relationships"</a>) as well as to cache
     persistent objects in a session (<a href="#10">Chapter 10,
     "Session"</a>). While in most cases you won't need to deal with
     pointers to views, it is possible to a obtain a dynamically allocated
     instance of a view using the <code>result_iterator::load()</code>
     function (<a href="#4.4">Section 4.4, "Query Results"</a>).</p>

  <p>By default, all these mechanisms use raw pointers to return
     objects and views as well as to pass and cache objects. This
     is normally sufficient for applications
     that have simple object lifetime requirements and do not use sessions
     or object relationships. In particular, a dynamically allocated object
     or view that is returned as a raw pointer from a database operation
     can be assigned to a smart pointer of our choice, for example
     <code>std::auto_ptr</code> or <code>shared_ptr</code> from TR1 or
     Boost.</p>

  <p>However, to avoid any possibility of a mistake, such as forgetting
     to use a smart pointer for a returned object or view, as well as to
     simplify the use of more advanced ODB functionality, such as sessions
     and bidirectional object relationships, it is recommended that you use
     smart pointers with the sharing semantics as object and view pointers.
     The <code>shared_ptr</code> smart pointer from TR1 or Boost is a good
     default choice.</p>

  <p>ODB provides two mechanisms for changing the object or view pointer
     type. We can use the <code>--default-pointer</code> option to specify
     the default pointer. All objects and views that don't have the pointer
     type explicitly specified with the <code>db&nbsp;pointer</code>
     pragma (see below) will use the default pointer type. Refer to the
     <a href="http://www.codesynthesis.com/products/odb/doc/odb.xhtml">ODB
     Compiler Command Line Manual</a> for details on this option's argument.
     The typical usage is shown below:</p>

  <pre class="terminal">
--default-pointer std::tr1::shared_ptr
  </pre>

  <p>The second mechanism allows us to specify the pointer type on
     the per object and per view basis using the
     <code>db&nbsp;pointer</code> pragma, for example:</p>

  <pre class="c++">
#pragma db object pointer(std::tr1::shared_ptr)
class person
{
  ...
};
  </pre>

  <p>Refer to <a href="#11.1.2">Section 11.1.2, "<code>pointer</code>
     (object)"</a> and <a href="#11.2.4">Section 11.2.4, "<code>pointer</code>
     (view)"</a> for more information on this pragma.</p>

  <p>Built-in support that is provided by the ODB runtime library allows us
     to use the TR1 <code>shared_ptr</code> and <code>std::auto_ptr</code> as
     pointer types. Plus, ODB profile libraries, that are available for
     commonly used frameworks and libraries (such as Boost and Qt),
     provide support for smart pointers found in these frameworks and
     libraries (<a href="#III">Part III, "Profiles"</a>). It is also
     easy to add support for our own smart pointers, as described in
     <a href="#6.4"> Section 6.4, "Using Custom Smart Pointers"</a>.</p>

  <h2><a name="3.3">3.3 Database</a></h2>

  <p>Before an application can make use of persistence services
     offered by ODB, it has to create a database class instance. A
     database instance is the representation of the place where
     the application stores its persistent objects. We create
     a database instance by instantiating one of the database
     system-specific classes. For example, <code>odb::mysql::database</code>
     would be such a class for the MySQL database system. We will
     also normally pass a database name as an argument to the
     class' constructor. The following code fragment
     shows how we can create a database instance for the MySQL
     database system:</p>

  <pre class="c++">
#include &lt;odb/database.hxx>
#include &lt;odb/mysql/database.hxx>

auto_ptr&lt;odb::database> db (
  new odb::mysql::database (
    "test_user"     // database login name
    "test_password" // database password
    "test_database" // database name
    ));
  </pre>

  <p>The <code>odb::database</code> class is a common interface for
     all the database system-specific classes provided by ODB. You
     would normally work with the database
     instance via this interface unless there is a specific
     functionality that your application depends on and which is
     only exposed by a particular system's <code>database</code>
     class. You will need to include the <code>&lt;odb/database.hxx></code>
     header file to make this class available in your application.</p>

  <p>The <code>odb::database</code> interface defines functions for
     starting transactions and manipulating persistent objects.
     These are discussed in detail in the remainder of this chapter
     as well as the next chapter which is dedicated to the topic of
     querying the database for persistent objects. For details on the
     system-specific <code>database</code> classes, refer to
     <a href="#II">Part II, "Database Systems"</a>.</p>

  <p>Before we can persist our objects, the corresponding database schema has
     to be created in the database. The schema contains table definitions and
     other relational database artifacts that are used to store the state of
     persistent objects in the database.</p>

  <p>There are several ways to create the database schema. The easiest is to
     instruct the ODB compiler to generate the corresponding schema from the
     persistent classes (<code>--generate-schema</code> option). The ODB
     compiler can generate the schema either as a standalone SQL file or
     embedded into the generated C++ code (<code>--schema-format</code>
     option).  If we are using the SQL file to create the database schema, then
     this file should be executed, normally only once, before the application
     is started.</p>

  <p>Alternatively, the schema can be embedded directly into the generated
     code and we can use the <code>odb::schema_catalog</code> class to
     create it in the database from within our application,
     for example:</p>

  <pre class="c++">
#include &lt;odb/schema-catalog.hxx>

odb::transaction t (db->begin ());
odb::schema_catalog::create_schema (*db);
t.commit ();
  </pre>

  <p>Refer to the next section for information on the
     <code>odb::transaction</code> class.  The complete version of the above
     code fragment is available in the <code>schema/embedded</code> example in
     the <code>odb-examples</code> package.</p>

  <p>The <code>odb::schema_catalog</code> class has the following interface.
     You will need to include the <code>&lt;odb/schema-catalog.hxx></code>
     header file to make this class available in your application.</p>

  <pre class="c++">
namespace odb
{
  class schema_catalog
  {
  public:
    static void
    create_schema (database&amp;, const std::string&amp; name = "");
  };
}
  </pre>

  <p>The first argument to the <code>create_schema()</code> function
     is the database instance that we would like to create the schema in.
     The second argument is the schema name. By default, the ODB
     compiler generates all embedded schemas with the default schema
     name (empty string). However, if your application needs to
     have several separate schemas, you can use the
     <code>--default-schema</code> ODB compiler option to assign
     custom schema names and then use these names as a second argument
     to <code>create_schema()</code>. If the schema is not found,
     <code>create_schema()</code> throws the
     <code>odb::unknown_schema</code> exception. The
     <code>create_schema()</code> function should be called within
     a transaction.</p>

  <p>Finally, we can also use a custom database schema with ODB. This approach
     can work similarly to the standalone SQL file described above except that
     the database schema is hand-written or produced by another program. Or we
     could execute custom SQL statements that create the schema directly from
     our application. To map persistent classes to custom database schemas, ODB
     provides a wide range of mapping customization pragmas, such
     as <code>db&nbsp;table</code>, <code>db&nbsp;column</code>,
     and <code>db&nbsp;type</code> (<a href="#11">Chapter 11, "ODB Pragma
     Language"</a>). For sample code that shows how to perform such mapping
     for various C++ constructs, refer to the <code>schema/custom</code>
     example in the <code>odb-examples</code> package.</p>

  <h2><a name="3.4">3.4 Transactions</a></h2>

  <p>A transaction is an atomic, consistent, isolated and durable
     (ACID) unit of work. Database operations can only be
     performed within a transaction and each thread of execution
     in an application can have only one active transaction at a
     time.</p>

  <p>By atomicity we mean that when it comes to making changes to
     the database state within a transaction,
     either all the changes are applied or none at all. Consider,
     for example, a transaction that transfers funds between two
     objects representing bank accounts. If the debit function
     on the first object succeeds but the credit function on
     the second fails, the transaction is rolled back and the
     database state of the first object remains unchanged.</p>

  <p>By consistency we mean that a transaction must take all the
     objects stored in the database from one consistent state
     to another. For example, if a bank account object must
     reference a person object as its owner and we forget to
     set this reference before making the object persistent,
     the transaction will be rolled back and the database
     will remain unchanged.</p>

  <p>By isolation we mean that the changes made to the database
     state during a transaction are only visible inside this
     transaction until and unless it is committed. Using the
     above example with the bank transfer, the results of the
     debit operation performed on the first object is not
     visible to other transactions until the credit operation
     is successfully completed and the transaction is committed.</p>

  <p>By durability we mean that once the transaction is committed,
     the changes that it made to the database state are permanent
     and will survive failures such as an application crash. From
     now on the only way to alter this state is to execute and commit
     another transaction.</p>

  <p>A transaction is started by calling either the
     <code>database::begin()</code> or <code>connection::begin()</code>
     function. The returned transaction handle is stored in
     an instance of the <code>odb::transaction</code> class.
     You will need to include the <code>&lt;odb/transaction.hxx></code>
     header file to make this class available in your application.
     For example:</p>

  <pre class="c++">
#include &lt;odb/transaction.hxx>

transaction t (db.begin ())

// Perform database operations.

t.commit ();
  </pre>

  <p>The <code>odb::transaction</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  class transaction
  {
  public:
    typedef odb::database database_type;
    typedef odb::connection connection_type;

    transaction (transaction_impl*, bool make_current = true)

    void
    commit ();

    void
    rollback ();

    database_type&amp;
    database ();

    connection_type&amp;
    connection ();

    static bool
    has_current ();

    static transaction&amp;
    current ();

    static void
    current (transaction&amp;);

    static bool
    reset_current ();
  };
}
  </pre>

  <p>The <code>commit()</code> function commits a transaction and
     <code>rollback()</code> rolls it back. Unless the transaction
     has been <em>finalized</em>, that is, explicitly committed or rolled
     back, the destructor of the <code>odb::transaction</code> class will
     automatically roll it back when the transaction instance goes
     out of scope. If we try to commit or roll back a finalized
     transaction, the <code>odb::transaction_already_finalized</code>
     exception is thrown.</p>

  <p>The <code>database()</code> accessor returns the database this
     transaction is working on. Similarly, the <code>connection()</code>
     accessor returns the database connection this transaction is on
     (<a href="#3.5">Section 3.5, "Connections"</a>).</p>

  <p>The static <code>current()</code> accessor returns the
     currently active transaction for this thread. If there is no active
     transaction, this function throws the <code>odb::not_in_transaction</code>
     exception. We can check whether there is a transaction in effect in
     this thread using the <code>has_current()</code> static function.</p>

  <p>The <code>make_current</code> argument in the <code>transaction</code>
     constructor as well as the static <code>current()</code> modifier and
     <code>reset_current()</code> function give us additional
     control over the nomination of the currently active transaction.
     If we pass <code>false</code> as the <code>make_current</code>
     argument, then the newly created transaction will not
     automatically be made the active transaction for this
     thread. Later, we can use the static <code>current()</code> modifier
     to set this transaction as the active transaction.
     The <code>reset_current()</code> static function clears the
     currently active transaction. Together, these mechanisms
     allow for more advanced use cases, such as multiplexing
     two or more transactions on the same thread. For example:</p>

  <pre class="c++">
transaction t1 (db1.begin ());        // Active transaction.
transaction t2 (db2.begin (), false); // Not active.

// Perform database operations on db1.

transaction::current (t2);            // Deactivate t1, activate t2.

// Perform database operations on db2.

transaction::current (t1);            // Switch back to t1.

// Perform some more database operations on db1.

t1.commit ();

transaction::current (t2);            // Switch to t2.

// Perform some more database operations on db2.

t2.commit ();
  </pre>

  <p>Note that in the above discussion of atomicity, consistency,
     isolation, and durability, all of those guarantees only apply
     to the object's state in the database as opposed to the object's
     state in the application's memory. It is possible to roll
     a transaction back but still have changes from this
     transaction in the application's memory. An easy way to
     avoid this potential inconsistency is to instantiate
     persistent objects only within the transaction scope. Consider,
     for example, these two implementations of the same transaction:</p>

  <pre class="c++">
void
update_age (database&amp; db, person&amp; p)
{
  transaction t (db.begin ());

  p.age (p.age () + 1);
  db.update (p);

  t.commit ();
}
  </pre>

  <p>In the above implementation, if the <code>update()</code> call fails
     and the transaction is rolled back, the state of the <code>person</code>
     object in the database and the state of the same object in the
     application's memory will differ. Now consider an
     alternative implementation which only instantiates the
     <code>person</code> object for the duration of the transaction:</p>

  <pre class="c++">
void
update_age (database&amp; db, unsigned long id)
{
  transaction t (db.begin ());

  auto_ptr&lt;person> p (db.load&lt;person> (id));
  p.age (p.age () + 1);
  db.update (p);

  t.commit ();
}
  </pre>

  <p>Of course, it may not always be possible to write the
     application in this style. Oftentimes we need to access and
     modify the application's state of persistent objects out of
     transactions. In this case it may make sense to try to
     roll back the changes made to the application state if
     the transaction was rolled back and the database state
     remains unchanged. One way to do this is to re-load
     the object's state from the database, for example:</p>

  <pre class="c++">
void
update_age (database&amp; db, person&amp; p)
{
  try
  {
    transaction t (db.begin ());

    p.age (p.age () + 1);
    db.update (p);

    t.commit ();
  }
  catch (...)
  {
    transaction t (db.begin ());
    db.load (p.id (), p);
    t.commit ();

    throw;
  }
}
  </pre>

  <h2><a name="3.5">3.5 Connections</a></h2>

  <p>The <code>odb::connection</code> class represents a connection
     to the database. Normally, you wouldn't work with connections
     directly but rather let the ODB runtime obtain and release
     connections as needed. However, certain use cases may require
     obtaining a connection manually. For completeness, this section
     describes the <code>connection</code> class and discusses some
     of its use cases. You may want to skip this section if you are
     reading through the manual for the first time.</p>

  <p>Similar to <code>odb::database</code>, the <code>odb::connection</code>
     class is a common interface for all the database system-specific
     classes provided by ODB. For details on the system-specific
     <code>connection</code> classes, refer to <a href="#II">Part II,
     "Database Systems"</a>.</p>

  <p>To make the <code>odb::connection</code> class available in your
     application you will need to include the <code>&lt;odb/connection.hxx></code>
     header file. The <code>odb::connection</code> class has the
     following interface:</p>

  <pre>
namespace odb
{
  class connection
  {
  public:
    typedef odb::database database_type;

    transaction
    begin () = 0;

    unsigned long long
    execute (const char* statement);

    unsigned long long
    execute (const std::string&amp; statement);

    unsigned long long
    execute (const char* statement, std::size_t length);

    database_type&amp;
    database ();
  };

  typedef details::shared_ptr&lt;connection> connection_ptr;
}
  </pre>

  <p>The <code>begin()</code> function is used to start a transaction
     on the connection. The <code>execute()</code> functions allow
     us to execute native database statements on the connection.
     Their semantics are equivalent to the <code>database::execute()</code>
     functions (<a href="#3.11">Section 3.11, "Executing Native SQL
     Statements"</a>) except that they can be legally called outside
     a transaction. Finally, the <code>database()</code> accessor
     returns a reference to the <code>odb::database</code> instance
     to which this connection corresponds.</p>

  <p>To obtain a connection we call the <code>database::connection()</code>
     function. The connection is returned as <code>odb::connection_ptr</code>,
     which is an implementation-specific smart pointer with the shared
     pointer semantics. This, in particular, means that the connection
     pointer can be copied and returned from functions. Once the last
     instance of <code>connection_ptr</code> pointing to the same
     connection is destroyed, the connection is returned to the
     <code>database</code> instance. The following code fragment
     shows how we can obtain, use, and release a connection:</p>

  <pre>
using namespace odb::core;

database&amp; db = ...
connection_ptr c (db.connection ());

// Temporarily disable foreign key constraints.
//
c->execute ("SET FOREIGN_KEY_CHECKS = 0");

// Start a transaction on this connection.
//
transaction t (c->begin ());
...
t.commit ();

// Restore foreign key constraints.
//
c->execute ("SET FOREIGN_KEY_CHECKS = 1");

// When 'c' goes out of scope, the connection is returned to 'db'.
  </pre>

  <p>Some of the use cases which may require direct manipulation of
     connections include out-of-transaction statement execution,
     such as the execution of connection configuration statements,
     the implementation of a connection-per-thread policy, and making
     sure that a set of transactions is executed on the same
     connection.</p>

  <h2><a name="3.6">3.6 Error Handling and Recovery</a></h2>

  <p>ODB uses C++ exceptions to report database operation errors. Most
     ODB exceptions signify <em>hard</em> errors or errors that cannot
     be corrected without some intervention from the application.
     For example, if we try to load an object with an unknown object
     id, the <code>odb::object_not_persistent</code> exception is
     thrown. Our application may be able to correct this error, for
     instance, by obtaining a valid object id and trying again.
     The hard errors and corresponding ODB exceptions that can be
     thrown by each database function are described in the remainder
     of this chapter with <a href="#3.12">Section 3.12, "ODB Exceptions"</a>
     providing a quick reference for all the ODB exceptions.</p>

  <p>The second group of ODB exceptions signify <em>soft</em> or
     <em>recoverable</em> errors. Such errors are temporary
     failures which normally can be corrected by simply re-executing
     the transaction. ODB defines three such exceptions:
     <code>odb::connection_lost</code>, <code>odb::timeout</code>,
     and <code>odb::deadlock</code>. All recoverable ODB exceptions
     are derived from the common <code>odb::recoverable</code> base
     exception which can be used to handle all the recoverable
     conditions with a single <code>catch</code> block.</p>

  <p>The <code>odb::connection_lost</code> exception is thrown if
     a connection to the database is lost in the middle of
     a transaction. In this situation the transaction is aborted but
     it can be re-tried without any changes. Similarly, the
     <code>odb::timeout</code> exception is thrown if one of the
     database operations or the whole transaction has timed out.
     Again, in this case the transaction is aborted but can be
     re-tried as is.</p>

  <p>If two or more transactions access or modify more than one object
     and are executed concurrently by different applications or by
     different threads within the same application, then it is possible
     that these transactions will try to access objects in an incompatible
     order and deadlock. The canonical example of a deadlock are
     two transactions in which the first has modified <code>object1</code>
     and is waiting for the second transaction to commit its changes to
     <code>object2</code> so that it can also update <code>object2</code>.
     At the same time the second transaction has modified <code>object2</code>
     and is waiting for the first transaction to commit its changes to
     <code>object1</code> because it also needs to modify <code>object1</code>.
     As a result, none of the two transactions can be completed.</p>

  <p>The database system detects such situations and automatically
     aborts the waiting operation in one of the deadlocked transactions.
     In ODB this translates to the <code>odb::deadlock</code>
     recoverable exception being thrown from one of the database functions.</p>

  <p>The following code fragment shows how to handle the recoverable
     exceptions by restarting the affected transaction:</p>

  <pre class="c++">
const unsigned short max_retries = 5;

for (unsigned short retry_count (0); ; retry_count++)
{
  try
  {
    transaction t (db.begin ());

    ...

    t.commit ();
    break;
  }
  catch (const odb::recoverable&amp; e)
  {
    if (retry_count > max_retries)
      throw retry_limit_exceeded (e.what ());
    else
      continue;
  }
}
  </pre>

  <h2><a name="3.7">3.7 Making Objects Persistent</a></h2>

  <p>A newly created instance of a persistent class is transient.
     We use the <code>database::persist()</code> function template
     to make a transient instance persistent. This function has four
     overloaded versions with the following signatures:</p>

  <pre class="c++">
  template &lt;typename T>
  typename object_traits&lt;T>::id_type
  persist (const T&amp; object);

  template &lt;typename T>
  typename object_traits&lt;T>::id_type
  persist (const object_traits&lt;T>::const_pointer_type&amp; object);

  template &lt;typename T>
  typename object_traits&lt;T>::id_type
  persist (T&amp; object);

  template &lt;typename T>
  typename object_traits&lt;T>::id_type
  persist (const object_traits&lt;T>::pointer_type&amp; object);
  </pre>

  <p>Here and in the rest of the manual,
     <code>object_traits&lt;T>::pointer_type</code> and
     <code>object_traits&lt;T>::const_pointer_type</code> denote the
     unrestricted and constant object pointer types (<a href="#3.2">Section
     3.2, "Object and View Pointers"</a>), respectively.
     Similarly, <code>object_traits&lt;T>::id_type</code> denotes the object
     id type. The <code>odb::object_traits</code> template is part of the
     database support code generated by the ODB compiler.</p>

  <p>The first <code>persist()</code> function expects a constant reference
     to an instance being persisted. The second function expects a constant
     object pointer. Both of these functions can only be used on objects with
     application-assigned object ids (<a href="#11.4.2">Section 11.4.2,
     "<code>auto</code>"</a>).</p>

  <p>The second and third <code>persist()</code> functions are similar to the
     first two except that they operate on unrestricted references and object
     pointers. If the identifier of the object being persisted is assigned
     by the database, these functions update the id member of the passed
     instance with the assigned value. All four functions return the object
     id of the newly persisted object.</p>

  <p>If the database already contains an object of this type with this
     identifier, the <code>persist()</code> functions throw the
     <code>odb::object_already_persistent</code> exception. This should
     never happen for database-assigned object ids as long as the
     number of objects persisted does not exceed the value space of
     the id type.</p>

  <p>When calling the <code>persist()</code> functions, we don't need to
     explicitly specify the template type since it will be automatically
     deduced from the argument being passed. The following example shows
     how we can call these functions:</p>

<pre class="c++">
person john ("John", "Doe", 33);
shared_ptr&lt;person> jane (new person ("Jane", "Doe", 32));

transaction t (db.begin ());

db->persist (john);
unsigned long jane_id (db.persist (jane));

t.commit ();

cerr &lt;&lt; "Jane's id: " &lt;&lt; jane_id &lt;&lt; endl;
</pre>

  <p>Notice that in the above code fragment we have created instances
     that we were planning to make persistent before starting the
     transaction. Likewise, we printed Jane's id after we have committed
     the transaction. As a general rule, you should avoid performing
     operations within the transaction scope that can be performed
     before the transaction starts or after it terminates. An active
     transaction consumes both your application's resources, such as
     a database connection, as well as the database server's
     resources, such as object locks. By following the above rule you
     make sure these resources are released and made available to other
     threads in your application and to other applications as soon as
     possible.</p>

  <h2><a name="3.8">3.8 Loading Persistent Objects</a></h2>

  <p>Once an object is made persistent, and you know its object id, it
     can be loaded by the application using the <code>database::load()</code>
     function template. This function has two overloaded versions with
     the following signatures:</p>

  <pre class="c++">
  template &lt;typename T>
  typename object_traits&lt;T>::pointer_type
  load (const typename object_traits&lt;T>::id_type&amp; id);

  template &lt;typename T>
  void
  load (const typename object_traits&lt;T>::id_type&amp; id, T&amp; object);
  </pre>

  <p>Given an object id, the first function allocates a new instance
     of the object class in the dynamic memory, loads its state from
     the database, and returns the pointer to the new instance. The
     second function loads the object's state into an existing instance.
     Both functions throw <code>odb::object_not_persistent</code> if
     there is no object of this type with this id in the database.</p>

  <p>When we call the first <code>load()</code> function, we need to
     explicitly specify the object type. We don't need to do this for
     the second function because the object type will be automatically
     deduced from the second argument, for example:</p>

  <pre class="c++">
transaction t (db.begin ());

auto_ptr&lt;person> jane (db.load&lt;person> (jane_id));

db.load (jane_id, *jane);

t.commit ();
  </pre>

  <p>If we don't know for sure whether an object with a given id
     is persistent, we can use the <code>find()</code> function
     instead of <code>load()</code>, for example:</p>

  <pre class="c++">
  template &lt;typename T>
  typename object_traits&lt;T>::pointer_type
  find (const typename object_traits&lt;T>::id_type&amp; id);

  template &lt;typename T>
  bool
  find (const typename object_traits&lt;T>::id_type&amp; id, T&amp; object);
  </pre>

  <p>If an object with this id is not found in the database, the first
     <code>find()</code> function returns a <code>NULL</code> pointer
     while the second function leaves the passed instance unmodified and
     returns <code>false</code>.</p>

  <p>If we don't know the object id, then we can use queries to
     find the object (or objects) matching some criteria
     (<a href="#4">Chapter 4, "Querying the Database"</a>). Note,
     however, that loading an object's state using its
     identifier can be significantly faster than executing a query.</p>


  <h2><a name="3.9">3.9 Updating Persistent Objects</a></h2>

  <p>If a persistent object has been modified, we can store the updated
     state in the database using the <code>database::update()</code>
     function template. This function has three overloaded versions with
     the following signatures:</p>

  <pre class="c++">
  template &lt;typename T>
  void
  update (const T&amp; object);

  template &lt;typename T>
  void
  update (const object_traits&lt;T>::const_pointer_type&amp; object);

  template &lt;typename T>
  void
  update (const object_traits&lt;T>::pointer_type&amp; object);
  </pre>

  <p>The first <code>update()</code> function expects an object reference,
     while the other two expect object pointers. If the object passed to
     one of these functions does not exist in the database,
     <code>update()</code> throws the <code>odb::object_not_persistent</code>
     exception.</p>

  <p>Below is an example of the funds transfer that we talked about
     in the earlier section on transactions. It uses the hypothetical
     <code>bank_account</code> persistent class:</p>

  <pre class="c++">
void
transfer (database&amp; db,
          unsigned long from_acc,
          unsigned long to_acc,
          unsigned int amount)
{
  bank_account from, to;

  transaction t (db.begin ());

  db.load (from_acc, from);

  if (from.balance () &lt; amount)
    throw insufficient_funds ();

  db.load (to_acc, to);

  to.balance (to.balance () + amount);
  from.balance (from.balance () - amount);

  db.update (to);
  db.update (from);

  t.commit ();
}
  </pre>

  <p>The same can be accomplished using dynamically allocated objects
     and the <code>update()</code> function with object pointer argument,
     for example:</p>

  <pre class="c++">
transaction t (db.begin ());

shared_ptr&lt;bank_account> from (db.load&lt;bank_account> (from_acc));

if (from->balance () &lt; amount)
  throw insufficient_funds ();

shared_ptr&lt;bank_account> to (db.load&lt;bank_account> (to_acc));

to->balance (to->balance () + amount);
from->balance (from->balance () - amount);

db.update (to);
db.update (from);

t.commit ();
  </pre>

  <p>In ODB persistent classes, composite value types, as well as individual
     data members can be declared read-only (see <a href="#11.1.4">Section
     11.1.4, "<code>readonly</code> (object)"</a>, <a href="#11.3.6">Section
     11.3.6, "<code>readonly</code> (composite value)"</a>, and
     <a href="#11.4.10">Section 11.4.10, "<code>readonly</code>
     (data member)"</a>).</p>

  <p>If an individual data member is declared read-only, then
     any changes to this member will be ignored when updating the database
     state of an object using any of the above <code>update()</code>
     functions. A <code>const</code> data member is automatically treated
     as read-only. If a composite value is declared read-only then all its
     data members are treated as read-only.</p>

  <p>If the whole object is declared read-only then the database state of
     this object cannot be changed. Calling any of the above
     <code>update()</code> functions for such an object will result in a
     compile-time error.</p>

  <h2><a name="3.10">3.10 Deleting Persistent Objects</a></h2>

  <p>To delete a persistent object's state from the database we use the
     <code>database::erase()</code> or <code>database::erase_query()</code>
     function templates. If the application still has an instance of the
     erased object, this instance becomes transient. The <code>erase()</code>
     function has the following overloaded versions:</p>

  <pre class="c++">
  template &lt;typename T>
  void
  erase (const T&amp; object);

  template &lt;typename T>
  void
  erase (const object_traits&lt;T>::const_pointer_type&amp; object);

  template &lt;typename T>
  void
  erase (const object_traits&lt;T>::pointer_type&amp; object);

  template &lt;typename T>
  void
  erase (const typename object_traits&lt;T>::id_type&amp; id);
  </pre>

  <p>The first <code>erase()</code> function uses an object itself, in
     the form of an object reference, to delete its state from the
     database. The next two functions accomplish the same result but using
     object pointers. Note that all three functions leave the passed
     object unchanged. It simply becomes transient. The last function
     uses the object id to identify the object to be deleted. If the
     object does not exist in the database, then all four functions
     throw the <code>odb::object_not_persistent</code> exception.</p>

  <p>We have to specify the object type when calling the last
     <code>erase()</code> function. The same is unnecessary for the
     first three functions because the object type will be automatically
     deduced from their arguments. The following example shows how we
     can call these functions:</p>

  <pre class="c++">
person&amp; john = ...
shared_ptr&lt;jane> jane = ...
unsigned long joe_id = ...

transaction t (db.begin ());

db.erase (john);
db.erase (jane);
db.erase&lt;person> (joe_id);

t.commit ();
  </pre>

  <p>The <code>erase_query()</code> function allows us to delete
     the state of multiple objects matching certain criteria. It uses
     the query expression of the <code>database::query()</code> function
     (<a href="#4">Chapter 4, "Querying the Database"</a>) and,
     because the ODB query facility is optional, it is only available
     if the <code>--generate-query</code> ODB compiler option was
     specified. The <code>erase_query()</code> function has the
     following overloaded versions:</p>

  <pre class="c++">
  template &lt;typename T>
  unsigned long long
  erase_query ();

  template &lt;typename T>
  unsigned long long
  erase_query (const odb::query&lt;T>&amp;);
  </pre>

  <p>The first <code>erase_query()</code> function is used to delete
     the state of all the persistent objects of a given type stored
     in the database. The second function uses the passed query instance
     to only delete the state of objects matching the query criteria.
     Both functions return the number of objects erased. When calling
     the <code>erase_query()</code> function, we have to explicitly
     specify the object type we are erasing. For example:</p>

  <pre class="c++">
typedef odb::query&lt;person> query;

transaction t (db.begin ());

db.erase_query&lt;person> (query::last == "Doe" &amp;&amp; query::are &lt; 30);

t.commit ();
  </pre>

  <p>Unlike the <code>query()</code> function, when calling
     <code>erase_query()</code> we cannot use members from pointed-to
     objects in the query expression. However, we can still use
     a member corresponding to a pointer as an ordinary object
     member that has the id type of the pointed-to object
     (<a href="#6">Chapter 6, "Relationships"</a>). This allows us
     to compare object ids as well as test the pointer for
     <code>NULL</code>. As an example, the following transaction
     makes sure that all the <code>employee</code> objects that
     reference an <code>employer</code> object that is about to
     be deleted are deleted as well. Here we assume that the
     <code>employee</code> class contains a pointer to the
     <code>employer</code> class. Refer to <a href="#6">Chapter 6,
     "Relationships"</a> for complete definitions of these
     classes.</p>

  <pre class="c++">
typedef odb::query&lt;employee> query;

transaction t (db.begin ());

employer&amp; e = ... // Employer object to be deleted.

db.erase_query&lt;employee> (query::employer == e.id ());
db.erase (e);

t.commit ();
  </pre>


  <h2><a name="3.11">3.11 Executing Native SQL Statements</a></h2>

  <p>In some situations we may need to execute native SQL statements
     instead of using the object-oriented database API described above.
     For example, we may want to tune the database schema generated
     by the ODB compiler or take advantage of a feature that is
     specific to the database system we are using. The
     <code>database::execute()</code> function, which has three
     overloaded versions, provides this functionality:</p>

  <pre class="c++">
  unsigned long long
  execute (const char* statement);

  unsigned long long
  execute (const std::string&amp; statement);

  unsigned long long
  execute (const char* statement, std::size_t length)
  </pre>

  <p>The first <code>execute()</code> function expects the SQL statement
     as a zero-terminated C-string. The last version expects the explicit
     statement length as the second argument and the statement itself
     may contain <code>'\0'</code> characters, for example, to represent
     binary data, if the database system supports it. All three functions
     return the number of rows that were affected by the statement. For
     example:</p>

  <pre class="c++">
transaction t (db.begin ());

db.execute ("DROP TABLE test");
db.execute ("CREATE TABLE test (n INT PRIMARY KEY)");

t.commit ();
  </pre>

  <p>While these functions must always be called within a transaction,
     it may be necessary to execute a native statement outside a
     transaction. This can be done using the
     <code>connection::execute()</code> functions as described in
     <a href="#3.5">Section 3.5, "Connections"</a>.</p>

  <h2><a name="3.12">3.12 ODB Exceptions</a></h2>

  <p>In the previous sections we have already mentioned some of the
     exceptions that can be thrown by the database functions. In this
     section we will discuss the ODB exception hierarchy and document
     all the exceptions that can be thrown by the common ODB
     runtime.</p>

  <p>The root of the ODB exception hierarchy is the abstract
     <code>odb::exception</code> class. This class derives
     from <code>std::exception</code> and has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  struct exception: std::exception
  {
    virtual const char*
    what () const throw () = 0;
  };
}
  </pre>

  <p>Catching this exception guarantees that we will catch all the
     exceptions thrown by ODB. The <code>what()</code> function
     returns a human-readable description of the condition that
     triggered the exception.</p>

  <p>The concrete exceptions that can be thrown by ODB are presented
     in the following listing:</p>

  <pre class="c++">
namespace odb
{
  struct null_pointer: exception
  {
    virtual const char*
    what () const throw ();
  };

  // Transaction exceptions.
  //
  struct already_in_transaction: exception
  {
    virtual const char*
    what () const throw ();
  };

  struct not_in_transaction: exception
  {
    virtual const char*
    what () const throw ();
  };

  struct transaction_already_finalized: exception
  {
    virtual const char*
    what () const throw ();
  };

  // Session exceptions.
  //
  struct already_in_session: exception
  {
    virtual const char*
    what () const throw ();
  };

  struct not_in_session: exception
  {
    virtual const char*
    what () const throw ();
  };

  // Database operations exceptions.
  //
  struct recoverable: exception
  {
  };

  struct connection_lost: recoverable
  {
    virtual const char*
    what () const throw ();
  };

  struct timeout: recoverable
  {
    virtual const char*
    what () const throw ();
  };

  struct deadlock: recoverable
  {
    virtual const char*
    what () const throw ();
  };

  struct object_not_persistent: exception
  {
    virtual const char*
    what () const throw ();
  };

  struct object_already_persistent: exception
  {
    virtual const char*
    what () const throw ();
  };

  struct result_not_cached: exception
  {
    virtual const char*
    what () const throw ();
  };

  struct database_exception: exception
  {
  };

  // Schema catalog exceptions.
  //
  struct unknown_schema: exception
  {
    const std::string&amp;
    name () const;

    virtual const char*
    what () const throw ();
  };
}
  </pre>

  <p>The <code>null_pointer</code> exception is thrown when a
     pointer to a persistent object declared non-<code>NULL</code>
     with the <code>db&nbsp;not_null</code> or
     <code>db&nbsp;value_not_null</code> pragma has the <code>NULL</code>
     value. See <a href="#6">Chapter 6, "Relationships"</a> for details.</p>

  <p>The next three exceptions (<code>already_in_transaction</code>,
     <code>not_in_transaction</code>,
     <code>transaction_already_finalized</code>) are thrown by the
     <code>odb::transaction</code> class and are discussed
     in <a href="#3.4">Section 3.4, "Transactions"</a>.</p>

  <p>The next two exceptions (<code>already_in_session</code>, and
     <code>not_in_session</code>) are thrown by the <code>odb::session</code>
     class and are discussed in <a href="#10">Chapter 10, "Session"</a>.</p>

  <p>The <code>recoverable</code> exception serves as a common base
     for all the recoverable exceptions, which are: <code>connection_lost</code>,
     <code>timeout</code>, and <code>deadlock</code>. The
     <code>connection_lost</code> exception is thrown when a connection
     to the database is lost. Similarly, the <code>timeout</code> exception
     is thrown if one of the database operations or the whole transaction
     has timed out. The <code>deadlock</code> exception is thrown when a
     transaction deadlock is detected by the database system. These
     exceptions can be thrown by any database function. See
     <a href="#3.6">Section 3.6, "Error Handling and Recovery"</a>
     for details.</p>

  <p>The <code>object_already_persistent</code> exception is thrown
     by the <code>persist()</code> database function. See
     <a href="#3.7">Section 3.7, "Making Objects Persistent"</a>
     for details.</p>

  <p>The <code>object_not_persistent</code> exception is thrown
     by the <code>load()</code>  and <code>update()</code>
     database functions. Refer to
     <a href="#3.8">Section 3.8, "Loading Persistent Objects"</a> and
     <a href="#3.9">Section 3.9, "Updating Persistent Objects"</a> for
     more information.</p>

  <p>The <code>result_not_cached</code> exception is thrown by
     the query result class. Refer to <a href="#4.4">Section 4.4,
     "Query Result"</a> for details.</p>

  <p>The <code>database_exception</code> exception is a base class for all
     database system-specific exceptions that are thrown by the
     database system-specific runtime library. Refer to <a href="#II">Part
     II, "Database Systems"</a> for more information.</p>

  <p>The <code>unknown_schema</code> exception is thrown by the
     <code>odb::schema_catalog</code> class if a schema with the specified
     name is not found. Refer to <a href="#3.3">Section 3.3, "Database"</a>
     for details.</p>

  <p>The <code>odb::exception</code> class is defined in the
     <code>&lt;odb/exception.hxx></code> header file. All the
     concrete ODB exceptions are defined in
     <code>&lt;odb/exceptions.hxx></code> which also includes
     <code>&lt;odb/exception.hxx></code>. Normally you don't
     need to include either of these two headers because they are
     automatically included by <code>&lt;odb/database.hxx></code>.
     However, if the source file that handles ODB exceptions
     does not include <code>&lt;odb/database.hxx></code>, then
     you will need to explicitly include one of these headers.</p>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="4">4 Querying the Database</a></h1>

  <p>If we don't know the identifiers of the objects that we are looking
     for, we can use queries to search the database for objects matching
     certain criteria. The ODB query facility is optional and we need to
     explicitly request the generation of the necessary database support
     code with the <code>--generate-query</code> ODB compiler option.</p>

  <p>ODB provides a flexible query API that offers two distinct levels of
     abstraction from the database system query language such as SQL.
     At the high level we are presented with an easy to use yet powerful
     object-oriented query language, called ODB Query Language. This
     query language is modeled after and is integrated into C++ allowing
     us to write expressive and safe queries that look and feel like
     ordinary C++. We have already seen examples of these queries in the
     introductory chapters. Below is another, more interesting, example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;
  typedef odb::result&lt;person> result;

  unsigned short age;
  query q (query::first == "John" &amp;&amp; query::age &lt; query::_ref (age));

  for (age = 10; age &lt; 100; age += 10)
  {
    result r (db.query&lt;person> (q));
    ...
  }
  </pre>

  <p>At the low level, queries can be written as predicates using
     the database system-native query language such as the
     <code>WHERE</code> predicate from the SQL <code>SELECT</code>
     statement. This language will be referred to as native query
     language. At this level ODB still takes care of converting
     query parameters from C++ to the database system format. Below
     is the re-implementation of the above example using SQL as
     the native query language:</p>

  <pre class="c++">
  query q ("first = 'John' AND age = " + query::_ref (age));
  </pre>

  <p>Note that at this level we lose the static typing of
     query expressions. For example, if we wrote something like this:</p>

  <pre class="c++">
  query q (query::first == 123 &amp;&amp; query::agee &lt; query::_ref (age));
  </pre>

  <p>We would get two errors during the C++ compilation. The first would
     indicate that we cannot compare <code>query::first</code> to an
     integer and the second would pick the misspelling in
     <code>query::agee</code>. On the other hand, if we wrote something
     like this:</p>

  <pre class="c++">
  query q ("first = 123 AND agee = " + query::_ref (age));
  </pre>

  <p>It would compile fine and would trigger an error only when executed
     by the database system.</p>

  <p>We can also combine the two query languages in a single query, for
     example:</p>

  <pre class="c++">
  query q ("first = 'John'" + (query::age &lt; query::_ref (age)));
  </pre>

  <h2><a name="4.1">4.1 ODB Query Language</a></h2>

  <p>An ODB query is an expression that tells the database system whether
     any given object matches the desired criteria. As such, a query expression
     always evaluates as <code>true</code> or <code>false</code>. At
     the higher level, an expression consists of other expressions
     combined with logical operators such as <code>&amp;&amp;</code> (AND),
     <code>||</code> (OR), and <code>!</code> (NOT). For example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;

  query q (query::first == "John" || query::age == 31);
  </pre>

  <p>At the core of every query expression lie simple expressions which
     involve one or more object members, values, or parameters. To
     refer to an object member we use an expression such as
     <code>query::first</code> above. The names of members in the
     <code>query</code> class are derived from the names of data members
     in the object class by removing the common member name decorations,
     such as leading and trailing underscores, the <code>m_</code> prefix,
     etc.</p>

  <p>In a simple expression an object member can be compared to a value,
     parameter, or another member using a number of predefined operators
     and functions. The following table gives an overview of the available
     expressions:</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="operators" border="1">
    <tr>
      <th>Operator</th>
      <th>Description</th>
      <th>Example</th>
    </tr>

    <tr>
      <td><code>==</code></td>
      <td>equal</td>
      <td><code>query::age == 31</code></td>
    </tr>

    <tr>
      <td><code>!=</code></td>
      <td>unequal</td>
      <td><code>query::age != 31</code></td>
    </tr>

    <tr>
      <td><code>&lt;</code></td>
      <td>less than</td>
      <td><code>query::age &lt; 31</code></td>
    </tr>

    <tr>
      <td><code>></code></td>
      <td>greater than</td>
      <td><code>query::age > 31</code></td>
    </tr>

    <tr>
      <td><code>&lt;=</code></td>
      <td>less than or equal</td>
      <td><code>query::age &lt;= 31</code></td>
    </tr>

    <tr>
      <td><code>>=</code></td>
      <td>greater than or equal</td>
      <td><code>query::age >= 31</code></td>
    </tr>

    <tr>
      <td><code>in()</code></td>
      <td>one of the values</td>
      <td><code>query::age.in (30, 32, 34)</code></td>
    </tr>

    <tr>
      <td><code>in_range()</code></td>
      <td>one of the values in range</td>
      <td><code>query::age.in_range (begin, end)</code></td>
    </tr>

    <tr>
      <td><code>is_null()</code></td>
      <td>value is NULL</td>
      <td><code>query::age.is_null ()</code></td>
    </tr>

    <tr>
      <td><code>is_not_null()</code></td>
      <td>value is not NULL</td>
      <td><code>query::age.is_not_null ()</code></td>
    </tr>
  </table>

  <p>The <code>in()</code> function accepts a maximum of five arguments.
     Use the <code>in_range()</code> function if you need to compare
     to more than five values. This function accepts a pair of
     standard C++ iterators and compares to all the values from
     the <code>begin</code> position inclusive and until and
     excluding the <code>end</code> position. The following
     code fragment shows how we can use these functions:</p>

  <pre class="c++">
  std::vector&lt;string> names;

  names.push_back ("John");
  names.push_back ("Jack");
  names.push_back ("Jane");

  query q1 (query::first.in ("John", "Jack", "Jane"));
  query q2 (query::first.in_range (names.begin (), names.end ()));
  </pre>



  <p>The operator precedence in the query expressions are the same
     as for equivalent C++ operators. We can use parentheses to
     make sure the expression is evaluated in the desired order.
     For example:</p>

  <pre class="c++">
  query q ((query::first == "John" || query::first == "Jane") &amp;&amp;
           query::age &lt; 31);
  </pre>


  <h2><a name="4.2">4.2 Parameter Binding</a></h2>

  <p>An instance of the <code>odb::query</code> class encapsulates two
     parts of information about the query: the query expression and
     the query parameters. Parameters can be bound to C++ variables
     either by value or by reference.</p>

  <p>If a parameter is bound by value, then the value for this parameter
     is copied from the C++ variable to the query instance at the query
     construction time. On the other hand, if a parameter is bound by
     reference, then the query instance stores a reference to the
     bound variable. The actual value of the parameter is only extracted
     at the query execution time. Consider, for example, the following
     two queries:</p>

  <pre class="c++">
  string name ("John");

  query q1 (query::first == query::_val (name));
  query q2 (query::first == query::_ref (name));

  name = "Jane";

  db.query&lt;person> (q1); // Find John.
  db.query&lt;person> (q2); // Find Jane.
  </pre>

  <p>The <code>odb::query</code> class provides two special functions,
     <code>_val()</code> and <code>_ref()</code>, that allow us to
     bind the parameter either by value or by reference, respectively.
     In the ODB query language, if the binding is not specified
     explicitly, the value semantic is used by default. In the
     native query language, binding must always be specified
     explicitly. For example:</p>

  <pre class="c++">
  query q1 (query::age &lt; age);                // By value.
  query q2 (query::age &lt; query::_val (age));  // By value.
  query q3 (query::age &lt; query::_ref (age));  // By reference.

  query q4 ("age &lt; " + age);                  // Error.
  query q5 ("age &lt; " + query::_val (age));    // By value.
  query q6 ("age &lt; " + query::_ref (age));    // By reference.
  </pre>

  <p>A query that only has by-value parameters does not depend on any
     other variables and is self-sufficient once constructed. A query
     that has one or more by-reference parameters depends on the
     bound variables until the query is executed. If one such variable
     goes out of scope and we execute the query, the behavior is
     undefined.</p>

  <h2><a name="4.3">4.3 Executing a Query</a></h2>

  <p>Once we have the query instance ready and by-reference parameters
     initialized, we can execute the query using the
     <code>database::query()</code> function template. It has two
     overloaded versions:</p>

  <pre class="c++">
  template &lt;typename T>
  result&lt;T>
  query (bool cache = true);

  template &lt;typename T>
  result&lt;T>
  query (const odb::query&lt;T>&amp;, bool cache = true);
  </pre>

  <p>The first <code>query()</code> function is used to return all the
     persistent objects of a given type stored in the database.
     The second function uses the passed query instance to only return
     objects matching the query criteria. The <code>cache</code> argument
     determines whether the objects' states should be cached in the
     application's memory or if they should be returned by the database
     system one by one as the iteration over the result progresses. The
     result caching is discussed in detail in the next section.</p>

  <p>When calling the <code>query()</code> function, we have to
     explicitly specify the object type we are querying. For example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;
  typedef odb::result&lt;person> result;

  result all (db.query&lt;person> ());
  result johns (db.query&lt;person> (query::first == "John"));
  </pre>

  <p>Note that it is not required to explicitly create a named
     query variable before executing it. For example, the following
     two queries are equivalent:</p>

  <pre class="c++">
  query q (query::first == "John");

  result r1 (db.query&lt;person> (q));
  result r1 (db.query&lt;person> (query::first == "John"));
  </pre>

  <p>Normally, we would create a named query instance if we are
     planning to run the same query multiple times and would use the
     in-line version for those that are executed only once. A named
     query instance that does not have any by-reference parameters is
     immutable and can be shared between multiple threads without
     synchronization. On the other hand, a query instance with
     by-reference parameters is modified every time it is executed.
     If such a query is shared among multiple threads, then access
     to this query instance must be synchronized from the execution
     point and until the completion of the iteration over the result.</p>

  <p>It is also possible to create queries from other queries by
     combining them using logical operators. For example:</p>

  <pre class="c++">
result
find_minors (database&amp; db, const query&amp; name_query)
{
  return db.query&lt;person> (name_query &amp;&amp; query::age &lt; 18);
}

result r (find_underage (db, query::first == "John"));
  </pre>

  <h2><a name="4.4">4.4 Query Result</a></h2>

  <p>The result of executing a query is zero, one, or more objects
     matching the query criteria. The result is returned as an instance
     of the <code>odb::result</code> class template, for example:</p>

  <pre class="c++">
  typedef odb::query&lt;person> query;
  typedef odb::result&lt;person> result;

  result johns (db.query&lt;person> (query::first == "John"));
  </pre>

  <p>It is best to view an instance of <code>odb::result</code>
     as a handle to a stream, such as a file stream. While we can
     make a copy of a result or assign one result to another, the
     two instances will refer to the same result stream. Advancing
     the current position in one instance will also advance it in
     another. The result instance is only usable within the transaction
     it was created in. Trying to manipulate the result after the
     transaction has terminated leads to undefined behavior.</p>

  <p>The <code>odb::result</code> class template conforms to the
     standard C++ sequence requirements and has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  template &lt;typename T>
  class result
  {
  public:
    typedef odb::result_iterator&lt;T> iterator;

  public:
    result ();

    result (const result&amp;);

    result&amp;
    operator= (const result&amp;);

    void
    swap (result&amp;)

  public:
    iterator
    begin ();

    iterator
    end ();

  public:
    void
    cache ();

    bool
    empty () const;

    std::size_t
    size () const;
  };
}
  </pre>

  <p>The default constructor creates an empty result set. The
    <code>cache()</code> function caches the returned objects'
    state in the application's memory. We have already mentioned
    result caching when we talked about query execution. As you
    may remember the <code>database::query()</code> function
    caches the result unless instructed not to by the caller.
    The <code>cache()</code> function allows us to
    cache the result at a later stage if it wasn't already
    cached during query execution.</p>

  <p>If the result is cached, the database state of all the returned
     objects is stored in the application's memory. Note that
     the actual objects are still only instantiated on demand
     during result iteration. It is the raw database state that
     is cached in memory. In contrast, for uncached results
     the object's state is sent by the database system one object
     at a time as the iteration progresses.</p>

  <p>Uncached results can improve the performance of both the application
     and the database system in situations where we have a large
     number of objects in the result or if we will only examine
     a small portion of the returned objects. However, uncached
     results have a number of limitations. There can only be one
     uncached result in a transaction. Creating another result
     (cached or uncached) by calling <code>database::query()</code>
     will invalidate the existing uncached result. Furthermore,
     calling any other database functions, such as <code>update()</code>
     or <code>erase()</code> will also invalidate the uncached result.</p>

  <p>The <code>empty()</code> function returns <code>true</code> if
     there are no objects in the result and <code>false</code> otherwise.
     The <code>size()</code> function can only be called for cached results.
     It returns the number of objects in the result. If we call this
     function on an uncached result, the <code>odb::result_not_cached</code>
     exception is thrown.</p>

  <p>To iterate over the objects in a result we use the
     <code>begin()</code> and <code>end()</code> functions
     together with the <code>odb::result&lt;T>::iterator</code>
     type, for example:</p>

  <pre class="c++">
  result r (db.query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    ...
  }
  </pre>

  <p>The result iterator is an input iterator which means that the
     only two position operations that it supports are to move to the
     next object and to determine whether the end of the result stream
     has been reached. In fact, the result iterator can only be in two
     states: the current position and the end position. If we have
     two iterators pointing to the current position and then we
     advance one of them, the other will advance as well. This,
     for example, means that it doesn't make sense to store an
     iterator that points to some object of interest in the result
     stream with the intent of dereferencing it after the iteration
     is over. Instead, we would need to store the object itself.</p>

  <p>The result iterator has the following dereference functions
     that can be used to access the pointed-to object:</p>

  <pre class="c++">
namespace odb
{
  template &lt;typename T>
  class result_iterator
  {
  public:
    T*
    operator-> () const;

    T&amp;
    operator* () const;

    typename object_traits&lt;T>::pointer_type
    load ();

    void
    load (T&amp; x);

    typename object_traits&lt;T>::id_type
    id ();
  };
}
  </pre>

  <p>When we call the <code>*</code> or <code>-></code> operator,
     the iterator will allocate a new instance of the object class
     in the dynamic memory, load its state from the database
     state, and return a reference or pointer to the new instance. The
     iterator maintains the ownership of the returned object and will
     return the same pointer for subsequent calls to either of these
     operators until it is advanced to the next object or we call
     the first <code>load()</code> function (see below). For example:</p>

  <pre class="c++">
  result r (db.query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end ();)
  {
    cout &lt;&lt; i->last () &lt;&lt; endl; // Create an object.
    person&amp; p (*i);             // Reference to the same object.
    cout &lt;&lt; p.age () &lt;&lt; endl;
    ++i;                        // Free the object.
  }
  </pre>

  <p>The overloaded <code>result_iterator::load()</code> functions are
     similar to <code>database::load()</code>. The first function
     returns a dynamically allocated instance of the current
     object. As an optimization, if the iterator already owns an object
     as a result of an earlier
     call to the <code>*</code> or <code>-></code> operator, then it
     relinquishes the ownership of this object and returns it instead.
     This allows us to write code like this without worrying about
     a double allocation:</p>

  <pre class="c++">
  result r (db.query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    if (i->last == "Doe")
    {
      auto_ptr p (i.load ());
      ...
    }
  }
  </pre>

  <p>Note, however, that because of this optimization, a subsequent
     to <code>load()</code> call to the <code>*</code> or <code>-></code>
     operator results in the allocation of a new object.</p>

  <p>The second <code>load()</code> function allows
     us to load the current object's state into an existing instance.
     For example:</p>

  <pre class="c++">
  result r (db.query&lt;person> (query::first == "John"));

  person p;
  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    i.load (p);
    cout &lt;&lt; p.last () &lt;&lt; endl;
    cout &lt;&lt; i.age () &lt;&lt; endl;
  }
  </pre>

  <p>The <code>id()</code> function return the object id of the current
     object. While we can achieve the same by loading the object and getting
     its id, this function is more efficient since it doesn't actually
     create the object. This can be useful when all we need is the object's
     identifier. For example:</p>

  <pre class="c++">
  std::set&lt;unsigned long> set = ...; // Persons of interest.

  result r (db.query&lt;person> (query::first == "John"));

  for (result::iterator i (r.begin ()); i != r.end (); ++i)
  {
    if (set.find (i.id ()) != set.end ()) // No object loaded.
    {
      cout &lt;&lt; i->first () &lt;&lt; endl; // Object loaded.
    }
  }
  </pre>

  <!-- CHAPTER -->

  <hr class="page-break"/>
  <h1><a name="5">5 Containers</a></h1>

  <p>The ODB runtime library provides built-in persistence support for all the
     commonly used standard C++ containers, namely,
     <code>std::vector</code>, <code>std::list</code>, <code>std::set</code>,
     <code>std::multiset</code>, <code>std::map</code>, and
     <code>std::multimap</code>. Plus, ODB profile libraries, that are
     available for commonly used frameworks and libraries (such as Boost and
     Qt), provide persistence support for containers found in these frameworks
     and libraries (<a href="#III">Part III, "Profiles"</a>).  It is also easy
     to persist custom container types as discussed later
     in <a href="#5.4">Section 5.4, "Using Custom Containers"</a>.</p>

  <p>We don't need to do anything special to declare a member of a
     container type in a persistent class. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  std::vector&lt;std::string> nicknames_;
  ...
};
  </pre>

  <p>The complete version of the above code fragment and the other code
     samples presented in this chapter can be found in the <code>container</code>
     example in the <code>odb-examples</code> package.</p>

  <p>A data member in a persistent class that is of a container type
     behaves like a value type. That is, when an object is made persistent,
     the elements of the container are stored in the database. Similarly,
     when a persistent object is loaded from the database, the contents
     of the container are automatically loaded as well. A data member
     of a container type can also use a smart pointer, as discussed
     in <a href="#7.3">Section 7.3, "Pointers and <code>NULL</code>
     Value Semantics"</a>.</p>

  <p>While an ordinary member is mapped to one or more columns in the
     object's table, a member of a container type is mapped to a separate
     table. The exact schema of such a table depends on the kind of
     container. ODB defines the following container kinds: ordered,
     set, multiset, map, and multimap. The container kinds and the
     contents of the tables to which they are mapped are discussed
     in detail in the following sections.</p>

  <p>Containers in ODB can contain simple value types (<a href="#7.1">Section
     7.1, "Simple Value Types"</a>), composite value types
     (<a href="#7.2">Section 7.2, "Composite Value Types"</a>), and pointers
     to objects (<a href="#6">Chapter 6, "Relationships"</a>). Containers of
     containers, either directly or indirectly via a composite value
     type, are not allowed. A key in a map or multimap container can
     be a simple or composite value type but not a pointer to an object.
     An index in the ordered container should be a simple integer value
     type.</p>

  <p>The value type in the ordered, set, and map containers as well as
     the key type in the map containers should be default-constructible.
     The default constructor in these types can be made private in which
     case the <code>odb::access</code> class should be made a friend of
     the value or key type. For example:</p>

  <pre class="c++">
#pragma db value
class name
{
public:
  name (const std::string&amp;, const std::string&amp;);
  ...
private:
  friend class odb::access;
  name ();
  ...
};

#pragma db object
class person
{
  ...
private:
  std::vector&lt;name> aliases_;
  ...
};
  </pre>


  <h2><a name="5.1">5.1 Ordered Containers</a></h2>

  <p>In ODB an ordered container is any container that maintains (explicitly
     or implicitly) an order of its elements in the form of an integer index.
     Standard C++ containers that are ordered include <code>std::vector</code>
     and <code>std::list</code>. While elements in <code>std::set</code>
     are also kept in a specific order, this order is not based on an
     integer index but rather on the relationship between elements. As
     a result, <code>std::set</code> is not considered an ordered
     container for the purpose of persistence.</p>

  <p>The database table for an ordered container consists of at least
     three columns. The first column contains the object id of a
     persistent class instance of which the container is a member.
     The second column contains the element index within a container.
     And the last column contains the element value. If the object
     id or element value are composite, then, instead of a single
     column, they can occupy multiple columns.</p>

  <p>Consider the following persistent object as an example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db id auto
  unsigned long id_;

  std::vector&lt;std::string> nicknames_;
  ...
};
  </pre>

  <p>The resulting database table (called <code>person_nicknames</code>) will
     contain the object id column of type <code>unsigned long</code>
     (called <code>object_id</code>), the index column of an integer type
     (called <code>index</code>), and the value column of type
     <code>std::string</code> (called <code>value</code>).</p>

  <p>A number of ODB pragmas allow us to customize the table name, column
     names, and native database types of an ordered container both, on
     the per-container and per-member basis. For more information on
     these pragmas, refer to <a href="#11">Chapter 11, "ODB Pragma
     Language"</a>. The following example shows some of the possible
     customizations:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db table("nicknames")              \
             id_column("person_id")          \
             index_type("SMALLINT UNSIGNED") \
             index_column("nickname_number") \
             value_type("VARCHAR(255)")      \
             value_column("nickname")
  std::vector&lt;std::string> nicknames_;
  ...
};
  </pre>

  <p>While the C++ container used in a persistent class may be ordered,
     sometimes we may wish to store such a container in the database without
     the order information. In the example above, for instance, the order
     of person's nicknames is probably not important. To instruct the ODB
     compiler to ignore the order in ordered containers we can use the
     <code>db&nbsp;unordered</code> pragma (<a href="#11.3.7">Section 11.3.7,
     "<code>unordered</code>"</a>, <a href="#11.4.12">Section 11.4.12,
     "<code>unordered</code>"</a>). For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db unordered
  std::vector&lt;std::string> nicknames_;
  ...
};
  </pre>

  <p>The table for an ordered container that is marked unordered won't
     have the index column and the order in which elements are retrieved
     from the database may not be the same as the order in which they
     were stored.</p>

  <h2><a name="5.2">5.2 Set and Multiset Containers</a></h2>

  <p>In ODB set and multiset containers (referred to as just set
     containers) are associative containers that contain elements
     based on some relationship between them. A set container may
     or may not guarantee a particular order of the elements that
     it stores. Standard C++ containers that are considered set
     containers for the purpose of persistence include
     <code>std::set</code> and <code>std::multiset</code>.</p>

  <p>The database table for a set container consists of at least
     two columns. The first column contains the object id of a
     persistent class instance of which the container is a member.
     And the second column contains the element value. If the object
     id or element value are composite, then, instead of a single
     column, they can occupy multiple columns.</p>

  <p>Consider the following persistent object as an example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db id auto
  unsigned long id_;

  std::set&lt;std::string> emails_;
  ...
};
  </pre>

  <p>The resulting database table (called <code>person_emails</code>) will
     contain the object id column of type <code>unsigned long</code>
     (called <code>object_id</code>) and the value column of type
     <code>std::string</code> (called <code>value</code>).</p>

  <p>A number of ODB pragmas allow us to customize the table name,
     column names, and native database types of a set container, both on
     the per-container and per-member basis. For more information on
     these pragmas, refer to <a href="#11">Chapter 11, "ODB Pragma
     Language"</a>. The following example shows some of the possible
     customizations:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db table("emails")            \
             id_column("person_id")     \
             value_type("VARCHAR(255)") \
             value_column("email")
  std::set&lt;std::string> emails_;
  ...
};
  </pre>

  <h2><a name="5.3">5.3 Map and Multimap Containers</a></h2>

  <p>In ODB map and multimap containers (referred to as just map
     containers) are associative containers that contain key-value
     elements based on some relationship between keys. A map container
     may or may not guarantee a particular order of the elements that
     it stores. Standard C++ containers that are considered map
     containers for the purpose of persistence include
     <code>std::map</code> and <code>std::multimap</code>.</p>

  <p>The database table for a map container consists of at least
     three columns. The first column contains the object id of a
     persistent class instance of which the container is a member.
     The second column contains the element key. And the last column
     contains the element value. If the object id, element key, or
     element value are composite, then instead of a single column
     they can occupy multiple columns.</p>

  <p>Consider the following persistent object as an example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db id auto
  unsigned long id_;

  std::map&lt;unsigned short, float> age_weight_map_;
  ...
};
  </pre>

  <p>The resulting database table (called <code>person_age_weight_map</code>)
     will contain the object id column of type <code>unsigned long</code>
     (called <code>object_id</code>), the key column of type
     <code>unsigned short</code> (called <code>key</code>), and the value
     column of type <code>float</code> (called <code>value</code>).</p>

  <p>A number of ODB pragmas allow us to customize the table name,
     column names, and native database types of a map container, both on
     the per-container and per-member basis. For more information on
     these pragmas, refer to <a href="#11">Chapter 11, "ODB Pragma
     Language"</a>. The following example shows some of the possible
     customizations:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db table("weight_map")      \
             id_column("person_id")   \
             key_type("INT UNSIGNED") \
             key_column("age")        \
             value_type("DOUBLE")     \
             value_column("weight")
  std::map&lt;unsigned short, float> age_weight_map_;
  ...
};
  </pre>

  <h2><a name="5.4">5.4 Using Custom Containers</a></h2>

  <p>While the ODB runtime and profile libraries provide support for
     a wide range of containers, it is also easy to persist custom
     container types.</p>

  <p>To achieve this you will need to implement the
     <code>container_traits</code> class template specialization for
     your container. First, determine the container kind (ordered, set,
     multiset, map, or multimap) for your container type. Then use a
     specialization for one of the standard C++ containers found in
     the common ODB runtime library (<code>libodb</code>) as a base
     for your own implementation.</p>

  <p>Once the container traits specialization is ready for your container,
     you will need to include it into the ODB compilation process using
     the <code>--odb-epilogue</code> option and into the generated header
     files with the <code>--hxx-prologue</code> option. As an example,
     suppose we have a hash table container for which we have the traits
     specialization implemented in the <code>hashtable-traits.hxx</code>
     file. Then, we can create an ODB compiler options file for this
     container and save it to <code>hashtable.options</code>:</p>

  <pre>
# Options file for the hash table container.
#
--odb-epilogue '#include "hashtable-traits.hxx"'
--hxx-prologue '#include "hashtable-traits.hxx"'
  </pre>

  <p>Now, whenever we compile a header file that uses the hashtable
     container, we can specify the following command line option to
     make sure it is recognized by the ODB compiler as a container
     and the traits file is included in the generated code:</p>

  <pre>
--options-file hashtable.options
  </pre>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="6">6 Relationships</a></h1>

  <p>Relationships between persistent objects are expressed with pointers or
     containers of pointers. The ODB runtime library provides built-in support
     for the TR1 <code>shared_ptr</code>/<code>weak_ptr</code>,
     <code>std::auto_ptr</code>, and raw pointers. Plus, ODB profile
     libraries, that available for commonly used frameworks and libraries
     (such as Boost and Qt), provide support for smart pointers found in these
     frameworks and libraries (<a href="#III">Part III, "Profiles"</a>). It is
     also easy to add support for a custom smart pointer as discussed later
     in <a href="#6.4"> Section 6.4, "Using Custom Smart Pointers"</a>. Any
     supported smart pointer can be used in a data member as long as it can be
     explicitly constructed from the canonical object pointer
     (<a href="#3.2">Section 3.2, "Object and View Pointers"</a>).  For
     example, we can use <code>weak_ptr</code> if the object pointer
     is <code>shared_ptr</code>.</p>

  <p>When an object containing a pointer to another object is loaded,
     the pointed-to object is loaded as well. In some situations this
     eager loading of the relationships is undesirable since it
     can lead to a large number of otherwise unused objects being
     instantiated from the database. To support finer control
     over relationships loading, the ODB runtime and profile
     libraries provide the so-called <em>lazy</em> versions of
     the supported pointers. An object pointed-to by a lazy pointer
     is not loaded automatically when the containing object is loaded.
     Instead, we have to explicitly request the instantiation of the
     pointed-to object. Lazy pointers are discussed in
     detail in <a href="#6.3">Section 6.3, "Lazy Pointers"</a>.</p>

  <p>As a simple example, consider the following employee-employer
     relationship. Code examples presented in this chapter
     will use the <code>shared_ptr</code> and <code>weak_ptr</code>
     smart pointers from the TR1 (<code>std::tr1</code>) namespace.</p>

  <pre class="c++">
#pragma db object
class employer
{
  ...

  #pragma db id
  std::string name_;
};

#pragma db object
class employee
{
  ...

  #pragma db id
  unsigned long id_;

  std::string first_name_;
  std::string last_name_;

  shared_ptr&lt;employer> employer_;
};
  </pre>

  <p>By default, an object pointer can be <code>NULL</code>. To
     specify that a pointer always points to a valid object we can
     use the <code>not_null</code> pragma (<a href="#11.4.4">Section
     11.4.4, "<code>null</code>/<code>not_null</code>"</a>) for
     single object pointers and the <code>value_not_null</code> pragma
     (<a href="#11.4.17">Section
     11.4.17, "<code>value_null</code>/<code>value_not_null</code>"</a>)
     for containers of object pointers. For example:</p>

  <pre class="c++">
#pragma db object
class employee
{
  ...

  #pragma db not_null
  shared_ptr&lt;employer> current_employer_;

  #pragma db value_not_null
  std::vector&lt;shared_ptr&lt;employer> > previous_employers_;
};
  </pre>

  <p>In this case, if we perform a database operation on the
     <code>employee</code> object and the <code>current_employer_</code>
     pointer or one of the pointers stored in the
     <code>previous_employers_</code> container is <code>NULL</code>,
     then the <code>odb::null_pointer</code> exception will be thrown.</p>

  <p>We don't need to do anything special to establish or navigate a
     relationship between two persistent objects, as shown in the
     following code fragment:</p>

  <pre class="c++">
// Create an employer and a few employees.
//
unsigned long john_id, jane_id;
{
  shared_ptr&lt;employer> er (new employer ("Example Inc"));
  shared_ptr&lt;employee> john (new employee ("John", "Doe"));
  shared_ptr&lt;employee> jane (new employee ("Jane", "Doe"));

  john->employer_ = er;
  jane->employer_ = er;

  transaction t (db.begin ());

  db.persist (er);
  john_id = db.persist (john);
  jane_id = db.persist (jane);

  t.commit ();
}

// Load a few employee objects and print their employer.
//
{
  session s;
  transaction t (db.begin ());

  shared_ptr&lt;employee> john (db.load&lt;employee> (john_id));
  shared_ptr&lt;employee> jane (db.load&lt;employee> (jane_id));

  cout &lt;&lt; john->employer_->name_ &lt;&lt; endl;
  cout &lt;&lt; jane->employer_->name_ &lt;&lt; endl;

  t.commit ();
}
  </pre>

  <p>The only notable line in the above code is the creation of a
     session before the second transaction starts. As discussed in
     <a href="#10">Chapter 10, "Session"</a>, a session acts as a cache
     of persistent objects.
     By creating a session before loading the <code>employee</code>
     objects we make sure that their <code>employer_</code> pointers
     point to the same <code>employer</code> object. Without a
     session, each <code>employee</code> would have ended up pointing
     to its own, private instance of the Example Inc employer.</p>

  <p>As a general guideline, you should use a session when loading
     objects that have pointers to other persistent objects. A
     session makes sure that for a given object id, a single instance
     is shared among all other objects that relate to it.</p>

  <p>We can also use data members from pointed-to
     objects in database queries (<a href="#4">Chapter 4, "Querying the
     Database"</a>). For each pointer in a persistent class, the query
     class defines a smart pointer-like member that contains members
     corresponding to the data members in the pointed-to object. We
     can then use the access via a pointer syntax (<code>-></code>)
     to refer to data members in pointed-to objects.
     For example, the query class for the <code>employee</code> object
     contains the <code>employer</code> member (its name is derived from the
     <code>employer_</code> pointer) which in turn contains the
     <code>name</code> member (its name is derived from the
     <code>employer::name_</code> data member of the pointed-to object).
     As a result, we can use the <code>query::employer->name</code>
     expression while querying the database for the <code>employee</code>
     objects. For example, the following transaction finds all the
     employees of Example Inc that have the Doe last name:</p>

  <pre class="c++">
typedef odb::query&lt;employee> query;
typedef odb::result&lt;employee> result;

session s;
transaction t (db.begin ());

result r (db->query&lt;employee> (
  query::employer->name == "Example Inc" &amp;&amp; query::last == "Doe"));

for (result::iterator i (r.begin ()); i != r.end (); ++i)
  cout &lt;&lt; i->first_ &lt;&lt; " " &lt;&lt; i->last_ &lt;&lt; endl;

t.commit ();
  </pre>

  <p>A query class member corresponding to a non-inverse
     (<a href="#6.2">Section 6.2, "Bidirectional Relationships"</a>) object
     pointer can also be used as a normal member that has the id type
     of the pointed-to object. For example, the following query locates
     all the <code>employee</code> objects that don't have an associated
     <code>employer</code> object:</p>

  <pre class="c++">
result r (db->query&lt;employee> (query::employer.is_null ()));
  </pre>

  <p>An important concept to keep in mind when working with object
     relationships is the independence of persistent objects. In particular,
     when an object containing a pointer to another object is made persistent
     or is updated, the pointed-to object is not automatically persisted
     or updated. Rather, only a reference to the object (in the form of the
     object id) is stored for the pointed-to object in the database.
     The pointed-to object itself is a separate entity and should
     be made persistent or updated independently.</p>

  <p>When persisting or updating an object containing a pointer to another
     object, the pointed-to object must have a valid object id. This,
     however, may not always be easy to achieve in complex relationships that
     involve objects with automatically assigned identifiers. In such
     cases it may be necessary to first persist an object with a pointer
     set to <code>NULL</code> and then, once the pointed-to object is
     made persistent and its identifier assigned, set the pointer
     to the correct value and update the object in the database.</p>

  <p>Persistent object relationships can be divided into two groups:
     unidirectional and bidirectional. Each group in turn contains
     several configurations that vary depending on the cardinality
     of the sides of the relationship. All possible unidirectional
     and bidirectional configurations are discussed in the following
     sections.</p>

  <h2><a name="6.1">6.1 Unidirectional Relationships</a></h2>

  <p>In unidirectional relationships we are only interested in navigating
     from object to object in one direction. Because there is no interest
     in navigating in the opposite direction, the cardinality of the other
     end of the relationship is unimportant. As a result, there are only
     two possible unidirectional relationships: to-one and to-many. Each
     of these relationships is described in the following sections. For
     sample code that shows how to work with these relationships, refer
     to the <code>relationship</code> example in the <code>odb-examples</code>
     package.</p>

  <h3><a name="6.1.1">6.1.1 To-One Relationships</a></h3>

  <p>An example of a unidirectional to-one relationship is the
     employee-employer relationship (an employee has one employer).
     The following persistent C++ classes model this relationship:</p>

  <pre class="c++">
#pragma db object
class employer
{
  ...

  #pragma db id
  std::string name_;
};

#pragma db object
class employee
{
  ...

  #pragma db id
  unsigned long id_;

  #pragma db not_null
  shared_ptr&lt;employer> employer_;
};
  </pre>

  <p>The corresponding database tables look like this:</p>

  <pre class="sql">
CREATE TABLE employer (
  name VARCHAR (255) NOT NULL PRIMARY KEY);

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  employer VARCHAR (255) NOT NULL REFERENCES employer (name));
  </pre>

  <h3><a name="6.1.2">6.1.2 To-Many Relationships</a></h3>

  <p>An example of a unidirectional to-many relationship is the
     employee-project relationship (an employee can be involved
     in multiple projects). The following persistent C++ classes
     model this relationship:</p>

  <pre class="c++">
#pragma db object
class project
{
  ...

  #pragma db id
  std::string name_;
};

#pragma db object
class employee
{
  ...

  #pragma db id
  unsigned long id_;

  #pragma db value_not_null unordered
  std::vector&lt;shared_ptr&lt;project> > projects_;
};
  </pre>

  <p>The corresponding database tables look like this:</p>

  <pre class="sql">
CREATE TABLE project (
  name VARCHAR (255) NOT NULL PRIMARY KEY);

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY);

CREATE TABLE employee_projects (
  object_id BIGINT UNSIGNED NOT NULL,
  value VARCHAR (255) NOT NULL REFERENCES project (name));
  </pre>

  <p>To obtain a more canonical database schema, the names of tables
     and columns above can be customized using ODB pragmas
     (<a href="#11">Chapter 11, "ODB Pragma Language"</a>). For example:</p>

  <pre class="c++">
#pragma db object
class employee
{
  ...

  #pragma db value_not_null unordered \
             id_column("employee_id") value_column("project_name")
  std::vector&lt;shared_ptr&lt;project> > projects_;
};
  </pre>

  <p>The resulting <code>employee_projects</code> table would then
     look like this:</p>

  <pre class="sql">
CREATE TABLE employee_projects (
  employee_id BIGINT UNSIGNED NOT NULL,
  project_name VARCHAR (255) NOT NULL REFERENCES project (name));
  </pre>


  <h2><a name="6.2">6.2 Bidirectional Relationships</a></h2>

  <p>In bidirectional relationships we are interested in navigating
     from object to object in both directions. As a result, each
     object class in a relationship contains a pointer to the other
     object. If smart pointers are used, then a weak pointer should
     be used as one of the pointers to avoid ownership cycles. For
     example:</p>

  <pre class="c++">
class employee;

#pragma db object
class position
{
  ...

  #pragma db id
  unsigned long id_;

  weak_ptr&lt;employee> employee_;
};

#pragma db object
class employee
{
  ...

  #pragma db id
  unsigned long id_;

  #pragma db not_null
  shared_ptr&lt;position> position_;
};
  </pre>

  <p>Note that when we establish a bidirectional relationship, we
     have to set both pointers consistently. One way to make sure
     that a relationship is always in a consistent state is to
     provide a single function that updates both pointers at the
     same time. For example:</p>

  <pre class="c++">
#pragma db object
class position: public enable_shared_from_this&lt;position>
{
  ...

  void
  fill (shared_ptr&lt;employee> e)
  {
    employee_ = e;
    e->positions_ = shared_from_this ();
  }

private:
  weak_ptr&lt;employee> employee_;
};

#pragma db object
class employee
{
  ...

private:
  friend class position;

  #pragma db not_null
  shared_ptr&lt;position> position_;
};
  </pre>


  <p>Above, to model a bidirectional relationship in persistent classes,
     we used two pointers, one in each object. While this is a natural
     representation in C++, it does not translate to a canonical
     relational model. Consider the database schema generated for
     the above two classes:</p>

  <pre class="sql">
CREATE TABLE position (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  employee BIGINT UNSIGNED REFERENCES employee (id));

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  position BIGINT UNSIGNED NOT NULL REFERENCES position (id));
  </pre>

  <p>While this database schema is valid, it is unconventional. We have
     a reference from a row in the <code>position</code> table to a row
     in the <code>employee</code> table. We also have a reference
     from this same row in the <code>employee</code> table back to
     the row in the <code>position</code> table. From the relational
     point of view, one of these references is redundant since
     in SQL we can easily navigate in both directions using just one
     of these references.</p>

  <p>To eliminate redundant database schema references we can use the
     <code>inverse</code> pragma (<a href="#11.4.11">Section 11.4.11,
     "<code>inverse</code>"</a>) which tells the ODB compiler that
     a pointer is the inverse side of a bidirectional relationship.
     Either side of a relationship can be made inverse. For example:</p>

  <pre class="c++">
#pragma db object
class position
{
  ...

  #pragma db inverse(position_)
  weak_ptr&lt;employee> employee_;
};

#pragma db object
class employee
{
  ...

  #pragma db not_null
  shared_ptr&lt;position> position_;
};
  </pre>

  <p>The resulting database schema looks like this:</p>

  <pre class="sql">
CREATE TABLE position (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY);

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  position BIGINT UNSIGNED NOT NULL REFERENCES position (id));
  </pre>

  <p>As you can see, an inverse member does not have a corresponding
     column (or table, in case of an inverse container of pointers)
     and, from the point of view of database operations, is effectively
     read-only. The only way to change a bidirectional relationship
     with an inverse side is to set its direct (non-inverse)
     pointer. Also note that an ordered container (<a href="#5.1">Section
     5.1, "Ordered Containers"</a>) of pointers that is an inverse side
     of a bidirectional relationship is always treated as unordered
     (<a href="#11.4.12">Section 11.4.12, "<code>unordered</code>"</a>)
     because the contents of such a container are implicitly built from
     the direct side of the relationship which does not contain the
     element order (index).</p>

  <p>There are three distinct bidirectional relationships that we
     will cover in the following sections: one-to-one, one-to-many,
     and many-to-many. We will only talk about bidirectional
     relationships with inverse sides since they result in canonical
     database schemas. For sample code that shows how to work with
     these relationships, refer to the <code>inverse</code> example
     in the <code>odb-examples</code> package.</p>

  <h3><a name="6.2.1">6.2.1 One-to-One Relationships</a></h3>

  <p>An example of a bidirectional one-to-one relationship is the
     presented above employee-position relationship (an employee
     fills one position and a position is filled by one employee).
     The following persistent C++ classes model this relationship:</p>

  <pre class="c++">
class employee;

#pragma db object
class position
{
  ...

  #pragma db id
  unsigned long id_;

  #pragma db inverse(position_)
  weak_ptr&lt;employee> employee_;
};

#pragma db object
class employee
{
  ...

  #pragma db id
  unsigned long id_;

  #pragma db not_null
  shared_ptr&lt;position> position_;
};
  </pre>

  <p>The corresponding database tables look like this:</p>

  <pre class="sql">
CREATE TABLE position (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY);

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  position BIGINT UNSIGNED NOT NULL REFERENCES position (id));
  </pre>

  <p>If instead the other side of this relationship is made inverse,
     then the database tables will change as follows:</p>

  <pre class="sql">
CREATE TABLE position (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  employee BIGINT UNSIGNED REFERENCES employee (id));

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY);
  </pre>

  <h3><a name="6.2.2">6.2.2 One-to-Many Relationships</a></h3>

  <p>An example of a bidirectional one-to-many relationship is the
     employer-employee relationship (an employer has multiple
     employees and an employee is employed by one employer).
     The following persistent C++ classes model this relationship:</p>

  <pre class="c++">
class employee;

#pragma db object
class employer
{
  ...

  #pragma db id
  std::string name_;

  #pragma db value_not_null inverse(employer_)
  std::vector&lt;weak_ptr&lt;employee> > employees_
};

#pragma db object
class employee
{
  ...

  #pragma db id
  unsigned long id_;

  #pragma db not_null
  shared_ptr&lt;employer> employer_;
};
  </pre>

  <p>The corresponding database tables differ significantly depending
     on which side of the relationship is made inverse. If the <em>one</em>
     side (<code>employer</code>) is inverse as in the code
     above, then the resulting database schema looks like this:</p>

  <pre class="sql">
CREATE TABLE employer (
  name VARCHAR (255) NOT NULL PRIMARY KEY);

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  employer VARCHAR (255) NOT NULL REFERENCES employer (name));
  </pre>

  <p>If instead the <em>many</em> side (<code>employee</code>) of this
     relationship is made inverse, then the database tables will change
     as follows:</p>

  <pre class="sql">
CREATE TABLE employer (
  name VARCHAR (255) NOT NULL PRIMARY KEY);

CREATE TABLE employer_employees (
  object_id VARCHAR (255) NOT NULL,
  value BIGINT UNSIGNED NOT NULL REFERENCES employee (id));

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY);
  </pre>

  <h3><a name="6.2.3">6.2.3 Many-to-Many Relationships</a></h3>

  <p>An example of a bidirectional many-to-many relationship is the
     employee-project relationship (an employee can work on multiple
     projects and a project can have multiple participating employees).
     The following persistent C++ classes model this relationship:</p>

  <pre class="c++">
class employee;

#pragma db object
class project
{
  ...

  #pragma db id
  std::string name_;

  #pragma db value_not_null inverse(projects_)
  std::vector&lt;weak_ptr&lt;employee> > employees_;
};

#pragma db object
class employee
{
  ...

  #pragma db id
  unsigned long id_;

  #pragma db value_not_null unordered
  std::vector&lt;shared_ptr&lt;project> > projects_;
};
  </pre>

  <p>The corresponding database tables look like this:</p>

  <pre class="sql">
CREATE TABLE project (
  name VARCHAR (255) NOT NULL PRIMARY KEY);

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY);

CREATE TABLE employee_projects (
  object_id BIGINT UNSIGNED NOT NULL,
  value VARCHAR (255) NOT NULL REFERENCES project (name));
  </pre>

  <p>If instead the other side of this relationship is made inverse,
     then the database tables will change as follows:</p>

  <pre class="sql">
CREATE TABLE project (
  name VARCHAR (255) NOT NULL PRIMARY KEY);

CREATE TABLE project_employees (
  object_id VARCHAR (255) NOT NULL,
  value BIGINT UNSIGNED NOT NULL REFERENCES employee (id));

CREATE TABLE employee (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY);
  </pre>

  <h2><a name="6.3">6.3 Lazy Pointers</a></h2>

  <p>Consider again the bidirectional, one-to-many employer-employee
     relationship that was presented earlier in this chapter:</p>

  <pre class="c++">
class employee;

#pragma db object
class employer
{
  ...

  #pragma db id
  std::string name_;

  #pragma db value_not_null inverse(employer_)
  std::vector&lt;weak_ptr&lt;employee> > employees_;
};

#pragma db object
class employee
{
  ...

  #pragma db id
  unsigned long id_;

  #pragma db not_null
  shared_ptr&lt;employer> employer_;
};
  </pre>

  <p>Consider also the following transaction which obtains the employer
     name given the employee id:</p>

  <pre class="c++">
unsigned long id = ...
string name;

session s;
transaction t (db.begin ());

shared_ptr&lt;employee> e (db.load&lt;employee> (id));
name = e->employer_->name_;

t.commit ();
  </pre>

  <p>While this transaction looks very simple, it actually does a lot more
     than what meets the eye and is necessary. Consider what happens when
     we load the <code>employee</code> object: the <code>employer_</code>
     pointer is also automatically loaded which means the <code>employer</code>
     object corresponding to this employee is also loaded. But the
     <code>employer</code> object in turn contains the list of pointers
     to all the employees, which are also loaded. A a result, when object
     relationships are involved, a simple transaction like the above can
     load many more objects than is necessary.</p>

  <p>To overcome this problem ODB offers finer grained control over
     the relationship loading in the form of lazy pointers. A lazy
     pointer does not automatically load the pointed-to object
     when the containing object is loaded. Instead, we have to
     explicitly load the pointed-to object if and when we need to
     access it.</p>

  <p>The ODB runtime library provides lazy counterparts for all the
     supported pointers, namely: <code>odb::lazy_shared_ptr</code> and
     <code>odb::lazy_weak_ptr</code> for TR1 <code>shared_ptr</code> and
     <code>weak_ptr</code>, <code>odb::lazy_auto_ptr</code> for
     <code>std::auto_ptr</code>, and <code>odb::lazy_ptr</code> for raw
     pointers. The ODB profile libraries provide lazy pointer
     implementations for smart pointers from popular frameworks and
     libraries (<a href="#III">Part III, "Profiles"</a>).</p>

  <p>While we will discuss the interface of lazy pointers in more detail
     shortly, the most commonly used extra function provided by these
     pointers is <code>load()</code>. This function loads the
     pointed-to object if it hasn't already been loaded. After
     the call to this function, the lazy pointer can be used
     in the the same way as its eager counterpart. The <code>load()</code>
     function also returns the eager pointer, in case you need to pass
     it around. For a lazy weak pointer, the
     <code>load()</code> function also locks the pointer.</p>

  <p>The following example shows how we can change our employer-employee
     relationship to use lazy pointers. Here we choose to use lazy pointers
     for both sides of the relationship.</p>

  <pre class="c++">
class employee;

#pragma db object
class employer
{
  ...

  #pragma db value_not_null inverse(employer_)
  std::vector&lt;lazy_weak_ptr&lt;employee> > employees_;
};

#pragma db object
class employee
{
  ...

  #pragma db not_null
  lazy_shared_ptr&lt;employer> employer_;
};
  </pre>

  <p>And the transaction is changed like this:</p>

  <pre class="c++">
unsigned long id = ...
string name;

session s;
transaction t (db.begin ());

shared_ptr&lt;employee> e (db.load&lt;employee> (id));
e->employer_.load ();
name = e->employer_->name_;

t.commit ();
  </pre>


  <p>As a general guideline we recommend that you make at least one side
     of a bidirectional relationship lazy, especially for relationships
     with a <em>many</em> side.</p>

  <p>A lazy pointer implementation mimics the interface of its eager
     counterpart which can be used once the pointer is loaded. It also
     adds a number of additional functions that are specific to the
     lazy loading functionality. Overall, the interface of a lazy
     pointer follows this general outline:</p>

  <pre class="c++">
template &lt;class T>
class lazy_ptr
{
public:
  //
  // The eager pointer interface.
  //

  // Initialization/assignment from an eager pointer.
  //
public:
  template &lt;class Y> lazy_ptr (const eager_ptr&lt;Y>&amp;);
  template &lt;class Y> lazy_ptr&amp; operator= (const eager_ptr&lt;Y>&amp;);

  // Lazy loading interface.
  //
public:
  //  NULL      loaded()
  //
  //  true       true      NULL pointer to transient object
  //  false      true      valid pointer to persistent object
  //  true       false     unloaded pointer to persistent object
  //  false      false     valid pointer to transient object
  //
  bool loaded () const;

  eager_ptr&lt;T> load () const;

  // Unload the pointer. For transient objects this function is
  // equivalent to reset().
  //
  void unload () const;

  // Initialization with a persistent loaded object.
  //
  template &lt;class Y> lazy_ptr (database&amp;, Y*);
  template &lt;class Y> lazy_ptr (database&amp;, const eager_ptr&lt;Y>&amp;);

  template &lt;class Y> void reset (database&amp;, Y*);
  template &lt;class Y> void reset (database&amp;, const eager_ptr&lt;Y>&amp;);

  // Initialization with a persistent unloaded object.
  //
  template &lt;class ID> lazy_ptr (database&amp;, const ID&amp;);

  template &lt;class ID> void reset (database&amp;, const ID&amp;);

  // Query object id and database of a persistent object.
  //
  template &lt;class O /* = T */>
  object_traits&lt;O>::id_type object_id () const;

  odb::database&amp; database () const;
};
  </pre>

  <p>In a lazy weak pointer interface, the <code>load()</code> function
     returns the <em>strong</em> (shared) eager pointer. The following
     transaction demonstrates the use of a lazy weak pointer based on
     the <code>employer</code> and <code>employee</code> classes
     presented earlier.</p>

  <pre class="c++">
typedef std::vector&lt;lazy_weak_ptr&lt;employee> > employees;

session s;
transaction t (db.begin ());

shared_ptr&lt;employer> er (db.load&lt;employer> ("Example Inc"));
employees&amp; es (er->employees ());

for (employees::iterator i (es.begin ()); i != es.end (); ++i)
{
  // We are only interested in employees with object id less than
  // 100.
  //
  lazy_weak_ptr&lt;employee>&amp; lwp (*i);

  if (lwp.object_id&lt;employee> () &lt; 100)
  {
    shared_ptr&lt;employee> e (lwp.load ()); // Load and lock.
    cout &lt;&lt; e->first_ &lt;&lt; " " &lt;&lt; e->last_ &lt;&lt; endl;
  }
}

t.commit ();
  </pre>

  <p>Notice that inside the for-loop we use a reference to the lazy
     weak pointer instead of making a copy. This is not merely to
     avoid a copy. When a lazy pointer is loaded, all other lazy
     pointers that point to the same object do not automatically
     become loaded (though an attempt to load such copies will
     result in them pointing to the same object, provided the
     same session is still in effect). By using a reference
     in the above transaction we make sure that we load the
     pointer that is contained in the <code>employer</code>
     object. This way, if we later need to re-examine this
     <code>employee</code> object, the pointer will already
     be loaded.</p>

  <p>As another example, suppose we want to add an employee
     to Example Inc. The straightforward implementation of this
     transaction is presented below:</p>

  <pre class="c++">
session s;
transaction t (db.begin ());

shared_ptr&lt;employer> er (db.load&lt;employer> ("Example Inc"));
shared_ptr&lt;employee> e (new employee ("John", "Doe"));

e->employer_ = er;
er->employees ().push_back (e);

db.persist (e);
t.commit ();
  </pre>

  <p>Notice here that we didn't have to update the employer object
     in the database since the <code>employees_</code> list of
     pointers is an inverse side of a bidirectional relationship
     and is effectively read-only, from the persistence point of
     view.</p>

  <p>A faster implementation of this transaction, that avoids loading
     the employer object, relies on the ability to initialize an
     <em>unloaded</em> lazy pointer with the database where the object
     is stored as well as its identifier:</p>

  <pre class="c++">
lazy_shared_ptr&lt;employer> er (db, std::string ("Example Inc"));
shared_ptr&lt;employee> e (new employee ("John", "Doe"));

e->employer_ = er;

session s;
transaction t (db.begin ());

db.persist (e);

t.commit ();
  </pre>

  <h2><a name="6.4">6.4 Using Custom Smart Pointers</a></h2>

  <p>While the ODB runtime and profile libraries provide support for
     the majority of widely-used pointers, it is also easy to add
     support for a custom smart pointer.</p>

  <p>To achieve this you will need to implement the
     <code>pointer_traits</code> class template specialization for
     your pointer. The first step is to determine the pointer kind
     since the interface of the <code>pointer_traits</code> specialization
     varies depending on the pointer kind. The supported pointer kinds
     are: <em>raw</em> (raw pointer or equivalent, that is, unmanaged),
          <em>unique</em> (smart pointer that doesn't support sharing),
          <em>shared</em> (smart pointer that supports sharing), and
          <em>weak</em> (weak counterpart of the shared pointer). Any of
     these pointers can be lazy, which also affects the
     interface of the <code>pointer_traits</code> specialization.</p>

  <p>Once you have determined the pointer kind for your smart pointer,
     use a specialization for one of the standard pointers found in
     the common ODB runtime library (<code>libodb</code>) as a base
     for your own implementation.</p>

  <p>Once the pointer traits specialization is ready, you will need to
     include it into the ODB compilation process using the
     <code>--odb-epilogue</code> option and into the generated header
     files with the <code>--hxx-prologue</code> option. As an example,
     suppose we have the <code>smart_ptr</code> smart pointer for which
     we have the traits specialization implemented in the
     <code>smart-ptr-traits.hxx</code> file. Then, we can create an ODB
     compiler options file for this pointer and save it to
     <code>smart-ptr.options</code>:</p>

  <pre>
# Options file for smart_ptr.
#
--odb-epilogue '#include "smart-ptr-traits.hxx"'
--hxx-prologue '#include "smart-ptr-traits.hxx"'
  </pre>

  <p>Now, whenever we compile a header file that uses <code>smart_ptr</code>,
     we can specify the following command line option to make sure it is
     recognized by the ODB compiler as a smart pointer and the traits file
     is included in the generated code:</p>

  <pre>
--options-file smart-ptr.options
  </pre>

  <p>It is also possible to implement a lazy counterpart for your
     smart pointer. The ODB runtime library provides a class template
     that encapsulates the object id management and loading
     functionality that is needed to implement a lazy pointer. All
     you need to do is wrap it with an interface that mimics
     your smart pointer. Using one of the existing lazy pointer
     implementations (either from the ODB runtime library or one
     of the profile libraries) as a base for your implementation
     is the easiest way to get started.</p>


  <!-- CHAPTER -->

  <hr class="page-break"/>
  <h1><a name="7">7 Value Types</a></h1>

  <p>In <a href="#3.1">Section 3.1, "Concepts and Terminology"</a> we have
     already discussed the notion of values and value types as well as the
     distinction between simple and composite values. This chapter covers
     simple and composite value types in more detail.</p>

  <h2><a name="7.1">7.1 Simple Value Types</a></h2>

  <p>A simple value type is a fundamental C++ type or a class type that
     is mapped to a single database column. For each supported database
     system the ODB compiler provides a default mapping to suitable
     database types for most fundamental C++ types, such as <code>int</code>
     or <code>float</code> as well as some class types, such as
     <code>std::string</code>. For more information about the default
     mapping for each database system refer to <a href="#II">Part II,
     Database Systems</a>. We can also provide a custom mapping for
     these or our own value types using the <code>db&nbsp;type</code>
     pragma (<a href="#11.3.1">Section 11.3.1, "<code>type</code>"</a>).</p>

  <h2><a name="7.2">7.2 Composite Value Types</a></h2>

  <p>A composite value type is a <code>class</code> or <code>struct</code>
     type that is mapped to more than one database column. To declare
     a composite value type we use the <code>db&nbsp;value</code> pragma,
     for example:</p>

  <pre class="c++">
#pragma db value
class basic_name
{
  ...

  std::string first_;
  std::string last_;
};
  </pre>

  <p>The complete version of the above code fragment and the other code
     samples presented in this chapter can be found in the <code>composite</code>
     example in the <code>odb-examples</code> package.</p>

  <p>A composite value type does not have to define a default constructor,
     unless it is used as an element of a container, in which case the
     default constructor can be made private. If a composite value type
     has private or protected non-transient data members or if its
     default constructor is not public and the value type is used as
     an element of a container, then the <code>odb::access</code> class
     should be declared a friend of this value type. For example:</p>

  <pre class="c++">
#pragma db value
class basic_name
{
public:
  basic_name (const std::string&amp; first, const std::string&amp; last);

  ...

private:
  friend class odb::access;

  basic_name () {} // Needed for storing basic_name in containers.

  std::string first_;
  std::string last_;
};
  </pre>

  <p>The members of a composite value can be other value types (either
     simple or composite), containers (<a href="#5">Chapter 5,
     "Containers"</a>), and pointers to objects (<a href="#6">Chapter 6,
     "Relationships"</a>).
     Similarly, a composite value type can be used in object members,
     as an element of a container, and as a base for another composite
     value type. In particular, composite value types can be used as
     element types in set containers (<a href="#5.2">Section 5.2, "Set
     and Multiset Containers"</a>) and as key types in map containers
     (<a href="#5.3">Section 5.3, "Map and Multimap Containers"</a>).
     A composite value type that is used as an element of a container
     cannot contain other containers since containers of containers
     are not allowed. The following example illustrates some of the
     possible use cases:</p>

<pre class="c++">
#pragma db value
class basic_name
{
  ...

  std::string first_;
  std::string last_;
};

typedef std::vector&lt;basic_name> basic_names;

#pragma db value
class name_extras
{
  ...

  std::string nickname_;
  basic_names aliases_;
};

#pragma db value
class name: public basic_name
{
  ...

  std::string title_;
  name_extras extras_;
};

#pragma db object
class person
{
  ...

  name name_;
};
</pre>

  <p>We can also use data members from composite value types
     in database queries (<a href="#4">Chapter 4, "Querying the
     Database"</a>). For each composite value in a persistent class, the
     query class defines a nested member that contains members corresponding
     to the data members in the value type. We can then use the member access
     syntax (.) to refer to data members in value types. For example, the
     query class for the <code>person</code> object presented above
     contains the <code>name</code> member (its name is derived from
     the <code>name_</code> data member) which in turn contains the
     <code>extras</code> member (its name is derived from the
     <code>name::extras_</code> data member of the composite value type).
     This process continues recursively for nested composite value types
     and, as a result, we can use the <code>query::name.extras.nickname</code>
     expression while querying the database for the <code>person</code>
     objects. For example:</p>

  <pre class="c++">
typedef odb::query&lt;person> query;
typedef odb::result&lt;person> result;

transaction t (db->begin ());

result r (db->query&lt;person> (
  query::name.extras.nickname == "Squeaky"));

...

t.commit ();
  </pre>

  <h3><a name="7.2.1">7.2.1 Composite Value Column and Table Names</a></h3>

  <p>Customizing a column name for a data member of a simple value
     type is straightforward: we simply specify the desired name with
     the <code>db&nbsp;column</code> pragma (<a href="#11.4.7">Section
     11.4.7, "<code>column</code>"</a>). For composite value
     types things are slightly more complex since they are mapped to
     multiple columns. Consider the following example:</p>

<pre class="c++">
#pragma db value
class name
{
  ...

  std::string first_;
  std::string last_;
};

#pragma db object
class person
{
  ...

  #pragma db id auto
  unsigned long id_;

  name name_;
};
</pre>

  <p>The column names for the <code>first_</code> and <code>last_</code>
     members are constructed by using the sanitized name of the
     <code>person::name_</code> member as a prefix and the names of the
     members in the value type (<code>first_</code> and <code>last_</code>)
     as suffixes. As a result, the database schema for the above classes
     will look like this:</p>

  <pre class="sql">
CREATE TABLE person (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  name_first TEXT NOT NULL,
  name_last TEXT NOT NULL);
  </pre>

 <p>We can customize both the prefix and the suffix using the
    <code>db&nbsp;column</code> pragma as shown in the following
    example:</p>

  <pre class="c++">
#pragma db value
class name
{
  ...

  #pragma db column("first_name")
  std::string first_;

  #pragma db column("last_name")
  std::string last_;
};

#pragma db object
class person
{
  ...

  #pragma db column("person_")
  name name_;
};
  </pre>

  <p>The database schema changes as follows:</p>

  <pre class="sql">
CREATE TABLE person (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  person_first_name TEXT NOT NULL,
  person_last_name TEXT NOT NULL);
  </pre>

  <p>We can also make the column prefix empty, for example:</p>

<pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db column("")
  name name_;
};
  </pre>

  <p>This will result in the following schema:</p>

  <pre class="sql">
CREATE TABLE person (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL);
  </pre>

  <p>The same principle applies when a composite value type is used
     as an element of a container, except that instead of
     <code>db&nbsp;column</code>, either the <code>db&nbsp;value_column</code>
     (<a href="#11.4.25">Section 11.4.25, "<code>value_column</code>"</a>) or
     <code>db&nbsp;key_column</code>
     (<a href="#11.4.24">Section 11.4.24, "<code>key_column</code>"</a>)
     pragmas are used to specify the column prefix.</p>

  <p>When a composite value type contains a container, an extra table
     is used to store its elements (<a href="#5">Chapter 5, "Containers"</a>).
     The names of such tables are constructed in a way similar to the
     column names, except that by default both the object name and the
     member name are used as a prefix. For example:</p>

  <pre class="c++">
#pragma db value
class name
{
  ...

  std::string first_;
  std::string last_;
  std::vector&lt;std::string> nicknames_;
};

#pragma db object
class person
{
  ...

  name name_;
};
  </pre>

  <p>The corresponding database schema will look like this:</p>

  <pre class="sql">
CREATE TABLE person_name_nicknames (
  object_id BIGINT UNSIGNED NOT NULL,
  index BIGINT UNSIGNED NOT NULL,
  value TEXT NOT NULL)

CREATE TABLE person (
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY,
  name_first TEXT NOT NULL,
  name_last TEXT NOT NULL);
  </pre>

  <p>To customize the container table name we can use the
     <code>db&nbsp;table</code> pragma (<a href="#11.4.13">Section
     11.4.13, "<code>table</code>"</a>), for example:</p>

  <pre class="c++">
#pragma db value
class name
{
  ...

  #pragma db table("nickname")
  std::vector&lt;std::string> nicknames_;
};

#pragma db object
class person
{
  ...

  #pragma db table("person_")
  name name_;
};
  </pre>

  <p>This will result in the following schema changes:</p>

  <pre class="sql">
CREATE TABLE person_nickname (
  object_id BIGINT UNSIGNED NOT NULL,
  index BIGINT UNSIGNED NOT NULL,
  value TEXT NOT NULL)
  </pre>

  <p>Similar to columns, we can make the table prefix empty.</p>


  <h2><a name="7.3">7.3 Pointers and <code>NULL</code> Value Semantics</a></h2>

  <p>Relational database systems have a notion of the special
     <code>NULL</code> value that is used to indicate the absence
     of a valid value in a column. While by default ODB maps
     values to columns that do not allow <code>NULL</code> values,
     it is possible to change that with the <code>db&nbsp;null</code>
     pragma (<a href="#11.4.4">Section 11.4.4,
     "<code>null</code>/<code>not_null</code>"</a>).</p>

  <p>To properly support the <code>NULL</code> semantics, the
     C++ value type must have a notion or a <code>NULL</code>
     value or a similar special state concept. Most basic
     C++ types, such as <code>int</code> or <code>std::string</code>,
     do not have this notion and therefore cannot be used directly
     for <code>NULL</code>-enabled data members (in the case of a
     <code>NULL</code> value being loaded from the database,
     such data members will be default-initialized).</p>

  <p>To allow the easy conversion of value types that do not support
     the <code>NULL</code> semantics into the ones that do, ODB
     provides the <code>odb::nullable</code> class template. It
     allows us to wrap an existing C++ type into a container-like
     class that can either be <code>NULL</code> or contain a
     value of the wrapped type. ODB also automatically enables
     the <code>NULL</code> values for data members of the
     <code>odb::nullable</code> type. For example:</p>

  <pre class="c++">
#include &lt;odb/nullable.hxx>

#pragma db object
class person
{
  ...

  std::string first_;                    // TEXT NOT NULL
  odb::nullable&lt;std::string> middle_;    // TEXT NULL
  std::string last_;                     // TEXT NOT NULL
};
  </pre>

  <p>The <code>odb::nullable</code> class template is defined
     in the <code>&lt;odb/nullable.hxx></code> header file and
     has the following interface:</p>

  <pre class="c++">
namespace odb
{
  template &lt;typename T>
  class nullable
  {
  public:
    typedef T value_type;

    nullable ();
    nullable (const T&amp;);
    nullable (const nullable&amp;);
    template &lt;typename Y> explicit nullable (const nullable&lt;Y>&amp;);

    nullable&amp; operator= (const T&amp;);
    nullable&amp; operator= (const nullable&amp;);
    template &lt;typename Y> nullable&amp; operator= (const nullable&lt;Y>&amp;);

    void swap (nullable&amp;);

    // Accessor interface.
    //
    bool null () const;

    T&amp;       get ();
    const T&amp; get () const;

    // Pointer interface.
    //
    operator bool_convertible () const;

    T*       operator-> ();
    const T* operator-> () const;

    T&amp;       operator* ();
    const T&amp; operator* () const;

    // Reset to the NULL state.
    //
    void reset ();
  };
}
  </pre>

  <p>The following example shows how we can use this interface:</p>

  <pre class="c++">
  nullable&lt;string> ns;

  // Using the accessor interface.
  //
  if (ns.null ())
  {
    s = "abc";
  }
  else
  {
    string s (ns.get ());
    ns.reset ();
  }

  // The same using the pointer interface.
  //
  if (ns)
  {
    s = "abc";
  }
  else
  {
    string s (*ns);
    ns.reset ();
  }
  </pre>


  <p>The <code>odb::nullable</code> class template requires the wrapped
     type to have public default and copy constructors as well as the
     copy assignment operator. Note also that the <code>odb::nullable</code>
     implementation is not the most efficient in that it always contains
     a fully constructed value of the wrapped type. This is normally
     not a concern for simple types such as the C++ fundamental
     types or <code>std::string</code>. However, it may become
     an issue for more complex types. In such cases you may want to
     consider using a more efficient implementation of the
     <em>optional value</em> concept such as the
     <code>optional</code> class template from Boost
     (<a href="#16.3">Section 16.3, "Optional Library"</a>).</p>

  <p>Another common C++ representation of a value that can be
     <code>NULL</code> is a pointer. ODB will automatically
     handle data members that are pointers to values, however,
     it will not automatically enable <code>NULL</code> values
     for such data members, as is the case for <code>odb::nullable</code>.
     Instead, if the <code>NULL</code> value is desired, we will
     need to enable it explicitly using the <code>db&nbsp;null</code>
     pragma. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  std::string first_;

  #pragma db null
  std::auto_ptr&lt;std::string> middle_;

  std::string last_;
};
  </pre>

  <p>The ODB compiler includes built-in support for using
     <code>std::auto_ptr</code> and <code>std::tr1::shared_ptr</code>
     as pointers to values. Plus, ODB profile libraries, that are
     available for commonly used frameworks and libraries (such as Boost and
     Qt), provide support for smart pointers found in these frameworks
     and libraries (<a href="#III">Part III, "Profiles"</a>).</p>

  <p>Currently, ODB supports the <code>NULL</code> semantics only
     for simple values. In future versions this support will be extended
     to composite values and containers. With this limitation in mind,
     we can still use smart pointers in data members of composite value
     and container types. The only restriction is that these pointers
     must not be <code>NULL</code>. For example:</p>

  <pre class="c++">
#pragma db value
struct name
{
  std::string first_;
  std::string last_;
};

#pragma db object
class person
{
  ...

  std::auto_ptr&lt;name> name_;
  std::auto_ptr&lt;std::vector&lt;name> > aliases_;
};
  </pre>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="8">8 Inheritance</a></h1>

  <p>In C++ inheritance can be used to achieve two different goals.
     We can employ inheritance to reuse common data and functionality
     in multiple classes. For example:</p>

  <pre class="c++">
class person
{
public:
  const std::string&amp;
  first () const;

  const std::string&amp;
  last () const;

private:
  std::string first_;
  std::string last_;
};

class employee: public person
{
  ...
};

class contractor: public person
{
  ...
};
</pre>

 <p>In the above example both the <code>employee</code> and
    <code>contractor</code> classes inherit the <code>first_</code>
    and <code>last_</code> data members as well as the <code>first()</code>
    and <code>last()</code> accessors from the <code>person</code> base
    class.</p>

 <p>A common trait of this inheritance style, referred to as <em>reuse
    inheritance</em> from now on, is the lack of virtual functions and
    a virtual destructor in the base class. Also with this style the
    application code is normally written in terms of derived classes
    instead of a base.</p>

 <p>The second way to utilize inheritance in C++ is to provide polymorphic
    behavior through a common interface. In this case the base class
    defines a number of virtual functions and, normally, a virtual
    destructor while the derived classes provide specific
    implementations of these virtual functions. For example:</p>

  <pre class="c++">
class person
{
public:
  enum employment_status
  {
    unemployed,
    temporary,
    permanent,
    self_employed
  };

  virtual employment_status
  employment () const = 0;

  virtual
  ~person ();
};

class employee: public person
{
public:
  virtual employment_status
  employment () const
  {
    return temporary_ ? temporary : permanent;
  }

private:
  bool temporary_;
};

class contractor: public person
{
public:
  virtual employment_status
  employment () const
  {
    return self_employed;
  }
};
</pre>

  <p>With this inheritance style, which we will call <em>polymorphism
     inheritance</em>, the application code normally works with derived
     classes via the base class interface. Note also that it is very common
     to mix both styles in the same hierarchy. For example, the above two
     code fragments can be combined so that the <code>person</code> base
     class provides the common data members and functions as well as
     defines the polymorphic interface.</p>

  <p>The following sections describe the available strategies for
     mapping reuse and polymorphism inheritance styles to a relational
     data model. Note also that the distinction between the two styles is
     conceptual rather than formal. For example, it is possible to treat
     a class hierarchy that defines virtual functions as a case of reuse
     inheritance if this results in the desired database mapping and
     semantics.</p>

  <p>Generally, classes that employ reuse inheritance are mapped to
     completely independent entities in the database. They use different
     object id spaces and should always be passed to and returned from
     the database operations as pointers or references to derived types.
     In other words, from the persistence point of view, such classes
     behave as if the data members from the base classes were copied
     verbatim into the derived ones.</p>

  <p>In contrast, classes that employ polymorphism inheritance share
     the object id space and can be passed to and returned from the
     database operations <em>polymorphically</em> as pointers or
     references to the base class.</p>

  <p>For both inheritance styles it is sometimes desirable to prevent
     instances of a base class from being stored in the database.
     To achieve this a persistent
     class can be declared abstract using the <code>db&nbsp;abstract</code>
     pragma (<a href="#11.1.3">Section 11.1.3, "<code>abstract</code>"</a>).
     Note that a <em>C++-abstract</em> class, or a class that
     has one or more pure virtual functions and therefore cannot be
     instantiated, is also <em>database-abstract</em>. However, a
     database-abstract class is not necessarily C++-abstract. The
     ODB compiler automatically treats C++-abstract classes as
     database-abstract.</p>

  <h2><a name="8.1">8.1 Reuse Inheritance</a></h2>

  <p>Each non-abstract class from the reuse inheritance hierarchy is
     mapped to a separate database table that contains all its data
     members, including those inherited from base classes. An abstract
     persistent class does not have to define an object id, nor a default
     constructor, and it does not have a corresponding database table.
     An abstract class cannot be a pointed-to object in a relationship.
     Multiple inheritance is supported as long as each base
     class is only inherited once. The following example shows a
     persistent class hierarchy employing reuse inheritance:</p>

<pre class="c++">
// Abstract person class. Note that it does not declare the
// object id.
//
#pragma db object abstract
class person
{
  ...

  std::string first_;
  std::string last_;
};

// Abstract employee class. It derives from the person class and
// declares the object id for all the concrete employee types.
//
#pragma db object abstract
class employee: public person
{
  ...

  #pragma db id auto
  unsigned long id_;
};

// Concrete permanent_employee class. Note that it doesn't define
// any data members of its own.
//
#pragma db object
class permanent_employee: public employee
{
  ...
};

// Concrete temporary_employee class. It adds the employment
// duration in months.
//
#pragma db object
class temporary_employee: public employee
{
  ...

  unsigned long duration_;
};

// Concrete contractor class. It derives from the person class
// (and not employee; an independent contractor is not considered
// an employee). We use the contractor's external email address
// as the object id.
//
#pragma db object
class contractor: public person
{
  ...

  #pragma db id
  std::string email_;
};
</pre>

  <p>The sample database schema for this hierarchy is shown below.</p>

<pre class="sql">
CREATE TABLE permanent_employee (
  first TEXT NOT NULL,
  last TEXT NOT NULL,
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT);

CREATE TABLE temporary_employee (
  first TEXT NOT NULL,
  last TEXT NOT NULL,
  id BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  duration BIGINT UNSIGNED NOT NULL);

CREATE TABLE contractor (
  first TEXT NOT NULL,
  last TEXT NOT NULL,
  email VARCHAR (255) NOT NULL PRIMARY KEY);
</pre>

  <p>The complete version of the code presented in this section is
     available in the <code>inheritance</code> example in the
     <code>odb-examples</code> package.</p>

  <h2><a name="8.2">8.2 Polymorphism Inheritance</a></h2>

  <p>Polymorphism inheritance mapping is not yet implemented. Future
     versions of ODB will add support for this functionality.</p>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="9">9 Views</a></h1>

  <p>An ODB view is a C++ <code>class</code> or <code>struct</code> type
     that embodies a light-weight, read-only projection of one or more
     persistent objects or database tables or the result of a native SQL
     query execution.</p>

  <p>Some of the common applications of views include loading a subset
     of data members from objects or columns from database tables, executing
     and handling results of arbitrary SQL queries, including aggregate
     queries, as well as joining multiple objects and/or database tables
     using object relationships or custom join conditions.</p>

  <p>Many relational databases also define the concept of views. Note,
     however, that ODB views are not mapped to database views. Rather,
     by default, an ODB view is mapped to an SQL <code>SELECT</code>
     query. However, if desired, it is easy to create an ODB view
     that is based on a database view.</p>

  <p>Usually, views are defined in terms of other persistent entities,
     such as persistent objects, database tables, sequences, etc.
     Therefore, before we can examine our first view, we need to
     define a few persistent objects and a database table. We will
     use this model in examples throughout this chapter. Here we
     assume that you are familiar with ODB object relationship
     support (<a href="#6">Chapter 6, "Relationships"</a>).</p>

  <pre>
#pragma db object
class country
{
  ...

  #pragma db id
  std::string code_; // ISO 2-letter country code.

  std::string name_;
};

#pragma db object
class employer
{
  ...

  #pragma db id
  unsigned long id_;

  std::string name_;
};

#pragma db object
class employee
{
  ...

  #pragma db id
  unsigned long id_;

  std::string first_;
  std::string last_;

  unsigned short age_;

  shared_ptr&lt;country> residence_;
  shared_ptr&lt;country> nationality_;

  shared_ptr&lt;employer> employed_by_;
};
  </pre>

  <p>Besides these objects, we also have the legacy
     <code>employee_extra</code> table that is not mapped to any persistent
     class. It has the following definition:</p>

  <pre>
CREATE TABLE employee_extra(
  employee_id INTEGER NOT NULL,
  vacation_days INTEGER NOT NULL,
  previous_employer_id INTEGER)
  </pre>

  <p>The above persistent objects and database table as well as many of
     the views shown in this chapter are based on the
     <code>view</code> example which can be found in the
     <code>odb-examples</code> package of the ODB distribution.</p>

  <p>To declare a view we use the <code>db&nbsp;view</code> pragma,
     for example:</p>

  <pre>
#pragma db view object(employee)
struct employee_name
{
  std::string first;
  std::string last;
};
  </pre>

  <p>The above example shows one of the simplest views that we can create.
     It has a single associated object (<code>employee</code>) and its
     purpose is to extract the employee's first and last names without
     loading any other data, such as the referenced <code>country</code>
     and <code>employer</code> objects.</p>

  <p>Views use the same query facility (<a href="#4">Chapter 4, "Querying
     the Database"</a>) as persistent objects. Because support for queries
     is optional and views cannot be used without this support, you need
     to compile any header that defines a view with the
     <code>--generate-query</code> ODB compiler option.</p>

  <p>To query the database for a view we use the <code>database::query()</code>
     function in exactly the same way as we would use it to query the
     database for an object. For example, the following code fragment
     shows how we can find the names of all the employees that are
     younger than 31:</p>

  <pre>
typedef odb::query&lt;employee_name> query;
typedef odb::result&lt;employee_name> result;

transaction t (db.begin ());

result r (db.query&lt;employee_name> (query::age &lt; 31));

for (result::iterator i (r.begin ()); i != r.end (); ++i)
{
  const employee_name&amp; en (*i);
  cout &lt;&lt; en.first &lt;&lt; " " &lt;&lt; en.last &lt;&lt; endl;
}

t.commit ();
  </pre>

  <p>A view can be defined as a projection of one or more objects, one
     or more tables, a combination of objects and tables, or it can be
     the result of a custom SQL query. The following sections discuss each
     of these kinds of view in more detail.</p>

  <h2><a name="9.1">9.1 Object Views</a></h2>

  <p>To associate one or more objects with a view we use the
     <code>db&nbsp;object</code> pragma (<a href="#11.2.1">Section
     11.2.1, "<code>object</code>"</a>). We have already seen
     a simple, single-object view in the introduction to this chapter.
     To associate the second and subsequent objects we repeat the
     <code>db&nbsp;object</code> pragma for each additional object,
     for example:</p>

  <pre>
#pragma db view object(employee) object(employer)
struct employee_employer
{
  std::string first;
  std::string last;
  std::string name;
};
  </pre>

  <p>The complete syntax of the <code>db&nbsp;object</code> pragma is
     shown below:</p>

  <p><code><b>object(</b><i>name</i>
                     [<b>=</b> <i>alias</i>]
                     [<b>:</b> <i>join-condition</i>]<b>)</b></code></p>

  <p>The <i>name</i> part is a potentially qualified persistent class
     name that has been defined previously. The optional <i>alias</i>
     part gives this object an alias. If provided, the alias is used
     in several contexts instead of the object's unqualified name. We
     will discuss aliases further as we cover each of these contexts
     below. The optional <i>join-condition</i> part provides the
     criteria which should be used to associate this object with any
     of the previously associated objects or, as we will see in
     <a href="#9.3">Section 9.3, "Mixed Views"</a>, tables. Note that
     while the first associated object can have an alias, it cannot
     have a join condition.</p>

  <p>For each subsequent associated object the ODB compiler needs
     a join condition and there are several ways to specify
     it. The easiest way is to omit it altogether and let the ODB
     compiler try to come up with a join condition automatically.
     To do this the ODB compiler will examine each previously
     associated object for object relationships
     (<a href="#6">Chapter 6, "Relationships"</a>) that
     may exist between these objects and the object being associated.
     If such a relationship exists and is unambiguous, that is
     there is only one such relationship, then the ODB compiler
     will automatically use it to come up with the join condition for
     this object. This is exactly what happens in the previous
     example: there is a single relationship
     (<code>employee::employed_by</code>) between the
     <code>employee</code> and <code>employer</code> objects.</p>

  <p>On the other hand, consider this view:</p>

  <pre>
#pragma db view object(employee) object(country)
struct employee_residence
{
  std::string first;
  std::string last;
  std::string name;
};
  </pre>

  <p>While there is a relationship between <code>country</code> and
     <code>employee</code>, it is ambiguous. It can be
     <code>employee::residence_</code> (which is what we want) or
     it can be <code>employee::nationality_</code> (which we don't
     want). As result, when compiling the above view, the ODB
     compiler will issue an error indicating an ambiguous object
     relationship. To resolve this ambiguity, we can explicitly
     specify the object relationship that should be used to create
     the join condition as the name of the corresponding data member.
     Here is how we can fix the <code>employee_residence</code>
     view:</p>

  <pre>
#pragma db view object(employee) object(country: employee::residence_)
struct employee_residence
{
  std::string first;
  std::string last;
  std::string name;
};
  </pre>

  <p>It is possible to associate the same object with a single view
     more than once using different join conditions. However, in
     this case, we have to use aliases to assign different names
     for each association. For example:</p>

  <pre>
#pragma db view object(employee) \
  object(country = res_country: employee::residence_) \
  object(country = nat_country: employee::nationality_)
struct employee_country
{
  ...
};
  </pre>

  <p>Note that correctly defining data members in this view requires
     the use of a mechanism that we haven't yet covered. We will
     see how to do this shortly.</p>

  <p>If we assign an alias to an object and refer to a data member of
     this object in one of the join conditions, we have to use the
     unqualified alias name instead of the potentially qualified
     object name. For example:</p>

  <pre>
#pragma db view object(employee = ee) object(country: ee::residence_)
struct employee_residence
{
  ...
};
  </pre>

  <p>The last way to specify a join condition is to provide a custom
     query expression. This method is primarily useful if you would
     like to associate an object using a condition that does not
     involve an object relationship. Consider, for example, a
     modified <code>employee</code> object from the beginning of
     the chapter with an added country of birth member. For one
     reason or another we have decided not to use a relationship to
     the <code>country</code> object, as we have done with
     residence and nationality.</p>

  <pre>
#pragma db object
class employee
{
  ...

  std::string birth_place_; // Country name.
};
  </pre>

  <p>If we now want to create a view that returns the birth country code
     for an employee, then we have to use a custom join condition when
     associating the <code>country</code> object. For example:</p>

  <pre>
#pragma db view object(employee) \
  object(country: employee::birth_place_ == country::name_)
struct employee_birth_code
{
  std::string first;
  std::string last;
  std::string code;
};
  </pre>

  <p>The syntax of the query expression in custom join conditions
     is the same as in the query facility used to query the database
     for objects (<a href="#4">Chapter 4, "Querying the Database"</a>)
     except that for query members, instead of using
     <code>odb::query&lt;object>::member</code> names, we refer directly
     to object members.</p>

  <p>Looking at the views we have defined so far, you may be wondering
     how the ODB compiler knows which view data members correspond to which
     object data members. While the names are similar, they are not exactly
     the same, for example <code>employee_name::first</code> and
     <code>employee::first_</code>.</p>

  <p>As with join conditions, when it comes to associating data members,
     the ODB compiler tries to do this automatically. It first searches
     all the associated objects for an exact name match. If no match is
     found, then the ODB compiler compares the so-called public names.
     A public name of a member is obtained by removing the common member
     name decorations, such as leading and trailing underscores, the
     <code>m_</code> prefix, etc. In both of these searches the ODB
     compiler also makes sure that the types of the two members are the
     same or compatible.</p>

  <p>If one of the above searches returned a match and it is unambiguous, that
     is there is only one match, then the ODB compiler will automatically
     associate the two members. On the other hand, if no match is found
     or the match is ambiguous, the ODB compiler will issue an error.
     To associate two differently-named members or to resolve an ambiguity,
     we can explicitly specify the member association using the
     <code>db&nbsp;column</code> pragma (<a href="#11.4.7">Section 11.4.7,
     "<code>column</code>"</a>). For example:</p>

  <pre>
#pragma db view object(employee) object(employer)
struct employee_employer
{
  std::string first;
  std::string last;

  #pragma db column(employer::name_)
  std::string employer_name;
};
  </pre>

  <p>If an object data member specifies the SQL type with
     the <code>db&nbsp;type</code> pragma (<a href="#11.4.3">Section
     11.4.3, "<code>type</code>"</a>), then this type is also used for
     the associated view data members.</p>

  <p>Note also that similar to join conditions, if we assign an alias to
     an object and refer to a data member of this object in one of the
     <code>db&nbsp;column</code> pragmas, then we have to use the
     unqualified alias name instead of the potentially qualified
     object name. For example:</p>

  <pre>
#pragma db view object(employee) \
  object(country = res_country: employee::residence_) \
  object(country = nat_country: employee::nationality_)
struct employee_country
{
  std::string first;
  std::string last;

  #pragma db column(res_country::name_)
  std::string res_country_name;

  #pragma db column(nat_country::name_)
  std::string nat_country_name;
};
  </pre>

  <p>Besides specifying just the object member, we can also specify a
     <em>+-expression</em> in the <code>db&nbsp;column</code> pragma. A
     +-expression consists of string literals and object
     member references connected using the <code>+</code> operator.
     It is primarily useful for defining aggregate views based on
     SQL aggregate functions, for example:</p>

  <pre>
#pragma db view object(employee)
struct employee_count
{
  #pragma db column("count(" + employee::id_ + ")")
  std::size_t count;
};
  </pre>

  <p>When querying the database for a view, we may want to provide
     additional query criteria based on the objects associated with
     this view. To support this a view defines query members for all
     the associated objects which allows us to refer to such objects'
     members using the <code>odb::query&lt;view>::member</code> expressions.
     This is similar to how we can refer to object members using the
     <code>odb::query&lt;object>::member</code> expressions when
     querying the database for an object. For example:</p>

  <pre>
typedef odb::result&lt;employee_count> result;
typedef odb::query&lt;employee_count> query;

transaction t (db.begin ());

// Find the number of employees with the Doe last name.
//
result r (db.query&lt;employee_count> (query::last == "Doe"));

// Result of this aggregate query contains only one element.
//
cout &lt;&lt; r.begin ()->count &lt;&lt; endl;

t.commit ();
  </pre>

  <p>In the above query we used the last name data member from the associated
     <code>employee</code> object to only count employees with the specific
     name.</p>

  <p>When a view has only one associated object, the query members
     corresponding to this object are defined directly in the
     <code>odb::query&lt;view></code> scope. For instance,
     in the above example, we referred to the last name member as
     <code>odb::query&lt;employee_count>::last</code>. However, if
     a view has multiple associated objects, then query members
     corresponding to each such object are defined in a nested
     scope named after the object. As an example, consider
     the <code>employee_employer</code> view again:</p>

  <pre>
#pragma db view object(employee) object(employer)
struct employee_employer
{
  std::string first;
  std::string last;

  #pragma db column(employer::name_)
  std::string employer_name;
};
  </pre>

  <p>Now, to refer to the last name data member from the <code>employee</code>
     object we use the
     <code>odb::query&lt;...>::employee::last</code> expression.
     Similarly, to refer to the employer name, we use the
     <code>odb::query&lt;...>::employer::name</code> expression.
     For example:</p>

  <pre>
typedef odb::result&lt;employee_employer> result;
typedef odb::query&lt;employee_employer> query;

transaction t (db.begin ());

result r (db.query&lt;employee_employer> (
  query::employee::last == "Doe" &amp;&amp;
  query::employer::name == "Simple Tech Ltd"));

for (result::iterator i (r.begin ()); i != r.end (); ++i)
  cout &lt;&lt; i->first &lt;&lt; " " &lt;&lt; i->last &lt;&lt;  " " &lt;&lt; i->employer_name &lt;&lt; endl;

t.commit ();
  </pre>

  <p>If we assign an alias to an object, then this alias is used to
     name the query members scope instead of the object name. As an
     example, consider the <code>employee_country</code> view again:</p>

  <pre>
#pragma db view object(employee) \
  object(country = res_country: employee::residence_) \
  object(country = nat_country: employee::nationality_)
struct employee_country
{
  ...
};
  </pre>

  <p>And a query which returns all the employees that have the same
     country of residence and nationality:</p>

  <pre>
typedef odb::query&lt;employee_country> query;
typedef odb::result&lt;employee_country> result;

transaction t (db.begin ());

result r (db.query&lt;employee_country> (
  query::res_country::name == query::nat_country::name));

for (result::iterator i (r.begin ()); i != r.end (); ++i)
  cout &lt;&lt; i->first &lt;&lt; " " &lt;&lt; i->last &lt;&lt; " " &lt;&lt; i->res_country_name &lt;&lt; endl;

t.commit ();
  </pre>

  <p>Note also that unlike object query members, view query members do
     no support referencing members in related objects. For example,
     the following query is invalid:</p>

  <pre>
typedef odb::query&lt;employee_name> query;
typedef odb::result&lt;employee_name> result;

transaction t (db.begin ());

result r (db.query&lt;employee_name> (
  query::employed_by->name == "Simple Tech Ltd"));

t.commit ();
  </pre>

  <p>To get this behavior, we would instead need to associate the
     <code>employer</code> object with this view and then use the
     <code>query::employer::name</code> expression instead of
     <code>query::employed_by->name</code>.</p>

  <p>As we have discussed above, if specified, an object alias is
     used instead of the object name in the join condition, data
     member references in the <code>db&nbsp;column</code> pragma,
     as well as to name the query members scope. The object alias
     is also used as a table name alias in the underlying
     <code>SELECT</code> statement generated by the ODB compiler.
     Normally, you would not use the table alias directly with
     object views. However, if for some reason you need to refer
     to a table column directly, for example, as part of a native
     query expression, and you need to qualify the column with
     the table, then you will need to use the table alias instead.</p>

  <h2><a name="9.2">9.2 Table Views</a></h2>

  <p>A table view is similar to an object view except that it is
     based on one or more database tables instead of persistent
     objects. Table views are primarily useful when dealing with
     ad-hoc tables that are not mapped to persistent classes.</p>

  <p>To associate one or more tables with a view we use the
     <code>db&nbsp;table</code> pragma (<a href="#11.2.2">Section 11.2.2,
     "<code>table</code>"</a>). To associate the second and subsequent
     tables we repeat the <code>db&nbsp;table</code> pragma for each
     additional table. For example, the following view is based on the
     <code>employee_extra</code> legacy table we have defined at the
     beginning of the chapter.</p>

  <pre>
#pragma db view table("employee_extra")
struct employee_vacation
{
  #pragma db column("employee_id") type("INTEGER")
  unsigned long employee_id;

  #pragma db column("vacation_days") type("INTEGER")
  unsigned short vacation_days;
};
  </pre>

  <p>Besides the table name in the <code>db&nbsp;table</code> pragma
     we also have to specify the column name for each view data
     member. Note that unlike for object views, the ODB compiler
     does not try to automatically come up with column names for
     table views. Furthermore, we cannot use references to object
     members either, since there are no associated objects in table
     views. Instead, the actual column name or column expression
     must be specified as a string literal. The column name can
     also be qualified with a table name either in the
     <code>"table.column"</code> form or, if either a table
     or a column name contains a period, in the
     <code>"table"."column"</code> form. The following example
     illustrates the use of a column expression:</p>

  <pre>
#pragma db view table("employee_extra")
struct employee_max_vacation
{
  #pragma db column("max(vacation_days)") type("INTEGER")
  unsigned short max_vacation_days;
};
  </pre>

  <p>Note also that in the above examples we specified the SQL type
     for each of the columns to make sure that the ODB compiler
     has knowledge of the actual types as specified in the database
     schema. This is required to obtain correct and optimal
     generated code.</p>


  <p>The complete syntax of the <code>db&nbsp;table</code> pragma
     is similar to the <code>db&nbsp;object</code> pragma and is shown
     below:</p>

  <p><code><b>table("</b><i>name</i><b>"</b>
                    [<b>=</b> <b>"</b><i>alias</i><b>"</b>]
                    [<b>:</b> <i>join-condition</i>]<b>)</b></code></p>

  <p>The <i>name</i> part is a database table name. The optional
     <i>alias</i> part gives this table an alias. If provided, the
     alias must be used instead of the table whenever a reference
     to a table is used. Contexts where such a reference may
     be needed include the join condition (discussed below),
     column names, and query expressions. The optional <i>join-condition</i>
     part provides the criteria which should be used to associate this
     table with any of the previously associated tables or, as we will see in
     <a href="#9.3">Section 9.3, "Mixed Views"</a>, objects. Note that
     while the first associated table can have an alias, it cannot have
     a join condition.</p>

  <p>Similar to object views, for each subsequent associated table the
     ODB compiler needs a join condition. However, unlike for object views,
     for table views the ODB compiler does not try to come up with one
     automatically. Furthermore, we cannot use references to object
     members corresponding to object relationships either, since there
     are no associated objects in table views. Instead, for each
     subsequent associated table, a join condition must be
     specified as a custom query expression. While the syntax of the
     query expression is the same as in the query facility used to query
     the database for objects (<a href="#4">Chapter 4, "Querying the
     Database"</a>), a join condition for a table is normally specified
     as a single string literal containing a native SQL query expression.</p>

  <p>As an example of a multi-table view, consider the
     <code>employee_health</code> table that we define in addition
     to <code>employee_extra</code>:</p>

  <pre>
CREATE TABLE employee_health(
  employee_id INTEGER NOT NULL,
  sick_leave_days INTEGER NOT NULL)
  </pre>

  <p>Given these two tables we can now define a view that returns both
     the vacation and sick leave information for each employee:</p>

  <pre>
#pragma db view table("employee_extra" = "extra") \
  table("employee_health" = "health": \
        "extra.employee_id = health.employee_id")
struct employee_leave
{
  #pragma db column("extra.employee_id") type("INTEGER")
  unsigned long employee_id;

  #pragma db column("vacation_days") type("INTEGER")
  unsigned short vacation_days;

  #pragma db column("sick_leave_days") type("INTEGER")
  unsigned short sick_leave_days;
};
  </pre>

  <p>Querying the database for a table view is the same as for an
     object view except that we can only use native query expressions.
     For example:</p>

  <pre>
typedef odb::query&lt;employee_leave> query;
typedef odb::result&lt;employee_leave> result;

transaction t (db.begin ());

unsigned short v_min = ...
unsigned short l_min = ...

result r (db.query&lt;employee_leave> (
  "vacation_days > " + query::_val(v_min) + "AND"
  "sick_leave_days > " + query::_val(l_min)));

t.commit ();
  </pre>


  <h2><a name="9.3">9.3 Mixed Views</a></h2>

  <p>A mixed view has both associated objects and tables. As a first
     example of a mixed view, let us improve <code>employee_vacation</code>
     from the previous section to return the employee's first
     and last names instead of the employee id. To achieve this we
     have to associate both the <code>employee</code> object and
     the <code>employee_extra</code> table with the view:</p>

  <pre>
#pragma db view object(employee) \
  table("employee_extra" = "extra": "extra.employee_id = " + employee::id_)
struct employee_vacation
{
  std::string first;
  std::string last;

  #pragma db column("extra.vacation_days") type("INTEGER")
  unsigned short vacation_days;
};
  </pre>

  <p>When querying the database for a mixed view, we can use query members
     for the parts of the query expression that involves object members
     but have to fall back to using the native syntax for the parts that
     involve table columns. For example:</p>

  <pre>
typedef odb::query&lt;employee_vacation> query;
typedef odb::result&lt;employee_vacation> result;

transaction t (db.begin ());

result r (db.query&lt;employee_vacation> (
  (query::last == "Doe") + "AND extra.vacation_days &lt;> 0"));

for (result::iterator i (r.begin ()); i != r.end (); ++i)
  cout &lt;&lt; i->first &lt;&lt; " " &lt;&lt; i->last &lt;&lt; " " &lt;&lt; i->vacation_days &lt;&lt; endl;

t.commit ();
  </pre>

  <p>As another example, consider a more advanced view that associates
     two objects via a legacy table. This view allows us to find the
     previous employer name for each employee:</p>

  <pre>
#pragma db view object(employee) \
  table("employee_extra" = "extra": "extra.employee_id = " + employee::id_) \
  object(employer: "extra.previous_employer_id = " + employer::id_)
struct employee_prev_employer
{
  std::string first;
  std::string last;

  // If previous_employer_id is NULL, then the name will be NULL as well.
  // We use the odb::nullable wrapper to handle this.
  //
  #pragma db column(employer::name_)
  odb::nullable&lt;std::string> prev_employer_name;
};
  </pre>

  <h2><a name="9.4">9.4 View Query Conditions</a></h2>

  <p>Object, table, and mixed views can also specify an optional query
     condition that should be used whenever the database is queried for
     this view. To specify a query condition we use the
     <code>db&nbsp;query</code> pragma (<a href="#11.2.3">Section 11.2.3,
     "<code>query</code>"</a>).</p>

  <p>As an example, consider a view that returns some information about
     all the employees that are over a predefined retirement age.
     One way to implement this would be to define a standard object
     view as we have done in the previous sections and then use a
     query like this:</p>

  <pre>
result r (db.query&lt;employee_retirement> (query::age > 50));
  </pre>

  <p>The problem with the above approach is that we have to keep
     repeating the <code>query::age > 50</code> expression every
     time we execute the query, even though this expression always
     stays the same. View query conditions allow us to solve this
     problem. For example:</p>

  <pre>
#pragma db view object(employee) query(employee::age > 50)
struct employee_retirement
{
  std::string first;
  std::string last;
  unsigned short age;
};
  </pre>

  <p>With this improvement we can rewrite our query like this:</p>

  <pre>
result r (db.query&lt;employee_retirement> ());
  </pre>

   <p>But what if we may also need to restrict the result set based on
      some varying criteria, such as the employee's last name? Or, in other
      words, we may need to combine a constant query expression specified
      in the <code>db&nbsp;query</code> pragma with the varying expression
      specified at the query execution time. To allow this, the
      <code>db&nbsp;query</code> pragma syntax supports the use of a special
      <code>(?)</code> placeholder that indicates the position in the
      constant query expression where the runtime expression should be
      inserted. For example:</p>

  <pre>
#pragma db view object(employee) query(employee::age > 50 &amp;&amp; (?))
struct employee_retirement
{
  std::string first;
  std::string last;
  unsigned short name;
};
  </pre>

  <p>With this change we can now use additional query criteria in our
     view:</p>

  <pre>
result r (db.query&lt;employee_retirement> (query::last == "Doe"));
  </pre>

  <p>The syntax of the expression in a query condition is the same as in
     the query facility used to query the database for objects
     (<a href="#4">Chapter 4, "Querying the Database"</a>) except for
     two differences. Firstly, for query members, instead of
     using <code>odb::query&lt;object>::member</code> names, we refer
     directly to object members, using the object alias instead of the
     object name if an alias was assigned. Secondly, query conditions
     support the special <code>(?)</code> placeholder which can be used
     both in the C++-integrated query expressions as was shown above
     and in native SQL expressions specified as string literals. The
     following view is an example of the latter case:</p>

  <pre>
#pragma db view table("employee_extra") \
  query("vacation_days &lt;> 0 AND (?)")
struct employee_vacation
{
  ...
};
  </pre>

  <p>Another common use case for query conditions are views with the
     <code>ORDER BY</code> or <code>GROUP BY</code> clause. Such
     clauses are normally present in the same form in every query
     involving such views. As an example, consider an aggregate
     view which calculate the minimum and maximum ages of employees
     for each employer:</p>

  <pre>
#pragma db view object(employee) object(employer) \
  query ((?) + "GROUP BY" + employer::name_)
struct employer_age
{
  #pragma db column(employer::name_)
  std::string employer_name;

  #pragma db column("min(" + employee::age_ + ")")
  unsigned short min_age;

  #pragma db column("max(" + employee::age_ + ")")
  unsigned short max_age;
};
  </pre>

  <h2><a name="9.5">9.5 Native Views</a></h2>

  <p>The last kind of view supported by ODB is a native view. Native
     views are a low-level mechanism for capturing results of native
     SQL queries. Native views don't have associated tables or objects.
     Instead, we use the <code>db&nbsp;query</code> pragma to specify
     the native SQL query, which must at a minimum include the
     select-list and, if applicable, the from-list. For example, here
     is how we can re-implement the <code>employee_vacation</code> table
     view from Section 9.2 above as a native view:</p>

  <pre>
#pragma db view query("SELECT employee_id, vacation_days " \
                      "FROM employee_extra")
struct employee_vacation
{
  #pragma db type("INTEGER")
  unsigned long employee_id;

  #pragma db type("INTEGER")
  unsigned short vacation_days;
};
  </pre>

  <p>In native views the columns in the query select-list are
     associated with the view data members in the order specified.
     That is, the first column is stored in the first member, the
     second column &mdash; in the second member, and so on. The ODB compiler
     does not perform any error checking in this association. As a result
     you must make sure that the number and order of columns in the
     query select-list match the number and order of data members
     in the view. This is also the reason why we are not
     required to provide the column name for each data member in native
     views, as is the case for object and table views.</p>

  <p>Note also that while it is always possible to implement a table
     view as a native view, the table views must be preferred since
     they are safer. In a native view, if you add, remove, or
     rearrange data members without updating the column list in the
     query, or vice versa, at best, this will result in a runtime
     error. In contrast, in a table view such changes will result
     in the query being automatically updated.</p>

  <p>Similar to object and table views, the query specified for
     a native view can contain the special <code>(?)</code>
     placeholder which is replaced with the query expression
     specified at the query execution time.
     If the native query does not contain a placeholder, as in
     the example above, then any query expression specified at
     the query execution time is appended to the query text
     along with the <code>WHERE</code> keyword, if required.
     The following example shows the usage of the placeholder:</p>

  <pre>
#pragma db view query("SELECT employee_id, vacation_days " \
                      "FROM employee_extra " \
                      "WHERE vacation_days &lt;> 0 AND (?)")
struct employee_vacation
{
  ...
};
  </pre>

  <p>As another example, consider a view that returns the next
     value of a database sequence:</p>

  <pre>
#pragma db view query("SELECT nextval('my_seq')")
struct sequence_value
{
  unsigned long long value;
};
  </pre>

  <p>While this implementation can be acceptable in some cases, it has
     a number of drawbacks. Firstly, the name of the sequence is
     fixed in the view, which means if we have a second sequence, we
     will have to define another, almost identical view. Similarly,
     the operation that we perform on the sequence is also fixed.
     In some situations, instead of returning the next value, we may
     need the last value.</p>

  <p>Note that we cannot use the placeholder mechanism to resolve
     these problems since placeholders can only be used in the
     <code>WHERE</code>, <code>GROUP BY</code>, and similar
     clauses. In other words, the following won't work:</p>

  <pre>
#pragma db view query("SELECT nextval('(?)')")
struct sequence_value
{
  unsigned long long value;
};

result r (db.query&lt;sequence_value> ("my_seq"));
  </pre>

  <p>To support these kinds of use cases, ODB allows us to specify the
     complete query for a native view at runtime rather than at the view
     definition. To indicate that a native view has a runtime query,
     we can either specify the empty <code>db&nbsp;query</code>
     pragma or omit the pragma altogether. For example:</p>

  <pre>
#pragma db view
struct sequence_value
{
  unsigned long long value;
};
  </pre>

  <p>Given this view, we can perform the following queries:</p>

  <pre>
typedef odb::query&lt;sequence_value> query;
typedef odb::result&lt;sequence_value> result;

string seq_name = ...

result l (db.query&lt;sequence_value> (
  "SELECT lastval('" + seq_name + "')"));

result n (db.query&lt;sequence_value> (
  "SELECT nextval('" + seq_name + "')"));
  </pre>


  <h2><a name="9.6">9.6 Other View Features and Limitations</a></h2>

  <p>Views cannot be derived from other views. However, you can derive
     a view from a transient C++ class. View data members cannot be
     object pointers. If you need to access data from a pointed-to
     object, then you will need to associate such an object with
     the view. Similarly, view data members cannot be containers.
     These two limitations also apply to composite value types that
     contain object pointers or containers. Such composite values
     cannot be used as view data members.</p>

  <p>On the other hand, composite values that do not contain object
     pointers or containers can be used in views. As an example,
     consider a modified version of the <code>employee</code> persistent
     class that stores a person's name as a composite value:</p>

  <pre>
#pragma db value
class person_name
{
  std::string first_;
  std::string last_;
};

#pragma db object
class employee
{
  ...

  person_name name_;

  ...
};
  </pre>

  <p>Given this change, we can re-implement the <code>employee_name</code>
     view like this:</p>

  <pre>
#pragma db view object(employee)
struct employee_name
{
  person_name name;
};
  </pre>

  <p>It is also possible to extract some or all of the nested members
     of a composite value into individual view data members. Here is
     how we could have defined the <code>employee_name</code> view
     if we wanted to keep its original structure:</p>

  <pre>
#pragma db view object(employee)
struct employee_name
{
  #pragma db column(employee::name.first_)
  std::string first;

  #pragma db column(employee::name.last_)
  std::string last;
};
  </pre>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="10">10 Session</a></h1>

  <p>A session is an application's unit of work that may encompass several
     database transactions. In this version of ODB a session is just an
     object cache. In future versions it will provide additional
     functionality, such as automatic object state change tracking
     and optimistic concurrency.</p>

  <p>Each thread of execution in an application can have only one active
     session at a time. A session is started by creating an instance of
     the <code>odb::session</code> class and is automatically terminated
     when this instance is destroyed. You will need to include the
     <code>&lt;odb/session.hxx></code> header file to make this class
     available in your application. For example:</p>

  <pre class="c++">
#include &lt;odb/database.hxx>
#include &lt;odb/session.hxx>
#include &lt;odb/transaction.hxx>

using namespace odb::core;

{
  session s;

  // First transaction.
  //
  {
    transaction t (db.begin ());
    ...
    t.commit ();
  }

  // Second transaction.
  //
  {
    transaction t (db.begin ());
    ...
    t.commit ();
  }

  // Session 's' is terminated here.
}
  </pre>

  <p>The <code>session</code> class has the following interface:</p>

  <pre class="c++">
namespace odb
{
  class session
  {
  public:
    session ();
    ~session ();

    // Copying or assignment of sessions is not supported.
    //
  private:
    session (const session&amp;);
    session&amp; operator= (const session&amp;);

    // Current session interface.
    //
  public:
    static session&amp;
    current ();

    static bool
    has_current ();

    static void
    current (session&amp;);

    static void
    reset_current ();

    // Object cache interface.
    //
  public:
    typedef odb::database database_type;

    template &lt;typename T>
    void
    insert (database_type&amp;,
            const object_traits&lt;T>::id_type&amp;,
            const object_traits&lt;T>::pointer_type&amp;);

    template &lt;typename T>
    object_traits&lt;T>::pointer_type
    find (database_type&amp;, const object_traits&lt;T>::id_type&amp;) const;

    template &lt;typename T>
    void
    erase (database_type&amp;, const object_traits&lt;T>::id_type&amp;);
  };
}
  </pre>

  <p>The session constructor creates a new session and sets it as a
     current session for this thread. If we try to create another
     session while there is already a current session in effect,
     the constructor throws the <code>odb::already_in_session</code>
     exception. The destructor clears the current session for this
     thread if this session is the current one.</p>

  <p>The static <code>current()</code> accessor returns the currently active
     session for this thread. If there is no active session, this function
     throws the <code>odb::not_in_session</code> exception. We can check
     whether there is a session in effect in this thread using the
     <code>has_current()</code> static function.</p>

  <p>The static <code>current()</code> modifier allows us to set the
     current session for this thread. The <code>reset_current()</code>
     static function clears the current session. These two functions
     allow for more advanced use cases, such as multiplexing
     two or more sessions on the same thread.</p>

  <p>We normally don't use the object cache interface directly. However,
     it could be useful in some cases, for example, to find out whether
     an object has already been loaded.</p>

  <h2><a name="10.1">10.1 Object Cache</a></h2>

  <p>A session is an object cache. Every time an object is made persistent
     by calling the <code>database::persist()</code> function
     (<a href="#3.7">Section 3.7, "Making Objects Persistent"</a>), loaded
     by calling the <code>database::load()</code> or <code>database::find()</code>
     function (<a href="#3.8">Section 3.8, "Loading Persistent Objects"</a>),
     or loaded by iterating over a query result (<a href="#4.4">Section 4.4,
     "Query Result"</a>), the pointer to the persistent object, in the form
     of the canonical object pointer (<a href="#3.2">Section 3.2, "Object
     and View Pointers"</a>), is stored in the session. For as long as the
     session is in effect, any subsequent calls to load the same object will
     return the cached instance. When an object's state is deleted from the
     database with the <code>database::erase()</code> function
     (<a href="#3.10">Section 3.10, "Deleting Persistent Objects"</a>), the
     cached object pointer is removed from the session. For example:</p>

  <pre class="c++">
shared_ptr&lt;person> p (new person ("John", "Doe"));

session s;
transaction t (db.begin ());

unsigned long id (db.persist (p));            // p is cached in s.
shared_ptr&lt;person> p1 (db.load&lt;person> (id)); // p1 same as p.

t.commit ();
  </pre>


  <p>The per-object caching policies depend on the object pointer kind
     (<a href="#6.4">Section 6.4, "Using Custom Smart Pointers"</a>).
     Objects with a unique pointer, such as <code>std::auto_ptr</code>,
     as an object pointer are never cached since it is not possible to have
     two such pointers pointing to the same object. When an object is
     persisted via a pointer or loaded as a dynamically allocated instance,
     objects with both raw and shared pointers as object pointers are
     cached. If an object is persisted as a reference or loaded into
     a pre-allocated instance, the object is only cached if its object
     pointer is a raw pointer.</p>

  <p>Also note that when we persist an object as a constant reference
     or constant pointer, the session caches such an object as
     unrestricted (non-<code>const</code>). This can lead to undefined
     behavior if the object being persisted was actually created as
     <code>const</code> and is later found in the session cache and
     used as non-<code>const</code>. As a result, when using sessions,
     it is recommended that all persistent objects be created as
     non-<code>const</code> instances. The following code fragment
     illustrates this point:</p>

  <pre class="c++">
void save (database&amp; db, shared_ptr&lt;const person> p)
{
  transaction t (db.begin ());
  db.persist (p); // Persisted as const pointer.
  t.commit ();
}

session s;

shared_ptr&lt;const person> p1 (new const person ("John", "Doe"));
unsigned long id1 (save (db, p1)); // p1 is cached in s as non-const.

{
  transaction t (db.begin ());
  shared_ptr&lt;person> p (db.load&lt;person> (id1)); // p == p1
  p->age (30); // Undefined behavior since p1 was created const.
}

shared_ptr&lt;const person> p2 (new person ("Jane", "Doe"));
unsigned long id2 (save (db, p2)); // p2 is cached in s as non-const.

{
  transaction t (db.begin ());
  shared_ptr&lt;person> p (db.load&lt;person> (id2)); // p == p2
  p->age (30); // Ok, since p2 was not created const.
}
  </pre>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="11">11 ODB Pragma Language</a></h1>

  <p>As we have already seen in previous chapters, ODB uses a pragma-based
     language to capture database-specific information about C++ types.
     This chapter describes the ODB pragma language in more detail. It
     can be read together with other chapters in the manual to get a
     sense of what kind of configurations and mapping fine-tuning are
     possible. You can also use this chapter as a reference at a later
     stage.</p>

  <p>An ODB pragma has the following syntax:</p>

  <p><code>#pragma db <i>qualifier</i> [<i>specifier</i> <i>specifier</i> ...]</code></p>

  <p>The <em>qualifier</em> tells the ODB compiler what kind of C++ construct
     this pragma describes. Valid qualifiers are <code>object</code>,
     <code>view</code>, <code>value</code>, and <code>member</code>.
     A pragma with the <code>object</code> qualifier describes a persistent
     object type. It tells the ODB compiler that the C++ class it
     describes is a persistent class. Similarly, pragmas with the
     <code>view</code> qualifier describe view types, the <code>value</code>
     qualifier describes value types and the <code>member</code>
     qualifier is used to describe data members of persistent object,
     view, and value types.</p>

  <p>The <em>specifier</em> informs the ODB compiler about a particular
     database-related property of the C++ declaration. For example, the
     <code>id</code> member specifier tells the ODB compiler that this
     member contains this object's identifier. Below is the declaration
     of the <code>person</code> class that shows how we can use ODB
     pragmas:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...
private:
  #pragma db member id
  unsigned long id_;
  ...
};
  </pre>

  <p>In the above example we don't explicitly specify which C++ class or
     data member the pragma belongs to. Rather, the pragma applies to
     a C++ declaration that immediately follows the pragma. Such pragmas
     are called <em>positioned pragmas</em>. In positioned pragmas that
     apply to data members, the <code>member</code> qualifier can be
     omitted for brevity, for example:</p>

  <pre class="c++">
  #pragma db id
  unsigned long id_;
  </pre>

  <p>Note also that if the C++ declaration immediately following a
     position pragma is incompatible with the pragma qualifier, an
     error will be issued. For example:</p>

  <pre class="c++">
  #pragma db object  // Error: expected class instead of data member.
  unsigned long id_;
  </pre>

  <p>While keeping the C++ declarations and database declarations close
     together eases maintenance and increases readability, we can also
     place them in different parts of the same header file or even
     factor them to a separate file. To achieve this we use the so called
     <em>named pragmas</em>. Unlike positioned pragmas, named pragmas
     explicitly specify the C++ declaration to which they apply by
     adding the declaration name after the pragma qualifier. For example:</p>

  <pre class="c++">
class person
{
  ...
private:
  unsigned long id_;
  ...
};

#pragma db object(person)
#pragma db member(person::id_) id
  </pre>

  <p>Note that in the named pragmas for data members the <code>member</code>
     qualifier is no longer optional. The C++ declaration name in the
     named pragmas is resolved using the standard C++ name resolution
     rules, for example:</p>

  <pre class="c++">
namespace db
{
  class person
  {
    ...
  private:
    unsigned long id_;
    ...
  };
}

namespace db
{
  #pragma db object(person)  // Resolves db::person.
}

#pragma db member(db::person::id_) id
  </pre>

  <p>As another example, the following code fragment shows how to use the
     named value type pragma to map a C++ type to a native database type:</p>

  <pre class="c++">
#pragma db value(bool) type("INT")

#pragma db object
class person
{
  ...
private:
  bool married_; // Mapped to INT NOT NULL database type.
  ...
};
  </pre>

  <p>If we would like to factor the ODB pragmas into a separate file,
     we can include this file into the original header file (the one
     that defines the persistent types) using the <code>#include</code>
     directive, for example:</p>

  <pre class="c++">
// person.hxx

class person
{
  ...
};

#ifdef ODB_COMPILER
#  include "person-pragmas.hxx"
#endif
  </pre>

  <p>Alternatively, instead of using the <code>#include</code> directive,
     we can use the <code>--odb-epilogue</code> option to make the pragmas
     known to the ODB compiler when compiling the original header file,
     for example:</p>

  <pre class="terminal">
--odb-epilogue  '#include "person-pragmas.hxx"'
  </pre>

  <p>The following three sections cover the specifiers applicable
     to the <code>object</code>, <code>value</code>, and <code>member</code>
     qualifiers.</p>

  <p>The C++ header file that defines our persistent classes and
     normally contains one or more ODB pragmas is compiled by both
     the ODB compiler to generate the database support code and
     the C++ compiler to build the application. Some C++ compilers
     issue warnings about pragmas that they do not recognize. There
     are several ways to deal with this problem which are covered
     at the end of this chapter in <a href="#11.5">Section 11.5,
     "C++ Compiler Warnings"</a>.</p>

  <h2><a name="11.1">11.1 Object Type Pragmas</a></h2>

  <p>A pragma with the <code>object</code> qualifier declares a C++ class
     as a persistent object type. The qualifier can be optionally followed,
     in any order, by one or more specifiers summarized in the table below:</p>

  <!-- border="1" is necessary for html2ps -->
  <table class="specifiers" border="1">
    <tr>
      <th>Specifier</th>
      <th>Summary</th>
      <th>Section</th>
    </tr>

    <tr>
      <td><code>table</code></td>
      <td>table name for a persistent class</td>
      <td><a href="#11.1.1">11.1.1</a></td>
    </tr>

    <tr>
      <td><code>pointer</code></td>
      <td>pointer type for a persistent class</td>
      <td><a href="#11.1.2">11.1.2</a></td>
    </tr>

    <tr>
      <td><code>abstract</code></td>
      <td>persistent class is abstract</td>
      <td><a href="#11.1.3">11.1.3</a></td>
    </tr>

    <tr>
      <td><code>readonly</code></td>
      <td>persistent class is read-only</td>
      <td><a href="#11.1.4">11.1.4</a></td>
    </tr>

    <tr>
      <td><code>id</code></td>
      <td>persistent class has no object id</td>
      <td><a href="#11.1.5">11.1.5</a></td>
    </tr>

    <tr>
      <td><code>callback</code></td>
      <td>database operations callback</td>
      <td><a href="#11.1.6">11.1.6</a></td>
    </tr>

  </table>

  <h3><a name="11.1.1">11.1.1 <code>table</code></a></h3>

  <p>The <code>table</code> specifier specifies the table name that should
     be used to store objects of a class in a relational database. For
     example:</p>

  <pre class="c++">
#pragma db object table("people")
class person
{
  ...
};
  </pre>

  <p>If the table name is not specified, the class name is used as the
     table name.</p>

  <h3><a name="11.1.2">11.1.2 <code>pointer</code></a></h3>

  <p>The <code>pointer</code> specifier specifies the object pointer type
     for a persistent class. The object pointer type is used to return,
     pass, and cache dynamically allocated instances of a persistent
     class. For example:</p>

  <pre class="c++">
#pragma db object pointer(std::tr1::shared_ptr&lt;person>)
class person
{
  ...
};
  </pre>

  <p>There are several ways to specify an object pointer with the
     <code>pointer</code> specifier. We can use a complete pointer
     type as shown in the example above. Alternatively, we can
     specify only the template name of a smart pointer in which
     case the ODB compiler will automatically append the class
     name as a template argument. The following example is therefore
     equivalent to the one above:</p>

  <pre class="c++">
#pragma db object pointer(std::tr1::shared_ptr)
class person
{
  ...
};
  </pre>

  <p>If you would like to use the raw pointer as an object pointer,
     you can use <code>*</code> as a shortcut:</p>

  <pre class="c++">
#pragma db object pointer(*) // Same as pointer(person*)
class person
{
  ...
};
  </pre>

  <p>If a pointer type is not explicitly specified, the default
     pointer, specified with the <code>--default-pointer</code>
     ODB compiler option, is used. If this option is not specified
     either, then the raw pointer is used by default.</p>

  <p>For a more detailed discussion of object pointers, refer to
     <a href="#3.2">Section 3.2, "Object and View Pointers"</a>.</p>

  <h3><a name="11.1.3">11.1.3 <code>abstract</code></a></h3>

  <p>The <code>abstract</code> specifier specifies that a persistent class
     is abstract. An instance of an abstract class cannot be stored in
     the database and is normally used as a base for other persistent
     classes. For example:</p>

  <pre class="c++">
#pragma db object abstract
class person
{
  ...
};

#pragma db object
class employee: public person
{
  ...
};

#pragma db object
class contractor: public person
{
  ...
};
  </pre>

  <p>Persistent classes with pure virtual functions are automatically
     treated as abstract by the ODB compiler. For a more detailed
     discussion of persistent class inheritance, refer to
     <a href="#8">Chapter 8, "Inheritance"</a>.</p>

  <h3><a name="11.1.4">11.1.4 <code>readonly</code></a></h3>

  <p>The <code>readonly</code> specifier specifies that the persistent class
     is read-only. The database state of read-only objects cannot be
     updated. In particular, this means that you cannot call the
     <code>database::update()</code> function (<a href="#3.9">Section 3.9,
     "Updating Persistent Objects"</a>) for such objects. For example:</p>

  <pre class="c++">
#pragma db object readonly
class person
{
  ...
};
  </pre>

  <p>Read-only and read-write objects can derive from each other without
     any restrictions. When a read-only object derives from a read-write
     object, the resulting whole object is read-only, including the part
     corresponding to the read-write base. On the other hand, when a
     read-write object derives from a read-only object, all the data
     members that correspond to the read-only base are treated as
     read-only while the rest is treated as read-write.</p>

  <p>Note that it is also possible to declare individual data members
    (<a href="#11.4.10">Section 11.4.10, "<code>readonly</code>"</a>)
     as well as composite value types (<a href="#11.3.6">Section 11.3.6,
     "<code>readonly</code>"</a>) as read-only.</p>

  <h3><a name="11.1.5">11.1.5 <code>id</code></a></h3>

  <p>The <code>id</code> specifier specifies that the persistent class
     has no object id. It should be followed by opening and closing
     parenthesis. For example:</p>

  <pre class="c++">
#pragma db object id()
class person
{
  ...
};
  </pre>

  <p>A persistent class without an object id has limited functionality.
     Such a class cannot be loaded with the <code>database::load()</code>
     or <code>database::find()</code> functions (<a href="#3.8">Section 3.8,
     "Loading Persistent Objects"</a>), updated with the
     <code>database::update()</code> function (<a href="#3.9">Section 3.9,
     "Updating Persistent Objects"</a>), or deleted with the
     <code>database::erase()</code> function (<a href="#3.10">Section 3.10,
     "Deleting Persistent Objects"</a>). To load and delete
     objects without ids you can use the <code>database::query()</code>
     (<a href="#4">Chapter 4, "Querying the Database"</a>) and
     <code>database::erase_query()</code> (<a href="#3.10">Section 3.10,
     "Deleting Persistent Objects"</a>) functions, respectively.
     There is no way to update such objects except by using native SQL
     statements (<a href="#3.11">Section 3.11, "Executing Native SQL
     Statements"</a>).</p>

  <p>Furthermore, persistent classes without object ids cannot have container
     data members nor can they be used in object relationships. Such objects
     are not entered into the session object cache
     (<a href="#10.1">Section 10.1, "Object Cache"</a>) either.</p>

  <p>To declare a persistent class with an object id, use the data member
     <code>id</code> specifier (<a href="#11.4.1">Section 11.4.1,
     "<code>id</code>"</a>).</p>

  <h3><a name="11.1.6">11.1.6 <code>callback</code></a></h3>

  <p>The <code>callback</code> specifier specifies the persist class
     member function that should be called before and after a
     database operation is performed on an object of this class.
     For example:</p>

  <pre class="c++">
#include &lt;odb/callback.hxx>

#pragma db object callback(init)
class person
{
  ...

  void
  init (odb::callback_event, odb::database&amp;);
};
 </pre>

  <p>The callback function has the following signature and can be
     overloaded for constant objects:</p>

  <pre class="c++">
void
name (odb::callback_event, odb::database&amp;);

void
name (odb::callback_event, odb::database&amp;) const;
  </pre>

  <p>The first argument to the callback function is the event that
     triggered this call. The <code>odb::callback_event</code>
     enum-like type is defined in the <code>&lt;odb/callback.hxx></code>
     header file and has the following interface:</p>

  <pre class="c++">
namespace odb
{
  struct callback_event
  {
    enum value
    {
      pre_persist,
      post_persist,
      pre_load,
      post_load,
      pre_update,
      post_update,
      pre_erase,
      post_erase
    };

    callback_event (value v);
    operator value () const;
  };
}
  </pre>

  <p>The second argument to the callback function is the database
     on which the operation is about to be performed or has just
     been performed.</p>

  <p>If only the non-<code>const</code> version of the callback function
     is provided, then only database operations that are performed on
     unrestricted objects will trigger callback calls. If only the
     <code>const</code> version is provided, then the database
     operations on both constant and unrestricted objects will trigger
     callback calls but the object will always be passed as constant.
     Finally, if both versions are provided, then the <code>const</code>
     overload will be called for constant objects and the non-<code>const</code>
     overload for unrestricted objects. These rules are modeled after
     the standard C++ overload resolution rules. A callback function can
     be inline or virtual.</p>

  <p>A database operations callback can be used to implement object-specific
     pre and post initializations, registrations, and cleanups. As an example,
     the following code fragment outlines an implementation of a
     <code>person</code> class that maintains the transient <code>age</code>
     data member in addition to the persistent date of birth. A callback
     is used to calculate the value of the former from the latter every
     time a <code>person</code> object is loaded from the database.</p>

  <pre class="c++">
#include &lt;odb/core.hxx>
#include &lt;odb/callback.hxx>

#pragma db object callback(init)
class person
{
  ...

private:
  friend class odb::access;

  date born_;

  #pragma db transient
  unsigned short age_;

  void
  init (odb::callback_event e, odb::database&amp;)
  {
    switch (e)
    {
    case odb::callback_event::post_load:
    {
      // Calculate age from the date of birth.
      ...
      break;
    }
    default:
      break;
    }
  }
};
 </pre>

  <h2><a name="11.2">11.2 View Type Pragmas</a></h2>

  <p>A pragma with the <code>view</code> qualifier declares a C++ class
     as a view type. The qualifier can be optionally followed,
     in any order, by one or more specifiers summarized in the
     table below:</p>

  <!-- border="1" is necessary for html2ps -->
  <table class="specifiers" border="1">
    <tr>
      <th>Specifier</th>
      <th>Summary</th>
      <th>Section</th>
    </tr>

    <tr>
      <td><code>object</code></td>
      <td>object associated with a view</td>
      <td><a href="#11.2.1">11.2.1</a></td>
    </tr>

    <tr>
      <td><code>table</code></td>
      <td>table associated with a view</td>
      <td><a href="#11.2.2">11.2.2</a></td>
    </tr>

    <tr>
      <td><code>query</code></td>
      <td>view query condition</td>
      <td><a href="#11.2.3">11.2.3</a></td>
    </tr>

    <tr>
      <td><code>pointer</code></td>
      <td>pointer type for a view</td>
      <td><a href="#11.2.4">11.2.4</a></td>
    </tr>

    <tr>
      <td><code>callback</code></td>
      <td>database operations callback</td>
      <td><a href="#11.2.5">11.2.5</a></td>
    </tr>

  </table>

  <p>For more information on view types refer to <a href="#9"> Chapter 9,
     "Views"</a>.</p>

  <h3><a name="11.2.1">11.2.1 <code>object</code></a></h3>

  <p>The <code>object</code> specifier specifies a persistent class
     that should be associated with a view. For more information
     on object associations refer to <a href="#9.1">Section 9.1, "Object
     Views"</a>.</p>

  <h3><a name="11.2.2">11.2.2 <code>table</code></a></h3>

  <p>The <code>table</code> specifier specifies a database table
     that should be associated with a view. For more information
     on table associations refer to <a href="#9.2">Section 9.2, "Table
     Views"</a>.</p>

  <h3><a name="11.2.3">11.2.3 <code>query</code></a></h3>

  <p>The <code>query</code> specifier specifies a query condition
     for an object or table view or a native SQL query for a native
     view. An empty <code>query</code> specifier indicates that a
     native SQL query is provided at runtime. For more information
     on query conditions refer to <a href="#9.4">Section 9.4, "View
     Query Conditions"</a>. For more information on native SQL queries,
     refer to <a href="#9.5">Section 9.5, "Native Views"</a>.</p>

  <h3><a name="11.2.4">11.2.4 <code>pointer</code></a></h3>

  <p>The <code>pointer</code> specifier specifies the view pointer type
     for a view class. Similar to objects, the view pointer type is used
     to return dynamically allocated instances of a view class. The
     semantics of the <code>pointer</code> specifier for a view are the
     same as those of the <code>pointer</code> specifier for an object
     (<a href="#11.1.2">Section 11.1.2, "<code>pointer</code>"</a>).</p>

  <h3><a name="11.2.5">11.2.5 <code>callback</code></a></h3>

  <p>The <code>callback</code> specifier specifies the view class
     member function that should be called before and after an
     instance of this view class is created as part of the query
     result iteration. The semantics of the <code>callback</code>
     specifier for a view are similar to those of the
     <code>callback</code> specifier for an object
     (<a href="#11.1.6">Section 11.1.6, "<code>callback</code>"</a>)
     except that the only events that can trigger a callback
     call in the case of a view are <code>pre_load</code> and
     <code>post_load</code>.</p>


  <h2><a name="11.3">11.3 Value Type Pragmas</a></h2>

  <p>A pragma with the <code>value</code> qualifier describes a value
     type. It can be optionally followed, in any order, by one or more
     specifiers summarized in the table below:</p>

  <!-- border="1" is necessary for html2ps -->
  <table class="specifiers" border="1">
    <tr>
      <th>Specifier</th>
      <th>Summary</th>
      <th>Section</th>
    </tr>

    <tr>
      <td><code>type</code></td>
      <td>database type for a value type</td>
      <td><a href="#11.3.1">11.3.1</a></td>
    </tr>

    <tr>
      <td><code>id_type</code></td>
      <td>database type for a value type when used as an object id</td>
      <td><a href="#11.3.2">11.3.2</a></td>
    </tr>

    <tr>
      <td><code>null</code>/<code>not_null</code></td>
      <td>type can/cannot be <code>NULL</code></td>
      <td><a href="#11.3.3">11.3.3</a></td>
    </tr>

    <tr>
      <td><code>default</code></td>
      <td>default value for a value type</td>
      <td><a href="#11.3.4">11.3.4</a></td>
    </tr>

    <tr>
      <td><code>options</code></td>
      <td>database options for a value type</td>
      <td><a href="#11.3.5">11.3.5</a></td>
    </tr>

    <tr>
      <td><code>readonly</code></td>
      <td>composite value type is read-only</td>
      <td><a href="#11.3.6">11.3.6</a></td>
    </tr>

    <tr>
      <td><code>unordered</code></td>
      <td>ordered container should be stored unordered</td>
      <td><a href="#11.3.7">11.3.7</a></td>
    </tr>

    <tr>
      <td><code>index_type</code></td>
      <td>database type for a container's index type</td>
      <td><a href="#11.3.8">11.3.8</a></td>
    </tr>

    <tr>
      <td><code>key_type</code></td>
      <td>database type for a container's key type</td>
      <td><a href="#11.3.9">11.3.9</a></td>
    </tr>

    <tr>
      <td><code>value_type</code></td>
      <td>database type for a container's value type</td>
      <td><a href="#11.3.10">11.3.10</a></td>
    </tr>

    <tr>
      <td><code>value_null</code>/<code>value_not_null</code></td>
      <td>container's value can/cannot be <code>NULL</code></td>
      <td><a href="#11.3.11">11.3.11</a></td>
    </tr>

    <tr>
      <td><code>id_options</code></td>
      <td>database options for a container's id column</td>
      <td><a href="#11.3.12">11.3.12</a></td>
    </tr>

    <tr>
      <td><code>index_options</code></td>
      <td>database options for a container's index column</td>
      <td><a href="#11.3.13">11.3.13</a></td>
    </tr>

    <tr>
      <td><code>key_options</code></td>
      <td>database options for a container's key column</td>
      <td><a href="#11.3.14">11.3.14</a></td>
    </tr>

    <tr>
      <td><code>value_options</code></td>
      <td>database options for a container's value column</td>
      <td><a href="#11.3.15">11.3.15</a></td>
    </tr>

    <tr>
      <td><code>id_column</code></td>
      <td>column name for a container's object id</td>
      <td><a href="#11.3.16">11.3.16</a></td>
    </tr>

    <tr>
      <td><code>index_column</code></td>
      <td>column name for a container's index</td>
      <td><a href="#11.3.17">11.3.17</a></td>
    </tr>

    <tr>
      <td><code>key_column</code></td>
      <td>column name for a container's key</td>
      <td><a href="#11.3.18">11.3.18</a></td>
    </tr>

    <tr>
      <td><code>value_column</code></td>
      <td>column name for a container's value</td>
      <td><a href="#11.3.19">11.3.19</a></td>
    </tr>

  </table>

  <p>Many of the value type specifiers have corresponding member type
     specifiers with the same names (<a href="#11.4">Section 11.4,
     "Data Member Pragmas"</a>). The behavior of such specifiers
     for members is similar to that for value types. The only difference
     is the scope. A particular value type specifier applies to all the
     members of this value type that don't have a pre-member version
     of the specifier, while the member specifier always applies only
     to a single member. Also, with a few exceptions, member specifiers
     take precedence over and override parameters specified with value
     specifiers.</p>

  <h3><a name="11.3.1">11.3.1 <code>type</code></a></h3>

  <p>The <code>type</code> specifier specifies the native database type
     that should be used for data members of this type. For example:</p>

  <pre class="c++">
#pragma db value(bool) type("INT")

#pragma db object
class person
{
  ...

  bool married_; // Mapped to INT NOT NULL database type.
};
  </pre>

  <p>The ODB compiler provides the default mapping between common C++
     types, such as <code>bool</code>, <code>int</code>, and
     <code>std::string</code> and the database types for each supported
     database system. For more information on the default mapping,
     refer to <a href="#II">Part II, "Database Systems"</a>. The
     <code>null</code> and <code>not_null</code> (<a href="#11.3.3">Section
     11.3.3, "<code>null</code>/<code>not_null</code>"</a>) specifiers
     can be used to control the NULL semantics of a type.</p>

  <p>In the above example we changed the mapping for the <code>bool</code>
     type which is now mapped to the <code>INT</code> database type. In
     this case, the <code>value</code> pragma is all that is necessary
     since the ODB compiler will be able to figure out how to store
     a boolean value as an integer in the database. However, there
     could be situations where the ODB compiler will not know how to
     handle the conversion between the C++ and database representations
     of a value. Consider, as an example, a situation where the
     boolean value is stored in the database as a string:</p>

  <pre class="c++">
#pragma db value(bool) type("VARCHAR(5)")
  </pre>

  <p>The possible database values for the C++ <code>true</code> value could
     be <code>"true"</code>, or <code>"TRUE"</code>, or <code>"True"</code>.
     Or, maybe, all of the above could be valid. The ODB compiler has no way
     of knowing how your application wants to convert <code>bool</code>
     to a string and back. To support such custom value type mappings,
     ODB allows you to provide your own database conversion functions
     by specializing the <code>value_traits</code> class template. The
     <code>mapping</code> example in the <code>odb-examples</code>
     package shows how to do this for all the supported database systems.</p>

  <h3><a name="11.3.2">11.3.2 <code>id_type</code></a></h3>

  <p>The <code>id_type</code> specifier specifies the native database type
     that should be used for data members of this type that are designated as
     object identifiers (<a href="#11.4.1">Section 11.4.1,
     "<code>id</code>"</a>). In combination with the <code>type</code>
     specifier (<a href="#11.3.1">Section 11.3.1, "<code>type</code>"</a>)
     <code>id_type</code> allows you to map a C++ type differently depending
     on whether it is used in an ordinary member or an object id. For
     example:</p>

  <pre class="c++">
#pragma db value(std::string) type("TEXT") id_type("VARCHAR(128)")

#pragma db object
class person
{
  ...

  #pragma db id
  std::string email_; // Mapped to VARCHAR(128) NOT NULL.

  std::string name_;  // Mapped to TEXT NOT NULL.
};
  </pre>

  <p>Note that there is no corresponding member type specifier for
     <code>id_type</code> since the desired result can be achieved
     with just the <code>type</code> specifier, for example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db id type("VARCHAR(128)")
  std::string email_;
};
  </pre>

  <h3><a name="11.3.3">11.3.3 <code>null</code>/<code>not_null</code></a></h3>

  <p>The <code>null</code> and <code>not_null</code> specifiers specify that
     a value type or object pointer can or cannot be <code>NULL</code>,
     respectively. By default, value types are assumed not to allow
     <code>NULL</code> values while object pointers are assumed to
     allow <code>NULL</code> values. Data members of types that allow
     <code>NULL</code> values are mapped in a relational database to
     columns that allow <code>NULL</code> values. For example:</p>

  <pre class="c++">
using std::tr1::shared_ptr;

typedef shared_ptr&lt;std::string> string_ptr;
#pragma db value(string_ptr) type("TEXT") null

#pragma db object
class person
{
  ...

  string_ptr name_; // Mapped to TEXT NULL.
};

typedef shared_ptr&lt;person> person_ptr;
#pragma db value(person_ptr) not_null
  </pre>

  <p>The <code>NULL</code> semantics can also be specified on the
     per-member basis (<a href="#11.4.4">Section 11.4.4,
     "<code>null</code>/<code>not_null</code>"</a>). If both a type and
     a member have <code>null</code>/<code>not_null</code> specifiers,
     then the member specifier takes precedence. If a member specifier
     relaxes the <code>NULL</code> semantics (that is, if a member has
     the <code>null</code> specifier and the type has the explicit
     <code>not_null</code> specifier), then a warning is issued.</p>

  <p>It is also possible to override a previously specified
     <code>null</code>/<code>not_null</code> specifier. This is
     primarily useful if a third-party type, for example,
     one provided by a profile library (<a href="#III">Part III,
     "Profiles"</a>), allows <code>NULL</code> values but in your
     object model data members of this type should never be
     <code>NULL</code>. In this case you can use the <code>not_null</code>
     specifier to disable <code>NULL</code> values for this type for the
     entire translation unit. For example:</p>

  <pre class="c++">
// By default, null_string allows NULL values.
//
#include &lt;null-string.hxx>

// Disable NULL values for all the null_string data members.
//
#pragma db value(null_string) not_null
  </pre>

  <p>For a more detailed discussion of the <code>NULL</code> semantics
     for values, refer to <a href="#7.3">Section 7.3, "Pointers and
     <code>NULL</code> Value Semantics"</a>. For a more detailed
     discussion of the <code>NULL</code> semantics for object pointers,
     refer to <a href="#6">Chapter 6, "Relationships"</a>.</p>

  <h3><a name="11.3.4">11.3.4 <code>default</code></a></h3>

  <p>The <code>default</code> specifier specifies the database default value
     that should be used for data members of this type. For example:</p>

  <pre class="c++">
#pragma db value(std::string) default("")

#pragma db object
class person
{
  ...

  std::string name_; // Mapped to TEXT NOT NULL DEFAULT ''.
};
  </pre>

  <p>The semantics of the <code>default</code> specifier for a value type
     are similar to those of the <code>default</code> specifier for a
     data member (<a href="#11.4.5">Section 11.4.5,
     "<code>default</code>"</a>).</p>

  <h3><a name="11.3.5">11.3.5 <code>options</code></a></h3>

  <p>The <code>options</code> specifier specifies additional column
     definition options that should be used for data members of this
     type. For example:</p>

  <pre class="c++">
#pragma db value(std::string) options("COLLATE binary")

#pragma db object
class person
{
  ...

  std::string name_; // Mapped to TEXT NOT NULL COLLATE binary.
};
  </pre>

  <p>The semantics of the <code>options</code> specifier for a value type
     are similar to those of the <code>options</code> specifier for a
     data member (<a href="#11.4.6">Section 11.4.6,
     "<code>options</code>"</a>).</p>

  <h3><a name="11.3.6">11.3.6 <code>readonly</code></a></h3>

  <p>The <code>readonly</code> specifier specifies that the composite
     value type is read-only. Changes to data members of a read-only
     composite value type are ignored when updating the database
     state of an object (<a href="#3.9">Section 3.9, "Updating Persistent
     Objects"</a>) containing such a value type. Note that this specifier
     is only valid for composite value types. For example:</p>

  <pre class="c++">
#pragma db value readonly
class person_name
{
  ...
};
  </pre>

  <p>Read-only and read-write composite values can derive from each other
     without any restrictions. When a read-only value derives from a
     read-write value, the resulting whole value is read-only, including
     the part corresponding to the read-write base. On the other hand, when a
     read-write value derives from a read-only value, all the data
     members that correspond to the read-only base are treated as
     read-only while the rest is treated as read-write.</p>

  <p>Note that it is also possible to declare individual data members
     (<a href="#11.4.10">Section 11.4.10, "<code>readonly</code>"</a>)
     as well as whole objects (<a href="#11.1.4">Section 11.1.4,
     "<code>readonly</code>"</a>) as read-only.</p>

  <h3><a name="11.3.7">11.3.7 <code>unordered</code></a></h3>

  <p>The <code>unordered</code> specifier specifies that the ordered
     container should be stored unordered in the database. The database
     table for such a container will not contain the index column
     and the order in which elements are retrieved from the database may
     not be the same as the order in which they were stored. For example:</p>

  <pre class="c++">
typedef std::vector&lt;std::string> names;
#pragma db value(names) unordered
  </pre>

  <p>For a more detailed discussion of ordered containers and their
     storage in the database, refer to <a href="#5.1">Section 5.1,
     "Ordered Containers"</a>.</p>

  <h3><a name="11.3.8">11.3.8 <code>index_type</code></a></h3>

  <p>The <code>index_type</code> specifier specifies the native
     database type that should be used for an ordered container's
     index column. The semantics of <code>index_type</code>
     are similar to those of the <code>type</code> specifier
     (<a href="#11.3.1">Section 11.3.1, "<code>type</code>"</a>). The native
     database type is expected to be an integer type. For example:</p>

  <pre class="c++">
typedef std::vector&lt;std::string> names;
#pragma db value(names) index_type("SMALLINT UNSIGNED")
  </pre>

  <h3><a name="11.3.9">11.3.9 <code>key_type</code></a></h3>

  <p>The <code>key_type</code> specifier specifies the native
     database type that should be used for a map container's
     key column. The semantics of <code>key_type</code>
     are similar to those of the <code>type</code> specifier
     (<a href="#11.3.1">Section 11.3.1, "<code>type</code>"</a>). For
     example:</p>

  <pre class="c++">
typedef std::map&lt;unsigned short, float> age_weight_map;
#pragma db value(age_weight_map) key_type("INT UNSIGNED")
  </pre>

  <h3><a name="11.3.10">11.3.10 <code>value_type</code></a></h3>

  <p>The <code>value_type</code> specifier specifies the native
     database type that should be used for a container's
     value column. The semantics of <code>value_type</code>
     are similar to those of the <code>type</code> specifier
     (<a href="#11.3.1">Section 11.3.1, "<code>type</code>"</a>). For
     example:</p>

  <pre class="c++">
typedef std::vector&lt;std::string> names;
#pragma db value(names) value_type("VARCHAR(255)")
  </pre>

  <p>The <code>value_null</code> and <code>value_not_null</code>
     (<a href="#11.3.11">Section 11.3.11,
     "<code>value_null</code>/<code>value_not_null</code>"</a>) specifiers
     can be used to control the NULL semantics of a value column.</p>

  <h3><a name="11.3.11">11.3.11 <code>value_null</code>/<code>value_not_null</code></a></h3>

  <p>The <code>value_null</code> and <code>value_not_null</code> specifiers
     specify that a container type's element value can or cannot be
     <code>NULL</code>, respectively. The semantics of <code>value_null</code>
     and <code>value_not_null</code> are similar to those of the
     <code>null</code> and <code>not_null</code> specifiers
     (<a href="#11.3.3">Section 11.3.3, "<code>null</code>/<code>not_null</code>"</a>).
     For example:</p>

  <pre class="c++">
using std::tr1::shared_ptr;

#pragma db object
class account
{
  ...
};

typedef std::vector&lt;shared_ptr&lt;account> > accounts;
#pragma db value(accounts) value_not_null
  </pre>

  <p>For set and multiset containers (<a href="#5.2">Section 5.2, "Set and
     Multiset Containers"</a>) the element value is automatically treated
     as not allowing a <code>NULL</code> value.</p>


  <h3><a name="11.3.12">11.3.12 <code>id_options</code></a></h3>

  <p>The <code>id_options</code> specifier specifies additional
     column definition options that should be used for a container's
     id column. For example:</p>

  <pre class="c++">
typedef std::vector&lt;std::string> nicknames;
#pragma db value(nicknames) id_options("COLLATE binary")
  </pre>

  <p>The semantics of the <code>id_options</code> specifier for a container
     type are similar to those of the <code>id_options</code> specifier for
     a container data member (<a href="#11.4.18">Section 11.4.18,
     "<code>id_options</code>"</a>).</p>


  <h3><a name="11.3.13">11.3.13 <code>index_options</code></a></h3>

  <p>The <code>index_options</code> specifier specifies additional
     column definition options that should be used for a container's
     index column. For example:</p>

  <pre class="c++">
typedef std::vector&lt;std::string> nicknames;
#pragma db value(nicknames) index_options("ZEROFILL")
  </pre>

  <p>The semantics of the <code>index_options</code> specifier for a container
     type are similar to those of the <code>index_options</code> specifier for
     a container data member (<a href="#11.4.19">Section 11.4.19,
     "<code>index_options</code>"</a>).</p>


  <h3><a name="11.3.14">11.3.14 <code>key_options</code></a></h3>

  <p>The <code>key_options</code> specifier specifies additional
     column definition options that should be used for a container's
     key column. For example:</p>

  <pre class="c++">
typedef std::map&lt;std::string, std::string> properties;
#pragma db value(properties) key_options("COLLATE binary")
  </pre>

  <p>The semantics of the <code>key_options</code> specifier for a container
     type are similar to those of the <code>key_options</code> specifier for
     a container data member (<a href="#11.4.20">Section 11.4.20,
     "<code>key_options</code>"</a>).</p>


  <h3><a name="11.3.15">11.3.15 <code>value_options</code></a></h3>

  <p>The <code>value_options</code> specifier specifies additional
     column definition options that should be used for a container's
     value column. For example:</p>

  <pre class="c++">
typedef std::set&lt;std::string> nicknames;
#pragma db value(nicknames) value_options("COLLATE binary")
  </pre>

  <p>The semantics of the <code>value_options</code> specifier for a container
     type are similar to those of the <code>value_options</code> specifier for
     a container data member (<a href="#11.4.21">Section 11.4.21,
     "<code>value_options</code>"</a>).</p>


  <h3><a name="11.3.16">11.3.16 <code>id_column</code></a></h3>

  <p>The <code>id_column</code> specifier specifies the column
     name that should be used to store the object id in a
     container's table. For example:</p>

  <pre class="c++">
typedef std::vector&lt;std::string> names;
#pragma db value(names) id_column("id")
  </pre>

  <p>If the column name is not specified, then <code>object_id</code>
     is used by default.</p>

  <h3><a name="11.3.17">11.3.17 <code>index_column</code></a></h3>

  <p>The <code>index_column</code> specifier specifies the column
     name that should be used to store the element index in an
     ordered container's table. For example:</p>

  <pre class="c++">
typedef std::vector&lt;std::string> names;
#pragma db value(names) index_column("name_number")
  </pre>

  <p>If the column name is not specified, then <code>index</code>
     is used by default.</p>

  <h3><a name="11.3.18">11.3.18 <code>key_column</code></a></h3>

  <p>The <code>key_column</code> specifier specifies the column
     name that should be used to store the key in a map
     container's table. For example:</p>

  <pre class="c++">
typedef std::map&lt;unsigned short, float> age_weight_map;
#pragma db value(age_weight_map) key_column("age")
  </pre>

  <p>If the column name is not specified, then <code>key</code>
     is used by default.</p>

  <h3><a name="11.3.19">11.3.19 <code>value_column</code></a></h3>

  <p>The <code>value_column</code> specifier specifies the column
     name that should be used to store the element value in a
     container's table. For example:</p>

  <pre class="c++">
typedef std::map&lt;unsigned short, float> age_weight_map;
#pragma db value(age_weight_map) value_column("weight")
  </pre>

  <p>If the column name is not specified, then <code>value</code>
     is used by default.</p>

  <!-- Data Member Pragmas -->


  <h2><a name="11.4">11.4 Data Member Pragmas</a></h2>

  <p>A pragma with the <code>member</code> qualifier or a positioned
     pragma without a qualifier describes a data member. It can
     be optionally followed, in any order, by one or more specifiers
     summarized in the table below:</p>

  <!-- border="1" is necessary for html2ps -->
  <table class="specifiers" border="1">
    <tr>
      <th>Specifier</th>
      <th>Summary</th>
      <th>Section</th>
    </tr>

    <tr>
      <td><code>id</code></td>
      <td>member is an object id</td>
      <td><a href="#11.4.1">11.4.1</a></td>
    </tr>

    <tr>
      <td><code>auto</code></td>
      <td>id is assigned by the database</td>
      <td><a href="#11.4.2">11.4.2</a></td>
    </tr>

    <tr>
      <td><code>type</code></td>
      <td>database type for a member</td>
      <td><a href="#11.4.3">11.4.3</a></td>
    </tr>

    <tr>
      <td><code>null</code>/<code>not_null</code></td>
      <td>member can/cannot be <code>NULL</code></td>
      <td><a href="#11.4.4">11.4.4</a></td>
    </tr>

    <tr>
      <td><code>default</code></td>
      <td>default value for a member</td>
      <td><a href="#11.4.5">11.4.5</a></td>
    </tr>

    <tr>
      <td><code>options</code></td>
      <td>database options for a member</td>
      <td><a href="#11.4.6">11.4.6</a></td>
    </tr>

    <tr>
      <td><code>column</code></td>
      <td>column name for a member of an object or composite value</td>
      <td><a href="#11.4.7">11.4.7</a></td>
    </tr>

    <tr>
      <td><code>column</code></td>
      <td>column name for a member of a view</td>
      <td><a href="#11.4.8">11.4.8</a></td>
    </tr>

    <tr>
      <td><code>transient</code></td>
      <td>member is not stored in the database</td>
      <td><a href="#11.4.9">11.4.9</a></td>
    </tr>

    <tr>
      <td><code>readonly</code></td>
      <td>member is read-only</td>
      <td><a href="#11.4.10">11.4.10</a></td>
    </tr>

    <tr>
      <td><code>inverse</code></td>
      <td>member is an inverse side of a bidirectional relationship</td>
      <td><a href="#11.4.11">11.4.11</a></td>
    </tr>

    <tr>
      <td><code>unordered</code></td>
      <td>ordered container should be stored unordered</td>
      <td><a href="#11.4.12">11.4.12</a></td>
    </tr>

    <tr>
      <td><code>table</code></td>
      <td>table name for a container</td>
      <td><a href="#11.4.13">11.4.13</a></td>
    </tr>

    <tr>
      <td><code>index_type</code></td>
      <td>database type for a container's index type</td>
      <td><a href="#11.4.14">11.4.14</a></td>
    </tr>

    <tr>
      <td><code>key_type</code></td>
      <td>database type for a container's key type</td>
      <td><a href="#11.4.15">11.4.15</a></td>
    </tr>

    <tr>
      <td><code>value_type</code></td>
      <td>database type for a container's value type</td>
      <td><a href="#11.4.16">11.4.16</a></td>
    </tr>

    <tr>
      <td><code>value_null</code>/<code>value_not_null</code></td>
      <td>container's value can/cannot be <code>NULL</code></td>
      <td><a href="#11.4.17">11.4.17</a></td>
    </tr>

    <tr>
      <td><code>id_options</code></td>
      <td>database options for a container's id column</td>
      <td><a href="#11.4.18">11.4.18</a></td>
    </tr>

    <tr>
      <td><code>index_options</code></td>
      <td>database options for a container's index column</td>
      <td><a href="#11.4.19">11.4.19</a></td>
    </tr>

    <tr>
      <td><code>key_options</code></td>
      <td>database options for a container's key column</td>
      <td><a href="#11.4.20">11.4.20</a></td>
    </tr>

    <tr>
      <td><code>value_options</code></td>
      <td>database options for a container's value column</td>
      <td><a href="#11.4.21">11.4.21</a></td>
    </tr>

    <tr>
      <td><code>id_column</code></td>
      <td>column name for a container's object id</td>
      <td><a href="#11.4.22">11.4.22</a></td>
    </tr>

    <tr>
      <td><code>index_column</code></td>
      <td>column name for a container's index</td>
      <td><a href="#11.4.23">11.4.23</a></td>
    </tr>

    <tr>
      <td><code>key_column</code></td>
      <td>column name for a container's key</td>
      <td><a href="#11.4.24">11.4.24</a></td>
    </tr>

    <tr>
      <td><code>value_column</code></td>
      <td>column name for a container's value</td>
      <td><a href="#11.4.25">11.4.25</a></td>
    </tr>

  </table>

  <p>Many of the member specifiers have corresponding value type
     specifiers with the same names (<a href="#11.3">Section 11.3,
     "Value Type Pragmas"</a>). The behavior of such specifiers
     for members is similar to that for value types. The only difference
     is the scope. A particular value type specifier applies to all the
     members of this value type that don't have a pre-member version
     of the specifier, while the member specifier always applies only
     to a single member. Also, with a few exceptions, member specifiers
     take precedence over and override parameters specified with value
     specifiers.</p>

  <h3><a name="11.4.1">11.4.1 <code>id</code></a></h3>

  <p>The <code>id</code> specifier specifies that a data member contains
     the object id. In a relational database, an identifier member is
     mapped to a primary key. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db id
  std::string email_;
};
  </pre>

  <p>Normally, every persistent class has a data member designated as an
     object's identifier. However, it is possible to declare a
     persistent class without an id using the object <code>id</code>
     specifier (<a href="#11.1.5">Section 11.1.5, "<code>id</code>"</a>).</p>

  <p>Note also that the <code>id</code> specifier cannot be used for data
     members of composite value types or views.</p>

  <h3><a name="11.4.2">11.4.2 <code>auto</code></a></h3>

  <p>The <code>auto</code> specifier specifies that the object's identifier
     is automatically assigned by the database. Only a member that was
     designated as an object id can have this specifier. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db id auto
  unsigned long id_;
};
  </pre>

  <p>Note that automatically-assigned object ids are not reused.
     If you have a high object turnover (that is, objects are routinely
     made persistent and then erased), then care must be taken not to
     run out of object ids. In such situations, using
     <code>unsigned long long</code> as the identifier type is a safe
     choice.</p>

  <p>For additional information on the automatic identifier assignment,
     refer to <a href="#3.7">Section 3.7, "Making Objects Persistent"</a>.</p>

  <p>Note also that the <code>auto</code> specifier cannot be specified
     for data members of composite value types or views.</p>

  <h3><a name="11.4.3">11.4.3 <code>type</code></a></h3>

  <p>The <code>type</code> specifier specifies the native database type
     that should be used for a data member. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db type("INT")
  bool married_;
};
  </pre>

  <p>The <code>null</code> and <code>not_null</code> (<a href="#11.4.4">Section
     11.4.4, "<code>null</code>/<code>not_null</code>"</a>) specifiers
     can be used to control the NULL semantics of a data member.</p>

  <h3><a name="11.4.4">11.4.4 <code>null</code>/<code>not_null</code></a></h3>

  <p>The <code>null</code> and <code>not_null</code> specifiers specify that
     a data member can or cannot be <code>NULL</code>, respectively.
     By default, data members of basic value types for which database
     mapping is provided by the ODB compiler do not allow <code>NULL</code>
     values while data members of object pointers allow <code>NULL</code>
     values. Other value types, such as those provided by the profile
     libraries (<a href="#III">Part III, "Profiles"</a>), may or may
     not allow <code>NULL</code> values, depending on the semantics
     of each value type. Consult the relevant documentation to find
     out more about the <code>NULL</code> semantics for such value
     types. A data member containing the object id (<a href="#11.4.1">Section
     11.4.1, "<code>id</code>"</a> ) is automatically treated as not
     allowing a <code>NULL</code> value. Data members that
     allow <code>NULL</code> values are mapped in a relational database
     to columns that allow <code>NULL</code> values. For example:</p>

  <pre class="c++">
using std::tr1::shared_ptr;

#pragma db object
class person
{
  ...

  #pragma db null
  std::string name_;
};

#pragma db object
class account
{
  ...

  #pragma db not_null
  shared_ptr&lt;person> holder_;
};
</pre>

  <p>The <code>NULL</code> semantics can also be specified on the
     per-type basis (<a href="#11.3.3">Section 11.3.3,
     "<code>null</code>/<code>not_null</code>"</a>). If both a type and
     a member have <code>null</code>/<code>not_null</code> specifiers,
     then the member specifier takes precedence. If a member specifier
     relaxes the <code>NULL</code> semantics (that is, if a member has
     the <code>null</code> specifier and the type has the explicit
     <code>not_null</code> specifier), then a warning is issued.</p>

  <p>For a more detailed discussion of the <code>NULL</code> semantics
     for values, refer to <a href="#7.3">Section 7.3, "Pointers and
     <code>NULL</code> Value Semantics"</a>. For a more detailed
     discussion of the <code>NULL</code> semantics for object pointers,
     refer to <a href="#6">Chapter 6, "Relationships"</a>.</p>

  <h3><a name="11.4.5">11.4.5 <code>default</code></a></h3>

  <p>The <code>default</code> specifier specifies the database default value
     that should be used for a data member. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db default(-1)
  int age_;              // Mapped to INT NOT NULL DEFAULT -1.
};
  </pre>

  <p>A default value can be the special <code>null</code> keyword,
     a <code>bool</code> literal (<code>true</code> or <code>false</code>),
     an integer literal, a floating point literal, a string literal, or
     an enumerator name. If you need to specify a default value that is
     an expression, for example an SQL function call, then you can use
     the <code>options</code> specifier (<a href="#11.4.6">Section
     11.4.6, "<code>options</code>"</a>) instead. For example:</p>

  <pre class="c++">
enum gender {male, female, undisclosed};

#pragma db object
class person
{
  ...

  #pragma db default(null)
  odb::nullable&lt;std::string> middle_; // DEFAULT NULL

  #pragma db default(false)
  bool married_;                      // DEFAULT 0/FALSE

  #pragma db default(0.0)
  float weight_;                      // DEFAULT 0.0

  #pragma db default("Mr")
  string title_;                      // DEFAULT 'Mr'

  #pragma db default(undisclosed)
  gender gender_;                     // DEFAULT 2/'undisclosed'

  #pragma db options("DEFAULT CURRENT_TIMESTAMP()")
  date timestamp_;                    // DEFAULT CURRENT_TIMESTAMP()
};
  </pre>

  <p>Default values specified as enumerators are only supported for
     members that are mapped to an <code>ENUM</code> or an integer
     type in the database, which is the case for the automatic
     mapping of C++ enums to suitable database types as performed
     by the ODB compiler. If you have mapped a C++ enum to another
     database type, then you should use a literal corresponding
     to that type to specify the default value. For example:</p>

  <pre class="c++">
enum gender {male, female, undisclosed};
#pragma db value(gender) type("VARCHAR(11)")

#pragma db object
class person
{
  ...

  #pragma db default("undisclosed")
  gender gender_;                   // DEFAULT 'undisclosed'
};
  </pre>

  <p>A default value can also be specified on the per-type basis
     (<a href="#11.3.4">Section 11.3.4, "<code>default</code>"</a>).
     An empty <code>default</code> specifier can be used to reset
     a default value that was previously specified on the per-type
     basis. For example:</p>

  <pre class="c++">
#pragma db value(std::string) default("")

#pragma db object
class person
{
  ...

  #pragma db default()
  std::string name_;   // No default value.
};
  </pre>

  <p>A data member containing the object id (<a href="#11.4.1">Section
     11.4.1, "<code>id</code>"</a> ) is automatically treated as not
     having a default value even if its type specifies a default value.</p>

  <p>Note also that default values do not affect the generated C++ code
     in any way. In particular, no automatic initialization of data members
     with their default values is performed at any point. If you need such
     an initialization, you will need to implement it yourself, for example,
     in your persistent class constructors. The default values only
     affect the generated database schemas and, in the context of ODB,
     are primarily useful for schema evolution.</p>

  <p>Additionally, the <code>default</code> specifier cannot be specified
     for view data members.</p>

  <h3><a name="11.4.6">11.4.6 <code>options</code></a></h3>

  <p>The <code>options</code> specifier specifies additional column
     definition options that should be used for a data member. For
     example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db options("UNIQUE")
  std::string email_; // Mapped to TEXT NOT NULL UNIQUE.
};
  </pre>

  <p>Options can also be specified on the per-type basis
     (<a href="#11.3.5">Section 11.3.5, "<code>options</code>"</a>).
     By default, options are accumulating. That is, the ODB compiler
     first adds all the options specified for a value type followed
     by all the options specified for a data member. To clear the
     accumulated options at any point in this sequence you can use
     an empty <code>options</code> specifier. For example:</p>

  <pre class="c++">
#pragma db value(std::string) options("COLLATE binary")

#pragma db object
class person
{
  ...

  std::string first_; // TEXT NOT NULL COLLATE binary

  #pragma db options("UNIQUE")
  std::string last_;  // TEXT NOT NULL COLLATE binary UNIQUE

  #pragma db options()
  std::string title_; // TEXT NOT NULL

  #pragma db options() options("UNIQUE")
  std::string email_; // TEXT NOT NULL UNIQUE
};
  </pre>

  <p>ODB provides dedicated specifiers for specifying column types
     (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>),
     <code>NULL</code> constraints (<a href="#11.4.4">Section 11.4.4,
     "<code>null</code>/<code>not_null</code>"</a>), and default
     values (<a href="#11.4.5">Section 11.4.5, "<code>default</code>"</a>).
     For ODB to function correctly these specifiers should always be
     used instead of the opaque <code>options</code> specifier for
     these components of a column definition.</p>

  <p>Note also that the <code>options</code> specifier cannot be specified
     for view data members.</p>

  <h3><a name="11.4.7">11.4.7 <code>column</code> (object, composite value)</a></h3>

  <p>The <code>column</code> specifier specifies the column name
     that should be used to store a data member of a persistent class
     or composite value type in a relational database. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db id column("person_id")
  unsigned long id_;
};
  </pre>

  <p>For a member of a composite value type, the <code>column</code> specifier
     specifies the column name prefix. Refer to <a href="#7.2.1">Section 7.2.1,
     "Composite Value Column and Table Names"</a> for details.</p>

  <p>If the column name is not specified, it is derived from the member's
     so-called public name. A public member name is obtained by removing
     the common data member name decorations, such as leading and trailing
     underscores, the <code>m_</code> prefix, etc.</p>

  <h3><a name="11.4.8">11.4.8 <code>column</code> (view)</a></h3>

  <p>The <code>column</code> specifier can be used to specify the associated
     object data member, the potentially qualified column name, or the column
     expression for a data member of a view class. For more information,
     refer to <a href="#9.1">Section 9.1, "Object Views"</a> and
     <a href="#9.2">Section 9.2, "Table Views"</a>.</p>

  <h3><a name="11.4.9">11.4.9 <code>transient</code></a></h3>

  <p>The <code>transient</code> specifier instructs the ODB compiler
     not to store a data member in the database. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  date born_;

  #pragma db transient
  unsigned short age_; // Computed from born_.
};
  </pre>

  <p>This pragma is usually used on computed members, pointers and
     references that are only meaningful in the application's
     memory, as well as utility members such as mutexes, etc.</p>

  <h3><a name="11.4.10">11.4.10 <code>readonly</code></a></h3>

  <p>The <code>readonly</code> specifier specifies that a data member of
     an object or composite value type is read-only. Changes to a read-only
     data member are ignored when updating the database state of an object
     (<a href="#3.9">Section 3.9, "Updating Persistent Objects"</a>)
     containing such a member. Since views are read-only, it is not
     necessary to use this specifier for view data members. Object id
     (<a href="#11.4.1">Section 11.4.1, "<code>id</code>"</a>)
     and inverse (<a href="#11.4.11">Section 11.4.11,
     "<code>inverse</code>"</a>) data members are automatically treated
     as read-only and must not be explicitly declared as such. For
     example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db readonly
  date born_;
};
  </pre>

  <p>Besides simple value members, object pointer, container, and composite
     value members can also be declared read-only. A change of a pointed-to
     object is ignored when updating the state of a read-only object
     pointer. Similarly, any changes to the number or order of
     elements or to the element values themselves are ignored when
     updating the state of a read-only container. Finally, any changes
     to the members of a read-only composite value type are also ignored
     when updating the state of such a composite value.</p>

  <p>ODB automatically treats <code>const</code> data members as read-only.
     For example, the following <code>person</code> object is equivalent
     to the above declaration for the database persistence purposes:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  const date born_; // Automatically read-only.
};
  </pre>

  <p>When declaring an object pointer <code>const</code>, make sure to
     declare the pointer as <code>const</code> rather than (or in addition
     to) the object itself. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  const person* father_; // Read-write pointer to a read-only object.
  person* const mother_; // Read-only pointer to a read-write object.
};
  </pre>

  <p>Note that in case of a wrapper type (<a href="#7.3">Section 7.3,
     "Pointers and <code>NULL</code> Value Semantics"</a>), both the
     wrapper and the wrapped type must be <code>const</code> in
     order for the ODB compiler to automatically treat the data
     member as read-only. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  const std::auto_ptr&lt;const date> born_;
};
  </pre>

  <p>Read-only members are useful when dealing with
     asynchronous changes to the state of a data member in the
     database which should not be overwritten. In other cases,
     where the state of a data member never changes, declaring such a member
     read-only allows ODB to perform more efficient object updates.
     In such cases, however, it is conceptually more correct to
     declare such a data member as <code>const</code> rather than
     as read-only.</p>

  <p>Note that it is also possible to declare composite value types
     (<a href="#11.3.6">Section 11.3.6, "<code>readonly</code>"</a>)
     as well as whole objects (<a href="#11.1.4">Section 11.1.4,
     "<code>readonly</code>"</a>) as read-only.</p>

  <h3><a name="11.4.11">11.4.11 <code>inverse</code></a></h3>

  <p>The <code>inverse</code> specifier specifies that a data member of
     an object pointer or a container of object pointers type is an
     inverse side of a bidirectional object relationship. The single
     required argument to this specifier is the corresponding data
     member name in the referenced object. For example:</p>

<pre class="c++">
using std::tr1::shared_ptr;
using std::tr1::weak_ptr;

class person;

#pragma db object pointer(shared_ptr)
class employer
{
  ...

  std::vector&lt;shared_ptr&lt;person> > employees_;
};

#pragma db object pointer(shared_ptr)
class person
{
  ...

  #pragma db inverse(employee_)
  weak_ptr&lt;employer> employer_;
};
  </pre>

  <p>An inverse member does not have a corresponding column or, in case
     of a container, table in the resulting database schema. Instead, the
     column or table from the referenced object is used to retrieve the
     relationship information. Only ordered and set containers can be used
     for inverse members. If an inverse member is of an ordered container
     type, it is automatically marked as unordered
     (<a href="#11.4.12">Section 11.4.12, "<code>unordered</code>"</a>).</p>

  <p>For a more detailed discussion of inverse members, refer to
     <a href="#6.2">Section 6.2, "Bidirectional Relationships"</a>.</p>

  <h3><a name="11.4.12">11.4.12 <code>unordered</code></a></h3>

  <p>The <code>unordered</code> specifier specifies that a member of
     an ordered container type should be stored unordered in the database.
     The database table for such a member will not contain the index column
     and the order in which elements are retrieved from the database may
     not be the same as the order in which they were stored. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db unordered
  std::vector&lt;std::string> nicknames_;
};
  </pre>

  <p>For a more detailed discussion of ordered containers and their
     storage in the database, refer to <a href="#5.1">Section 5.1,
     "Ordered Containers"</a>.</p>

  <h3><a name="11.4.13">11.4.13 <code>table</code></a></h3>

  <p>The <code>table</code> specifier specifies the table name that should
     be used to store the contents of a container member. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db table("nicknames")
  std::vector&lt;std::string> nicknames_;
};
  </pre>

  <p>If the table name is not specified, then the container table name
     is constructed by concatenating the object's table name, underscore,
     and the public member name. The public member name is obtained
     by removing the common member name decorations, such as leading and
     trailing underscores, the <code>m_</code> prefix, etc. In the example
     above, without the <code>table</code> specifier, the container's
     table name would have been <code>person_nicknames</code>.</p>

  <p>The <code>table</code> specifier can also be used for members of
     composite value types. In this case it specifies the table name
     prefix for container members inside the composite value type. Refer
     to <a href="#7.2.1">Section 7.2.1, "Composite Value Column and Table
     Names"</a> for details.</p>

  <h3><a name="11.4.14">11.4.14 <code>index_type</code></a></h3>

  <p>The <code>index_type</code> specifier specifies the native
     database type that should be used for an ordered container's
     index column of a data member. The semantics of <code>index_type</code>
     are similar to those of the <code>type</code> specifier
     (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>). The native
     database type is expected to be an integer type. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db index_type("SMALLINT UNSIGNED")
  std::vector&lt;std::string> nicknames_;
};
  </pre>

  <h3><a name="11.4.15">11.4.15 <code>key_type</code></a></h3>

  <p>The <code>key_type</code> specifier specifies the native
     database type that should be used for a map container's
     key column of a data member. The semantics of <code>key_type</code>
     are similar to those of the <code>type</code> specifier
     (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>). For
     example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db key_type("INT UNSIGNED")
  std::map&lt;unsigned short, float> age_weight_map_;
};
  </pre>

  <h3><a name="11.4.16">11.4.16 <code>value_type</code></a></h3>

  <p>The <code>value_type</code> specifier specifies the native
     database type that should be used for a container's
     value column of a data member. The semantics of <code>value_type</code>
     are similar to those of the <code>type</code> specifier
     (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>). For
     example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db value_type("VARCHAR(255)")
  std::vector&lt;std::string> nicknames_;
};
  </pre>

  <p>The <code>value_null</code> and <code>value_not_null</code>
     (<a href="#11.4.17">Section 11.4.17,
     "<code>value_null</code>/<code>value_not_null</code>"</a>) specifiers
     can be used to control the NULL semantics of a value column.</p>

  <h3><a name="11.4.17">11.4.17 <code>value_null</code>/<code>value_not_null</code></a></h3>

  <p>The <code>value_null</code> and <code>value_not_null</code> specifiers
     specify that a container's element value for a data member can or
     cannot be <code>NULL</code>, respectively. The semantics of
     <code>value_null</code> and <code>value_not_null</code> are similar
     to those of the <code>null</code> and <code>not_null</code> specifiers
     (<a href="#11.4.4">Section 11.4.4, "<code>null</code>/<code>not_null</code>"</a>).
     For example:</p>

  <pre class="c++">
using std::tr1::shared_ptr;

#pragma db object
class person
{
  ...
};

#pragma db object
class account
{
  ...

  #pragma db value_not_null
  std::vector&lt;shared_ptr&lt;person> > holders_;
};
  </pre>

  <p>For set and multiset containers (<a href="#5.2">Section 5.2, "Set and
     Multiset Containers"</a>) the element value is automatically treated
     as not allowing a <code>NULL</code> value.</p>

  <h3><a name="11.4.18">11.4.18 <code>id_options</code></a></h3>

  <p>The <code>id_options</code> specifier specifies additional
     column definition options that should be used for a container's
     id column of a data member. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db id options("COLLATE binary")
  std::string name_;

  #pragma db id_options("COLLATE binary")
  std::vector&lt;std::string> nicknames_;
};
  </pre>

  <p>The semantics of <code>id_options</code> are similar to those
     of the <code>options</code> specifier (<a href="#11.4.6">Section
     11.4.6, "<code>options</code>"</a>).</p>

  <h3><a name="11.4.19">11.4.19 <code>index_options</code></a></h3>

  <p>The <code>index_options</code> specifier specifies additional
     column definition options that should be used for a container's
     index column of a data member. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db index_options("ZEROFILL")
  std::vector&lt;std::string> nicknames_;
};
  </pre>

  <p>The semantics of <code>index_options</code> are similar to those
     of the <code>options</code> specifier (<a href="#11.4.6">Section
     11.4.6, "<code>options</code>"</a>).</p>

  <h3><a name="11.4.20">11.4.20 <code>key_options</code></a></h3>

  <p>The <code>key_options</code> specifier specifies additional
     column definition options that should be used for a container's
     key column of a data member. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db key_options("COLLATE binary")
  std::map&lt;std::string, std::string> properties_;
};
  </pre>

  <p>The semantics of <code>key_options</code> are similar to those
     of the <code>options</code> specifier (<a href="#11.4.6">Section
     11.4.6, "<code>options</code>"</a>).</p>

  <h3><a name="11.4.21">11.4.21 <code>value_options</code></a></h3>

  <p>The <code>value_options</code> specifier specifies additional
     column definition options that should be used for a container's
     value column of a data member. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db value_options("COLLATE binary")
  std::set&lt;std::string> nicknames_;
};
  </pre>

  <p>The semantics of <code>value_options</code> are similar to those
     of the <code>options</code> specifier (<a href="#11.4.6">Section
     11.4.6, "<code>options</code>"</a>).</p>

  <h3><a name="11.4.22">11.4.22 <code>id_column</code></a></h3>

  <p>The <code>id_column</code> specifier specifies the column
     name that should be used to store the object id in a
     container's table for a data member. The semantics of
     <code>id_column</code> are similar to those of the
     <code>column</code> specifier
     (<a href="#11.4.7">Section 11.4.7, "<code>column</code>"</a>).
     For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db id_column("person_id")
  std::vector&lt;std::string> nicknames_;
};
  </pre>

  <p>If the column name is not specified, then <code>object_id</code>
     is used by default.</p>

  <h3><a name="11.4.23">11.4.23 <code>index_column</code></a></h3>

  <p>The <code>index_column</code> specifier specifies the column
     name that should be used to store the element index in an
     ordered container's table for a data member. The semantics of
     <code>index_column</code> are similar to those of the
     <code>column</code> specifier
     (<a href="#11.4.7">Section 11.4.7, "<code>column</code>"</a>).
     For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db index_column("nickname_number")
  std::vector&lt;std::string> nicknames_;
};
  </pre>

  <p>If the column name is not specified, then <code>index</code>
     is used by default.</p>

  <h3><a name="11.4.24">11.4.24 <code>key_column</code></a></h3>

  <p>The <code>key_column</code> specifier specifies the column
     name that should be used to store the key in a map
     container's table for a data member. The semantics of
     <code>key_column</code> are similar to those of the
     <code>column</code> specifier
     (<a href="#11.4.7">Section 11.4.7, "<code>column</code>"</a>).
     For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db key_column("age")
  std::map&lt;unsigned short, float> age_weight_map_;
};
  </pre>

  <p>If the column name is not specified, then <code>key</code>
     is used by default.</p>

  <h3><a name="11.4.25">11.4.25 <code>value_column</code></a></h3>

  <p>The <code>value_column</code> specifier specifies the column
     name that should be used to store the element value in a
     container's table for a data member. The semantics of
     <code>value_column</code> are similar to those of the
     <code>column</code> specifier
     (<a href="#11.4.7">Section 11.4.7, "<code>column</code>"</a>).
     For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db value_column("weight")
  std::map&lt;unsigned short, float> age_weight_map_;
};
  </pre>

  <p>If the column name is not specified, then <code>value</code>
     is used by default.</p>

  <h2><a name="11.5">11.5 C++ Compiler Warnings</a></h2>

  <p>When a C++ header file defining persistent classes and containing
     ODB pragmas is used to build the application, the C++ compiler may
     issue warnings about pragmas that it doesn't recognize. There
     are several ways to deal with this problem. The easiest is to
     disable such warnings using one of the compiler-specific command
     line options or warning control pragmas. This method is described
     in the following sub-section for popular C++ compilers.</p>

  <p>There are also several C++ compiler-independent methods that we
     can employ. The first is to use the <code>PRAGMA_DB</code> macro,
     defined in <code>&lt;odb/core.hxx></code>, instead of using
     <code>#pragma&nbsp;db</code> directly. This macro expands to the
     ODB pragma when compiled with the ODB compiler and to an empty
     declaration when compiled with other compilers. The following example
     shows how we can use this macro:</p>

  <pre class="c++">
#include &lt;odb/core.hxx>

PRAGMA_DB(object)
class person
{
  ...

  PRAGMA_DB(id)
  unsigned long id_;
};
  </pre>

  <p>An alternative to using the <code>PRAGMA_DB</code> macro is to
     group the <code>#pragma&nbsp;db</code> directives in blocks that are
     conditionally included into compilation only when compiled with the
     ODB compiler. For example:</p>

  <pre class="c++">
class person
{
  ...

  unsigned long id_;
};

#ifdef ODB_COMPILER
#  pragma db object(person)
#  pragma db member(person::id_) id
#endif
  </pre>

  <p>The disadvantage of this approach is that it can quickly become
     overly verbose when positioned pragmas are used.</p>

  <h3><a name="11.5.1">11.5.1 GNU C++</a></h3>

  <p>GNU g++ does not issue warnings about unknown pragmas
     unless requested with the <code>-Wall</code> command line option.
     To disable only the unknown pragma warning, we can add the
     <code>-Wno-unknown-pragmas</code> option after <code>-Wall</code>,
     for example:</p>

  <pre class="terminal">
g++ -Wall -Wno-unknown-pragmas ...
  </pre>

  <h3><a name="11.5.2">11.5.2 Visual C++</a></h3>

  <p>Microsoft Visual C++ issues an unknown pragma warning (C4068) at
     warning level 1 or higher. This means that unless we have disabled
     the warnings altogether (level 0), we will see this warning.</p>

  <p>To disable this warning via the compiler command line, we can add
     the <code>/wd4068</code> C++ compiler option in Visual Studio 2008
     and earlier. In Visual Studio 2010 there is now a special GUI field
     where we can enter warning numbers that should be disabled. Simply
     enter 4068 into this field.</p>

  <p>We can also disable this warning for only a specific header or
     a fragment of a header using the warning control pragma. For
     example:</p>

  <pre class="c++">
#include &lt;odb/core.hxx>

#pragma warning (push)
#pragma warning (disable:4068)

#pragma db object
class person
{
  ...

  #pragma db id
  unsigned long id_;
};

#pragma warning (pop)
  </pre>

  <h3><a name="11.5.3">11.5.3 Sun C++</a></h3>

  <p>The Sun C++ compiler does not issue warnings about unknown pragmas
     unless the <code>+w</code> or <code>+w2</code> option is specified.
     To disable only the unknown pragma warning we can add the
     <code>-erroff=unknownpragma</code> option anywhere on the
     command line, for example:</p>

  <pre class="terminal">
CC +w -erroff=unknownpragma ...
  </pre>

  <h3><a name="11.5.4">11.5.4 IBM XL C++</a></h3>

  <p>IBM XL C++ issues an unknown pragma warning (1540-1401) by default.
     To disable this warning we can add the <code>-qsuppress=1540-1401</code>
     command line option, for example:</p>

  <pre class="terminal">
xlC -qsuppress=1540-1401 ...
  </pre>

  <h3><a name="11.5.5">11.5.5 HP aC++</a></h3>

  <p>HP aC++ (aCC) issues an unknown pragma warning (2161) by default.
     To disable this warning we can add the <code>+W2161</code>
     command line option, for example:</p>

  <pre class="terminal">
aCC +W2161 ...
  </pre>


  <!-- PART -->


  <hr class="page-break"/>
  <h1><a name="II">PART II&nbsp;&nbsp;
      <span style="font-weight: normal;">DATABASE SYSTEMS</span></a></h1>

  <p>Part II covers topics specific to the database system
     implementations and their support in ODB. In particular, it
     describes the system-specific <code>database</code> classes
     as well as the default mapping between basic C++ value types
     and native database types. Part II consists of the following
     chapters.</p>

  <table class="toc">
    <tr><th>12</th><td><a href="#12">MySQL Database</a></td></tr>
    <tr><th>13</th><td><a href="#13">SQLite Database</a></td></tr>
    <tr><th>14</th><td><a href="#14">PostgreSQL Database</a></td></tr>
  </table>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="12">12 MySQL Database</a></h1>

  <p>To generate support code for the MySQL database you will need
     to pass the "<code>--database&nbsp;mysql</code>"
     (or "<code>-d&nbsp;mysql</code>") option to the ODB compiler.
     Your application will also need to link to the MySQL ODB runtime
     library (<code>libodb-mysql</code>). All MySQL-specific ODB
     classes are defined in the <code>odb::mysql</code> namespace.</p>

  <h2><a name="12.1">12.1 MySQL Type Mapping</a></h2>

  <p>The following table summarizes the default mapping between basic
     C++ value types and MySQL database types. This mapping can be
     customized on the per-type and per-member basis using the ODB
     Pragma Language (<a href="#11">Chapter 11, "ODB Pragma
     Language"</a>).</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>C++ Type</th>
      <th>MySQL Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>bool</code></td>
      <td><code>TINYINT(1)</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>char</code></td>
      <td><code>TINYINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>signed char</code></td>
      <td><code>TINYINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned char</code></td>
      <td><code>TINYINT UNSIGNED</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>short</code></td>
      <td><code>SMALLINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned short</code></td>
      <td><code>SMALLINT UNSIGNED</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>int</code></td>
      <td><code>INT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned int</code></td>
      <td><code>INT UNSIGNED</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>long</code></td>
      <td><code>BIGINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned long</code></td>
      <td><code>BIGINT UNSIGNED</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>long long</code></td>
      <td><code>BIGINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned long long</code></td>
      <td><code>BIGINT UNSIGNED</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>float</code></td>
      <td><code>FLOAT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>double</code></td>
      <td><code>DOUBLE</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>std::string</code></td>
      <td><code>TEXT/VARCHAR(255)</code></td>
      <td><code>NOT NULL</code></td>
    </tr>
  </table>

  <p>Note that the <code>std::string</code> type is mapped
     differently depending on whether the member of this type
     is an object id or not. If the member is an object id,
     then for this member <code>std::string</code> is mapped
     to the <code>VARCHAR(255)</code> MySQL type. Otherwise,
     it is mapped to <code>TEXT</code>.</p>

  <p>The MySQL ODB runtime library also provides support for mapping the
     <code>std::vector&lt;char></code> type to the MySQL BLOB types.
     However, this mapping is not enabled by default (by default,
     <code>std::vector&lt;char></code> will be treated as a container).
     To enable the BLOB mapping for this type we need to specify
     the database type explicitly using the <code>db&nbsp;type</code>
     pragma (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>),
     for example:</p>

  <pre class="c++">
#pragma db object
class object
{
  ...

  #pragma db type("BLOB")
  std::vector&lt;char> buf_;
};
  </pre>

  <p>Alternatively, this can be done on the per-type basis, for example:</p>

  <pre class="c++">
typedef std::vector&lt;char> buffer;
#pragma db value(buffer) type("BLOB")

#pragma db object
class object
{
  ...

  buffer buf_; // Mapped to BLOB.
};
  </pre>

  <p>Additionally, by default, C++ enumerations are automatically
     mapped to a suitable MySQL type. Contiguous enumerations with
     the zero first enumerator are mapped to the MySQL <code>ENUM</code>
     type. All other enumerations are mapped to <code>INT</code> or
     <code>INT UNSIGNED</code>. In both cases the default <code>NULL</code>
     semantics is <code>NOT NULL</code>. For example:</p>

  <pre class="c++">
enum color {red, green, blue};
enum taste
{
  bitter = 1, // Non-zero first enumerator.
  sweet,
  sour = 4,   // Non-contiguous.
  salty
};

#pragma db object
class object
{
  ...

  color color_; // Mapped to ENUM ('red', 'green', 'blue') NOT NULL.
  taste taste_; // Mapped to INT UNSIGNED NOT NULL.
};
  </pre>

  <h2><a name="12.2">12.2 MySQL Database Class</a></h2>

  <p>The MySQL <code>database</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class database: public odb::database
    {
    public:
      database (const char* user,
                const char* passwd,
                const char* db,
                const char* host = 0,
                unsigned int port = 0,
                const char* socket = 0,
                const char* charset = 0,
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; user,
                const std::string&amp; passwd,
                const std::string&amp; db,
                const std::string&amp; host = "",
                unsigned int port = 0,
                const std::string* socket = 0,
                const std::string&amp; charset = "",
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; user,
                const std::string* passwd,
                const std::string&amp; db,
                const std::string&amp; host = "",
                unsigned int port = 0,
                const std::string* socket = 0,
                const std::string&amp; charset = "",
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; user,
                const std::string&amp; passwd,
                const std::string&amp; db,
                const std::string&amp; host,
                unsigned int port,
                const std::string&amp; socket,
                const std::string&amp; charset = "",
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; user,
                const std::string* passwd,
                const std::string&amp; db,
                const std::string&amp; host,
                unsigned int port,
                const std::string&amp; socket,
                const std::string&amp; charset = "",
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      database (int&amp; argc,
                char* argv[],
                bool erase = false,
                const std::string&amp; charset = "",
                unsigned long client_flags = 0,
                std::auto_ptr&lt;connection_factory> = 0);

      static void
      print_usage (std::ostream&amp;);


    public:
      const char*
      user () const;

      const char*
      password () const;

      const char*
      db () const;

      const char*
      host () const;

      unsigned int
      port () const;

      const char*
      socket () const;

      const char*
      charset () const;

      unsigned long
      client_flags () const;

    public:
      connection_ptr
      connection ();
    };
  }
}
  </pre>

  <p>You will need to include the <code>&lt;odb/mysql/database.hxx></code>
     header file to make this class available in your application.</p>

  <p>The overloaded <code>database</code> constructors allow us
     to specify MySQL database parameters that should be used when
     connecting to the database. In MySQL <code>NULL</code> and an
     empty string are treated as the same values for all the
     string parameters except <code>password</code> and
     <code>socket</code>.</p>

  <p>The <code>charset</code> argument allows us to specify the client
     character set, that is, the character set in which the application
     will encode its text data. Note that this can be different from
     the MySQL server character set. If this argument is not specified or
     is empty, then the default MySQL client character set is used, normally
     <code>latin1</code>. Commonly used values for this argument are
     <code>latin1</code> (equivalent to Windows cp1252 and similar to
     ISO-8859-1) and <code>utf8</code>. For other possible values
     as well as more information on character set support in MySQL,
     refer to the MySQL documentation.</p>

  <p>The <code>client_flags</code> argument allows us to specify various
     MySQL client library flags. For more information on the possible
     values, refer to the MySQL C API documentation. The
     <code>CLIENT_FOUND_ROWS</code> flag is always set by the MySQL ODB
     runtime regardless of whether it was passed in the
     <code>client_flags</code> argument.</p>

  <p>The last constructor extracts the database parameters
     from the command line. The following options are recognized:</p>

  <pre class="terminal">
  --user &lt;login>
  --password &lt;password>
  --database &lt;name>
  --host &lt;host>
  --port &lt;integer>
  --socket &lt;socket>
  --options-file &lt;file>
  </pre>

  <p>The <code>--options-file</code> option allows us to specify some
     or all of the database options in a file with each option appearing
     on a separate line followed by a space and an option value.</p>

  <p>If the <code>erase</code> argument to this constructor is true,
     then the above options are removed from the <code>argv</code>
     array and the <code>argc</code> count is updated accordingly.
     This is primarily useful if your application accepts other
     options or arguments and you would like to get the MySQL
     options out of the <code>argv</code> array.</p>

  <p>This constructor throws the <code>odb::mysql::cli_exception</code>
     exception if the MySQL option values are missing or invalid.
     See section <a href="#12.4">Section 12.4, "MySQL Exceptions"</a>
     for more information on this exception.</p>

  <p>The static <code>print_usage()</code> function prints the list of options
     with short descriptions that are recognized by this constructor.</p>

  <p>The last argument to all of the constructors is a
     pointer to the connection factory. If we pass a
     non-<code>NULL</code> value, the database instance assumes
     ownership of the factory instance. The connection factory
     interface as well as the available implementations are described
     in the next section.</p>

  <p>The set of accessor functions following the constructors allows us
     to query the parameters of the <code>database</code> instance.</p>

  <p>The <code>connection()</code> function returns a pointer to the
     MySQL database connection encapsulated by the
     <code>odb::mysql::connection</code> class. For more information
     on <code>mysql::connection</code>, refer to <a href="#12.3">Section
     12.3, "MySQL Connection and Connection Factory"</a>.</p>

  <h2><a name="12.3">12.3 MySQL Connection and Connection Factory</a></h2>

  <p>The <code>mysql::connection</code> class has the following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class connection: public odb::connection
    {
    public:
      connection (database&amp;);
      connection (database&amp;, MYSQL*);

      MYSQL*
      handle ();
    };

    typedef details::shared_ptr&lt;connection> connection_ptr;
  }
}
  </pre>

  <p>For more information on the <code>odb::connection</code> interface,
     refer to <a href="#3.5">Section 3.5, "Connections"</a>. The first
     overloaded <code>mysql::connection</code> constructor establishes a
     new MySQL connection. The second constructor allows us to create
     a <code>connection</code> instance by providing an already connected
     native MySQL handle. Note that the <code>connection</code>
     instance assumes ownership of this handle. The <code>handle()</code>
     accessor returns the MySQL handle corresponding to the connection.</p>

  <p>The <code>mysql::connection_factory</code> abstract class has the
     following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class connection_factory
    {
    public:
      virtual void
      database (database&amp;) = 0;

      virtual connection_ptr
      connect () = 0;
    };
  }
}
  </pre>

  <p>The <code>database()</code> function is called when a connection
     factory is associated with a database instance. This happens in
     the <code>odb::mysql::database</code> class constructors. The
     <code>connect()</code> function is called whenever a database
     connection is requested.</p>

  <p>The two implementations of the <code>connection_factory</code>
     interface provided by the MySQL ODB runtime are
     <code>new_connection_factory</code> and
     <code>connection_pool_factory</code>. You will need to include
     the <code>&lt;odb/mysql/connection-factory.hxx></code>
     header file to make the <code>connection_factory</code> interface
     and these implementation classes available in your application.</p>

  <p>The <code>new_connection_factory</code> class creates a new
     connection whenever one is requested. When a connection is no
     longer needed, it is released and closed. The
     <code>new_connection_factory</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class new_connection_factory: public connection_factory
    {
    public:
      new_connection_factory ();
    };
};
  </pre>

  <p>The <code>connection_pool_factory</code> class implements a
     connection pool. It has the following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class connection_pool_factory: public connection_factory
    {
    public:
      connection_pool_factory (std::size_t max_connections = 0,
                               std::size_t min_connections = 0,
                               bool ping = true);

    protected:
      class pooled_connection: public connection
      {
      public:
        pooled_connection (database_type&amp;);
        pooled_connection (database_type&amp;, MYSQL*);
      };

      typedef details::shared_ptr&lt;pooled_connection> pooled_connection_ptr;

      virtual pooled_connection_ptr
      create ();
    };
};
  </pre>

  <p>The <code>max_connections</code> argument in the
     <code>connection_pool_factory</code> constructor specifies the maximum
     number of concurrent connections that this pool factory will
     maintain. Similarly, the <code>min_connections</code> argument
     specifies the minimum number of available connections that
     should be kept open. The <code>ping</code> argument specifies
     whether the factory should validate the connection before
     returning it to the caller.</p>

  <p>Whenever a connection is requested, the pool factory first
     checks if there is an unused connection that can be returned.
     If there is none, the pool factory checks the
     <code>max_connections</code> value to see if a new connection
     can be created. If the total number of connections maintained
     by the pool is less than this value, then a new connection is
     created and returned. Otherwise, the caller is blocked until
     a connection becomes available.</p>

  <p>When a connection is released, the pool factory first checks
     if there are blocked callers waiting for a connection. If so, then
     one of them is unblocked and is given the connection. Otherwise,
     the pool factory checks whether the total number of connections
     maintained by the pool is greater than the <code>min_connections</code>
     value. If that's the case, the connection is closed. Otherwise, the
     connection is added to the pool of available connections to be
     returned on the next request. In other words, if the number of
     connections maintained by the pool exceeds <code>min_connections</code>
     and there are no callers waiting for a new connection,
     then the pool will close the excess connections.</p>

  <p>If the <code>max_connections</code> value is 0, then the pool will
     create a new connection whenever all of the existing connections
     are in use. If the <code>min_connections</code> value is 0, then
     the pool will never close a connection and instead maintain all
     the connections that were ever created.</p>

  <p>Connection validation (the <code>ping</code> argument) is useful
     if your application may experience long periods of inactivity. In
     such cases the MySQL server may close network connections that have
     been inactive for too long. If during connection validation the pool
     factory detects that the connection has been terminated, it silently
     closes it and tries to find or create another connection instead.</p>

  <p>The <code>create()</code> virtual function is called whenever the
     pool needs to create a new connection. By deriving from the
     <code>connection_pool_factory</code> class and overriding this
     function we can implement custom connection establishment
     and configuration.</p>

  <p>If you pass <code>NULL</code> as the connection factory to
     one of the <code>database</code> constructors, then the
     <code>connection_pool_factory</code> instance will be
     created by default with the min and max connections values
     set to <code>0</code> and connection validation enabled.
     The following code fragment shows how we can pass our own
     connection factory instance:</p>

  <pre class="c++">
#include &lt;odb/database.hxx>

#include &lt;odb/mysql/database.hxx>
#include &lt;odb/mysql/connection-factory.hxx>

int
main (int argc, char* argv[])
{
  auto_ptr&lt;odb::mysql::connection_factory> f (
    new odb::mysql::connection_pool_factory (20));

  auto_ptr&lt;odb::database> db (
    new mysql::database (argc, argv, false, 0, f));
}
  </pre>

  <h2><a name="12.4">12.4 MySQL Exceptions</a></h2>

  <p>The MySQL ODB runtime library defines the following MySQL-specific
     exceptions:</p>

  <pre class="c++">
namespace odb
{
  namespace mysql
  {
    class database_exception: odb::database_exception
    {
    public:
      unsigned int
      error () const;

      const std::string&amp;
      sqlstate () const;

      const std::string&amp;
      message () const;

      virtual const char*
      what () const throw ();
    };

    class cli_exception: odb::exception
    {
    public:
      virtual const char*
      what () const throw ();
    };
  }
}
  </pre>

  <p>You will need to include the <code>&lt;odb/mysql/exceptions.hxx></code>
     header file to make these exceptions available in your application.</p>

  <p>The <code>odb::mysql::database_exception</code> is thrown if
     a MySQL database operation fails. The MySQL-specific error
     information is accessible via the <code>error()</code>,
     <code>sqlstate()</code>, and <code>message()</code> functions.
     All this information is also combined and returned in a
     human-readable form by the <code>what()</code> function.</p>

  <p>The <code>odb::mysql::cli_exception</code> is thrown by the
     command line parsing constructor of the <code>odb::mysql::database</code>
     class if the MySQL option values are missing or invalid. The
     <code>what()</code> function returns a human-readable description
     of an error.</p>

  <h2><a name="12.5">12.5 MySQL Limitations</a></h2>

  <p>The following sections describe MySQL-specific limitations imposed
     by the current MySQL and ODB runtime versions.</p>

  <h3><a name="12.5.1">12.5.1 Foreign Key Constraints</a></h3>

  <p>ODB relies on standard SQL behavior which requires that foreign
     key constraints checking is deferred until the transaction is
     committed. The only behaviors supported by MySQL are to either
     check such constraints immediately (InnoDB engine) or to ignore
     foreign key constraints altogether (all other engines). As a
     result, schemas generated by the ODB compiler for MySQL have
     foreign key definitions commented out. They are retained only
     for documentation.</p>

  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="13">13 SQLite Database</a></h1>

  <p>To generate support code for the SQLite database you will need
     to pass the "<code>--database&nbsp;sqlite</code>"
     (or "<code>-d&nbsp;sqlite</code>") option to the ODB compiler.
     Your application will also need to link to the SQLite ODB runtime
     library (<code>libodb-sqlite</code>). All SQLite-specific ODB
     classes are defined in the <code>odb::sqlite</code> namespace.</p>

  <h2><a name="13.1">13.1 SQLite Type Mapping</a></h2>

  <p>The following table summarizes the default mapping between basic
     C++ value types and SQLite database types. This mapping can be
     customized on the per-type and per-member basis using the ODB
     Pragma Language (<a href="#11">Chapter 11, "ODB Pragma
     Language"</a>).</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>C++ Type</th>
      <th>SQLite Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>bool</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>char</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>signed char</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned char</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>short</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned short</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>int</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned int</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>long</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned long</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>long long</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned long long</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>float</code></td>
      <td><code>REAL</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>double</code></td>
      <td><code>REAL</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>std::string</code></td>
      <td><code>TEXT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>
  </table>

  <p>The SQLite ODB runtime library also provides support for mapping the
     <code>std::vector&lt;char></code> type to the SQLite BLOB type.
     However, this mapping is not enabled by default (by default,
     <code>std::vector&lt;char></code> will be treated as a container).
     To enable the BLOB mapping for this type we need to specify
     the database type explicitly using the <code>db&nbsp;type</code>
     pragma (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>),
     for example:</p>

  <pre class="c++">
#pragma db object
class object
{
  ...

  #pragma db type("BLOB")
  std::vector&lt;char> buf_;
};
  </pre>

  <p>Alternatively, this can be done on the per-type basis, for example:</p>

  <pre class="c++">
typedef std::vector&lt;char> buffer;
#pragma db value(buffer) type("BLOB")

#pragma db object
class object
{
  ...

  buffer buf_; // Mapped to BLOB.
};
  </pre>

  <p>Additionally, by default, C++ enumerations are automatically mapped to
     the SQLite <code>INTEGER</code> type with the default <code>NULL</code>
     semantics being <code>NOT NULL</code>.</p>

  <p>Note also that SQLite only operates with signed integers and the largest
     value that an SQLite database can store is a signed 64-bit integer. As
     a result, greater <code>unsigned&nbsp;long&nbsp;long</code> values will be
     represented in the database as negative values.</p>

  <h2><a name="13.2">13.2 SQLite Database Class</a></h2>

  <p>The SQLite <code>database</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  namespace sqlite
  {
    class database: public odb::database
    {
    public:
      database (const std::string&amp; name,
                int flags = SQLITE_OPEN_READWRITE,
                bool foreign_keys = true,
                std::auto_ptr&lt;connection_factory> = 0);

      database (int&amp; argc,
                char* argv[],
                bool erase = false,
                int flags = SQLITE_OPEN_READWRITE,
                bool foreign_keys = true,
                std::auto_ptr&lt;connection_factory> = 0);

      static void
      print_usage (std::ostream&amp;);

    public:
      const std::string&amp;
      name () const;

      int
      flags () const;

    public:
      transaction
      begin_immediate ();

      transaction
      begin_exclusive ();

    public:
      connection_ptr
      connection ();
    };
  }
}
  </pre>

  <p>You will need to include the <code>&lt;odb/sqlite/database.hxx></code>
     header file to make this class available in your application.</p>

  <p>The first constructor opens the specified SQLite database. The
     <code>name</code> argument is the database file
     name to open. If this argument is empty, then a temporary,
     on-disk database is created. If this argument is the
     <code>:memory:</code> special value, then a temporary, in-memory
     database is created. The <code>flags</code> argument allows us to
     specify SQLite opening flags. For more information on the possible
     values, refer to the <code>sqlite3_open_v2()</code> function description
     in the SQLite C API documentation. The <code>foreign_keys</code>
     argument specifies whether foreign key constraints checking
     should be enabled. See <a href="#13.5.3">Section 13.5.3,
     "Foreign Key Constraints"</a> for more information on foreign
     keys.</p>

  <p>The following example shows how we can open the <code>test.db</code>
     database in the read-write mode and create it if it does not exist:</p>

  <pre class="c++">
auto_ptr&lt;odb::database> db (
  new odb::sqlite::database (
    "test.db",
    SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE));
  </pre>

  <p>The second constructor extracts the database parameters from the
     command line. The following options are recognized:</p>

  <pre class="terminal">
  --database &lt;name>
  --create
  --read-only
  --options-file &lt;file>
  </pre>

  <p>By default, this constructor opens the database in the read-write mode
     (<code>SQLITE_OPEN_READWRITE</code> flag). If the <code>--create</code>
     flag is specified, then the database file is created if it does
     not already exist (<code>SQLITE_OPEN_CREATE</code> flag). If the
     <code>--read-only</code> flag is specified, then the database is
     opened in the read-only mode (<code>SQLITE_OPEN_READONLY</code>
     flag instead of <code>SQLITE_OPEN_READWRITE</code>). The
     <code>--options-file</code> option allows us to specify some
     or all of the database options in a file with each option appearing
     on a separate line followed by a space and an option value.</p>

  <p>If the <code>erase</code> argument to this constructor is true,
     then the above options are removed from the <code>argv</code>
     array and the <code>argc</code> count is updated accordingly.
     This is primarily useful if your application accepts other
     options or arguments and you would like to get the SQLite
     options out of the <code>argv</code> array.</p>

  <p>The <code>flags</code> argument has the same semantics as in
     the first constructor. Flags from the command line always override
     the corresponding values specified with this argument.</p>

  <p>The second constructor throws the <code>odb::sqlite::cli_exception</code>
     exception if the SQLite option values are missing or invalid.
     See <a href="#13.4">Section 13.4, "SQLite Exceptions"</a>
     for more information on this exception.</p>

  <p>The static <code>print_usage()</code> function prints the list of options
     with short descriptions that are recognized by the second constructor.</p>

  <p>The last argument to both constructors is a pointer to the connection
     factory. If we pass a non-<code>NULL</code> value, the database instance
     assumes ownership of the factory instance. The connection factory
     interface as well as the available implementations are described
     in the next section.</p>

  <p>The set of accessor functions following the constructors allows us
     to query the parameters of the <code>database</code> instance.</p>

  <p>The <code>begin_immediate()</code> and <code>begin_exclusive()</code>
     functions are the SQLite-specific extensions to the standard
     <code>odb::database::begin()</code> function (see
     <a href="#3.4">Section 3.4, "Transactions"</a>). They allow us
     to start an immediate (<code>BEGIN IMMEDIATE</code>) and an exclusive
     (<code>BEGIN EXCLUSIVE</code>) SQLite transaction, respectively.
     For more information on the semantics of the immediate and exclusive
     transactions, refer to the <code>BEGIN</code> statement description
     in the SQLite documentation.</p>

  <p>The <code>connection()</code> function returns a pointer to the
     SQLite database connection encapsulated by the
     <code>odb::sqlite::connection</code> class. For more information
     on <code>sqlite::connection</code>, refer to <a href="#13.3">Section
     13.3, "SQLite Connection and Connection Factory"</a>.</p>

  <h2><a name="13.3">13.3 SQLite Connection and Connection Factory</a></h2>

  <p>The <code>sqlite::connection</code> class has the following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace sqlite
  {
    class connection: public odb::connection
    {
    public:
      connection (database&amp;, int extra_flags = 0);
      connection (database&amp;, sqlite3*);

      transaction
      begin_immediate ();

      transaction
      begin_exclusive ();

      sqlite3*
      handle ();
    };

    typedef details::shared_ptr&lt;connection> connection_ptr;
  }
}
  </pre>

  <p>For more information on the <code>odb::connection</code> interface,
     refer to <a href="#3.5">Section 3.5, "Connections"</a>. The first
     overloaded <code>sqlite::connection</code> constructor opens
     a new SQLite connection. The <code>extra_flags</code> argument can
     be used to specify extra <code>sqlite3_open_v2()</code> flags
     that are combined with the flags specified in the
     <code>sqlite::database</code> constructor. The second constructor
     allows us to create a <code>connection</code> instance by providing
     an already open native SQLite handle. Note that the
     <code>connection</code> instance assumes ownership of this handle.</p>

  <p>The <code>begin_immediate()</code> and <code>begin_exclusive()</code>
     functions allow us to start an immediate and an exclusive SQLite
     transaction on the connection, respectively. Their semantics are
     equivalent to the corresponding functions defined in the
     <code>sqlite::database</code> class (<a href="#13.2">Section 13.2,
     "SQLite Database Class"</a>). The <code>handle()</code> accessor
     returns the SQLite handle corresponding to the connection.</p>

  <p>The <code>sqlite::connection_factory</code> abstract class has the
     following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace sqlite
  {
    class connection_factory
    {
    public:
      virtual void
      database (database&amp;) = 0;

      virtual connection_ptr
      connect () = 0;
    };
  }
}
  </pre>

  <p>The <code>database()</code> function is called when a connection
     factory is associated with a database instance. This happens in
     the <code>odb::sqlite::database</code> class constructors. The
     <code>connect()</code> function is called whenever a database
     connection is requested.</p>

  <p>The three implementations of the <code>connection_factory</code>
     interface provided by the SQLite ODB runtime library are
     <code>single_connection_factory</code>,
     <code>new_connection_factory</code>, and
     <code>connection_pool_factory</code>. You will need to include
     the <code>&lt;odb/sqlite/connection-factory.hxx></code>
     header file to make the <code>connection_factory</code> interface
     and these implementation classes available in your application.</p>

  <p>The <code>single_connection_factory</code> class creates a
     single connection that is shared between all the threads in
     an application. If the connection is currently not in use,
     then it is returned to the caller. Otherwise, the caller is
     blocked until the connection becomes available. The
     <code>single_connection_factory</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  namespace sqlite
  {
    class single_connection_factory: public connection_factory
    {
    public:
      single_connection_factory ();

    protected:
      class single_connection: public connection
      {
      public:
        single_connection (database_type&amp;);
        single_connection (database_type&amp;, MYSQL*);
      };

      typedef details::shared_ptr&lt;single_connection> single_connection_ptr;

      virtual single_connection_ptr
      create ();
    };
};
  </pre>

  <p>The <code>create()</code> virtual function is called when the
     factory needs to create the connection. By deriving from the
     <code>single_connection_factory</code> class and overriding this
     function we can implement custom connection establishment
     and configuration.</p>

  <p>The <code>new_connection_factory</code> class creates a new
     connection whenever one is requested. When a connection is no
     longer needed, it is released and closed. The
     <code>new_connection_factory</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  namespace sqlite
  {
    class new_connection_factory: public connection_factory
    {
    public:
      new_connection_factory ();
    };
};
  </pre>

  <p>The <code>connection_pool_factory</code> class implements a
     connection pool. It has the following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace sqlite
  {
    class connection_pool_factory: public connection_factory
    {
    public:
      connection_pool_factory (std::size_t max_connections = 0,
                               std::size_t min_connections = 0);

    protected:
      class pooled_connection: public connection
      {
      public:
        pooled_connection (database_type&amp;, int extra_flags = 0);
        pooled_connection (database_type&amp;, sqlite3*);
      };

      typedef details::shared_ptr&lt;pooled_connection> pooled_connection_ptr;

      virtual pooled_connection_ptr
      create ();
    };
};
  </pre>

  <p>The <code>max_connections</code> argument in the
     <code>connection_pool_factory</code> constructor specifies the maximum
     number of concurrent connections that this pool factory will
     maintain. Similarly, the <code>min_connections</code> argument
     specifies the minimum number of available connections that
     should be kept open.</p>

  <p>Whenever a connection is requested, the pool factory first
     checks if there is an unused connection that can be returned.
     If there is none, the pool factory checks the
     <code>max_connections</code> value to see if a new connection
     can be created. If the total number of connections maintained
     by the pool is less than this value, then a new connection is
     created and returned. Otherwise, the caller is blocked until
     a connection becomes available.</p>

  <p>When a connection is released, the pool factory first checks
     if there are blocked callers waiting for a connection. If so, then
     one of them is unblocked and is given the connection. Otherwise,
     the pool factory checks whether the total number of connections
     maintained by the pool is greater than the <code>min_connections</code>
     value. If that's the case, the connection is closed. Otherwise, the
     connection is added to the pool of available connections to be
     returned on the next request. In other words, if the number of
     connections maintained by the pool exceeds <code>min_connections</code>
     and there are no callers waiting for a new connection,
     then the pool will close the excess connections.</p>

  <p>If the <code>max_connections</code> value is 0, then the pool will
     create a new connection whenever all of the existing connections
     are in use. If the <code>min_connections</code> value is 0, then
     the pool will never close a connection and instead maintain all
     the connections that were ever created.</p>

  <p>The <code>create()</code> virtual function is called whenever the
     pool needs to create a new connection. By deriving from the
     <code>connection_pool_factory</code> class and overriding this
     function we can implement custom connection establishment
     and configuration.</p>

  <p>By default, connections created by <code>new_connection_factory</code>
     and <code>connection_pool_factory</code> enable the SQLite shared cache
     mode and use the unlock notify functionality to aid concurrency. To
     disable the shared cache mode you can pass the
     <code>SQLITE_OPEN_PRIVATECACHE</code> flag when creating the database
     instance. For more information on the shared cache mode refer to the
     SQLite documentation.</p>

  <p>If you pass <code>NULL</code> as the connection factory to one of the
     <code>database</code> constructors, then the <code>connection_pool_factory</code>
     instance will be created by default with the min and max connections
     values set to <code>0</code>. The following code fragment shows how we
     can pass our own connection factory instance:</p>

  <pre class="c++">
#include &lt;odb/database.hxx>

#include &lt;odb/sqlite/database.hxx>
#include &lt;odb/sqlite/connection-factory.hxx>

int
main (int argc, char* argv[])
{
  auto_ptr&lt;odb::sqlite::connection_factory> f (
    new odb::sqlite::connection_pool_factory (20));

  auto_ptr&lt;odb::database> db (
    new sqlite::database (argc, argv, false, SQLITE_OPEN_READWRITE, f));
}
  </pre>

  <h2><a name="13.4">13.4 SQLite Exceptions</a></h2>

  <p>The SQLite ODB runtime library defines the following SQLite-specific
     exceptions:</p>

  <pre class="c++">
namespace odb
{
  namespace sqlite
  {
    class database_exception: odb::database_exception
    {
    public:
      int
      error () const

      int
      extended_error () const;

      const std::string&amp;
      message () const;

      virtual const char*
      what () const throw ();
    };

    class cli_exception: odb::exception
    {
    public:
      virtual const char*
      what () const throw ();
    };
  }
}
  </pre>

  <p>You will need to include the <code>&lt;odb/sqlite/exceptions.hxx></code>
     header file to make these exceptions available in your application.</p>

  <p>The <code>odb::sqlite::database_exception</code> is thrown if
     an SQLite database operation fails. The SQLite-specific error
     information is accessible via the <code>error()</code>,
     <code>extended_error()</code>, and <code>message()</code> functions.
     All this information is also combined and returned in a
     human-readable form by the <code>what()</code> function.</p>

  <p>The <code>odb::sqlite::cli_exception</code> is thrown by the
     command line parsing constructor of the <code>odb::sqlite::database</code>
     class if the SQLite option values are missing or invalid. The
     <code>what()</code> function returns a human-readable description
     of an error.</p>


  <h2><a name="13.5">13.5 SQLite Limitations</a></h2>

  <p>The following sections describe SQLite-specific limitations imposed by
     the current SQLite and ODB runtime versions.</p>

  <h3><a name="13.5.1">13.5.1 Query Result Caching</a></h3>

  <p>SQLite ODB runtime implementation does not perform query result caching
     (<a href="#4.4">Section 4.4, "Query Result"</a>) even when explicitly
     requested. The SQLite API supports interleaving execution of multiple
     prepared statements on a single connection. As a result, with SQLite, it
     is possible to have multiple uncached results and calls to other database
     functions do not invalidate them. The only limitation of the uncached
     SQLite results is the unavailability of the <code>result::size()</code>
     function. If you call this function on an SQLite query result, then
     the <code>odb::result_not_cached</code> exception
     (<a href="#3.12">Section 3.12, "ODB Exceptions"</a>) is always
     thrown. Future versions of the SQLite ODB runtime library may add support
     for result caching.</p>

  <h3><a name="13.5.2">13.5.2 Automatic Assignment of Object Ids</a></h3>

  <p>Due to SQLite API limitations, every automatically assigned object id
     (<a href="#11.4.2">Section 11.4.2, "<code>auto</code>"</a>) should have
     the <code>INTEGER</code> SQLite type. While SQLite will treat other
     integer type names (such as <code>INT</code>, <code>BIGINT</code>, etc.)
     as <code>INTEGER</code>, automatic id assignment will not work. By default,
     ODB maps all C++ integral types to <code>INTEGER</code>. This means that
     the only situation that requires consideration is the assignment of a
     custom database type using the <code>db&nbsp;type</code> pragma
     (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>). For
     example:</p>

<pre class="c++">
#pragma db object
class person
{
  ...

  //#pragma db id auto type("INT")     // Will not work.
  //#pragma db id auto type("INTEGER") // Ok.
  #pragma db id auto                   // Ok, Mapped to INTEGER.
  unsigned int id_;
};
</pre>

  <h3><a name="13.5.3">13.5.3 Foreign Key Constraints</a></h3>

  <p>By default the SQLite ODB runtime enables foreign key constraints
     checking (<code>PRAGMA foreign_keys=ON</code>). You can disable foreign
     keys by passing <code>false</code> as the <code>foreign_keys</code>
     argument to one of the <code>odb::sqlite::database</code> constructors.
     Foreign keys will also be disabled if the SQLite library is built without
     support for foreign keys (<code>SQLITE_OMIT_FOREIGN_KEY</code> and
     <code>SQLITE_OMIT_TRIGGER</code> macros) or if you are using
     an SQLite version prior to 3.6.19, which does not support foreign
     key constraints checking.</p>

  <p>If foreign key constraints checking is disabled or not available,
     then inconsistencies in object relationships will not be detected.
     Furthermore, using the <code>erase_query()</code> function
     (<a href="#3.10">Section 3.10, "Deleting Persistent Objects"</a>)
     to delete persistent objects that contain containers will not work
     correctly. Container data for such objects will not be deleted.</p>

  <p>When foreign key constraints checking is enabled, then you may
     get the "foreign key constraint failed" error while re-creating the
     database schema. This error is due to bugs in the SQLite DDL foreign
     keys support. The recommended work-around for this problem is to
     temporarily disable foreign key constraints checking while
     re-creating the schema. The following code fragment shows how
     this can be done:</p>

<pre>
#include &lt;odb/connection.hxx>
#include &lt;odb/transaction.hxx>
#include &lt;odb/schema-catalog.hxx>

odb::database&amp; db = ...

{
  odb::connection_ptr c (db.connection ());

  c->execute ("PRAGMA foreign_keys=OFF");

  odb::transaction t (c->begin ());
  odb::schema_catalog::create_schema (db);
  t.commit ();

  c->execute ("PRAGMA foreign_keys=ON");
}
</pre>

  <p>Finally, ODB relies on standard SQL behavior which requires
     that foreign key constraints checking is deferred until the
     transaction is committed. Default SQLite behavior is to check such
     constraints immediately. As a result, when used with ODB, a custom
     database schema that defines foreign key constraints must declare
     such constraints as <code>DEFERRABLE INITIALLY DEFERRED</code>, as
     shown in the following example. Schemas generated by the ODB compiler
     meet this requirement automatically.</p>

  <pre class="sql">
CREATE TABLE Employee (
  ...
  employer BIGINT REFERENCES Employer (name) DEFERRABLE INITIALLY DEFERRED);
  </pre>


  <h3><a name="13.5.4">13.5.4 Constraint Violations</a></h3>

  <p>Due to the granularity of the SQLite error codes, it is impossible
     to distinguish between the duplicate primary key and other constraint
     violations. As a result, when making an object persistent, The SQLite
     ODB runtime will translate all constraint violation errors to the
     <code>object_not_persistent</code> exception (<a href="#3.12">Section
     3.12, "ODB Exceptions"</a>).</p>

  <h3><a name="13.5.5">13.5.5 Sharing of Queries</a></h3>

  <p>As discussed in <a href="#4.3">Section 4.3, "Executing a Query"</a>, a
     query instance that does not have any by-reference parameters is
     immutable and can be shared between multiple threads without
     synchronization. Currently, the SQLite ODB runtime does not support this
     functionality. Future versions of the library will remove this
     limitation.</p>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="14">14 PostgreSQL Database</a></h1>

  <p>To generate support code for the PostgreSQL database you will need
     to pass the "<code>--database&nbsp;pgsql</code>"
     (or "<code>-d&nbsp;pgsql</code>") option to the ODB compiler.
     Your application will also need to link to the PostgreSQL ODB runtime
     library (<code>libodb-pgsql</code>). All PostgreSQL-specific ODB
     classes are defined in the <code>odb::pgsql</code> namespace.</p>

  <p>ODB utilizes prepared statements extensively. Support for prepared
     statements was added in PostgreSQL version 7.4 with the introduction
     of the messaging protocol version 3.0. For this reason, ODB supports
     only PostgreSQL version 7.4 and later.</p>

  <h2><a name="14.1">14.1 PostgreSQL Type Mapping</a></h2>

  <p>The following table summarizes the default mapping between basic
     C++ value types and PostgreSQL database types. This mapping can be
     customized on the per-type and per-member basis using the ODB
     Pragma Language (<a href="#11">Chapter 11, "ODB Pragma
     Language"</a>).</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>C++ Type</th>
      <th>PostgreSQL Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>bool</code></td>
      <td><code>BOOLEAN</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>char</code></td>
      <td><code>SMALLINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>signed char</code></td>
      <td><code>SMALLINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned char</code></td>
      <td><code>SMALLINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>short</code></td>
      <td><code>SMALLINT NULL</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned short</code></td>
      <td><code>SMALLINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>int</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned int</code></td>
      <td><code>INTEGER</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>long</code></td>
      <td><code>BIGINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned long</code></td>
      <td><code>BIGINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>long long</code></td>
      <td><code>BIGINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>unsigned long long</code></td>
      <td><code>BIGINT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>float</code></td>
      <td><code>REAL</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>double</code></td>
      <td><code>DOUBLE PRECISION</code></td>
      <td><code>NOT NULL</code></td>
    </tr>

    <tr>
      <td><code>std::string</code></td>
      <td><code>TEXT</code></td>
      <td><code>NOT NULL</code></td>
    </tr>
  </table>

  <p>The PostgreSQL ODB runtime library also provides support for mapping the
     <code>std::vector&lt;char></code> type to the PostgreSQL <code>BYTEA</code>
     type. However, this mapping is not enabled by default (by default,
     <code>std::vector&lt;char></code> will be treated as a container).
     To enable the <code>BYTEA</code> mapping for this type we need to specify
     the database type explicitly using the <code>db&nbsp;type</code>
     pragma (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>),
     for example:</p>

  <pre class="c++">
#pragma db object
class object
{
  ...

  #pragma db type("BYTEA")
  std::vector&lt;char> buf_;
};
  </pre>

  <p>Alternatively, this can be done on the per-type basis, for example:</p>

  <pre class="c++">
typedef std::vector&lt;char> buffer;
#pragma db value(buffer) type("BYTEA")

#pragma db object
class object
{
  ...

  buffer buf_; // Mapped to BYTEA.
};
  </pre>

  <p>Additionally, by default, C++ enumerations are automatically
     mapped to <code>INTEGER</code> with the default <code>NULL</code>
     semantics being <code>NOT NULL</code>.</p>

  <p>Note also that because PostgreSQL does not support unsigned integers,
     the <code>unsigned short</code>, <code>unsigned int</code>, and
     <code>unsigned long long</code> C++ types are by default mapped
     to the <code>SMALLINT</code>, <code>INTEGER</code>, and
     <code>BIGINT</code> PostgreSQL types, respectively. The sign bit
     of the value stored by the database for these types will contain
     the most significant bit of the actual unsigned value being
     persisted.</p>

  <h2><a name="14.2">14.2 PostgreSQL Database Class</a></h2>

  <p>The PostgreSQL <code>database</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  namespace pgsql
  {
    class database: public odb::database
    {
    public:
      database (const std::string&amp; user,
                const std::string&amp; password,
                const std::string&amp; db,
                const std::string&amp; host = "",
                unsigned int port = 0,
                const std::string&amp; extra_conninfo = "",
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; user,
                const std::string&amp; password,
                const std::string&amp; db,
                const std::string&amp; host = "",
                const std::string&amp; socket_ext = "",
                const std::string&amp; extra_conninfo = "",
                std::auto_ptr&lt;connection_factory> = 0);

      database (const std::string&amp; conninfo,
                std::auto_ptr&lt;connection_factory> = 0);

      database (int&amp; argc,
                char* argv[],
                bool erase = false,
                const std::string&amp; extra_conninfo = "",
                std::auto_ptr&lt;connection_factory> = 0);

      static void
      print_usage (std::ostream&amp;);


    public:
      const std::string&amp;
      user () const;

      const std::string&amp;
      password () const;

      const std::string&amp;
      db () const;

      const std::string&amp;
      host () const;

      unsigned int
      port () const;

      const std::string&amp;
      socket_ext () const;

      const std::string&amp;
      extra_conninfo () const;

      const std::string&amp;
      conninfo () const;

    public:
      connection_ptr
      connection ();
    };
  }
}
  </pre>

  <p>You will need to include the <code>&lt;odb/pgsql/database.hxx></code>
     header file to make this class available in your application.</p>

  <p>The overloaded <code>database</code> constructors allow us to specify
     the PostgreSQL database parameters that should be used when connecting
     to the database. The <code>port</code> argument in the first constructor
     is an integer value specifying the TCP/IP port number to connect to. A
     zero port number indicates that the default port should be used.
     The <code>socket_ext</code> argument in the second constructor is a
     string value specifying the UNIX-domain socket file name extension.</p>

  <p>The third constructor allows us to specify all the database parameters
     as a single <code>conninfo</code> string. All other constructors
     accept additional database connection parameters as the
     <code>extra_conninfo</code> argument. For more information
     about the format of the <code>conninfo</code> string, refer to
     the <code>PQconnectdb()</code> function description in the PostgreSQL
     documentation. In the case of <code>extra_conninfo</code>, all the
     database parameters provided in this string will take precedence
     over those explicitly specified with other constructor arguments.</p>

  <p>The last constructor extracts the database parameters
     from the command line. The following options are recognized:</p>

  <pre class="terminal">
  --user &lt;login> | --username &lt;login>
  --password &lt;password>
  --database &lt;name> | --dbname &lt;name>
  --host &lt;host>
  --port &lt;integer>
  --options-file &lt;file>
  </pre>

  <p>The <code>--options-file</code> option allows us to specify some
     or all of the database options in a file with each option appearing
     on a separate line followed by a space and an option value.</p>

  <p>If the <code>erase</code> argument to this constructor is true,
     then the above options are removed from the <code>argv</code>
     array and the <code>argc</code> count is updated accordingly.
     This is primarily useful if your application accepts other
     options or arguments and you would like to get the PostgreSQL
     options out of the <code>argv</code> array.</p>

  <p>This constructor throws the <code>odb::pgsql::cli_exception</code>
     exception if the PostgreSQL option values are missing or invalid.
     See section <a href="#14.4">Section 14.4, "PostgreSQL Exceptions"</a>
     for more information on this exception.</p>

  <p>The static <code>print_usage()</code> function prints the list of options
     with short descriptions that are recognized by this constructor.</p>

  <p>The last argument to all of the constructors is a pointer to the
     connection factory. If we pass a non-<code>NULL</code> value, the
     database instance assumes ownership of the factory instance. The
     connection factory interface as well as the available implementations
     are described in the next section.</p>

  <p>The set of accessor functions following the constructors allows us
     to query the parameters of the <code>database</code> instance. Note that
     the <code>conninfo()</code> accessor returns a complete
     <code>conninfo</code> string which includes parameters that were
     explicitly specified with the various constructor arguments, as well as
     the extra parameters passed in the <code>extra_conninfo</code> argument.
     The <code>extra_conninfo()</code> accessor will return the
     <code>conninfo</code> string as passed in the <code>extra_conninfo</code>
     argument.</p>

  <p>The <code>connection()</code> function returns a pointer to the
     PostgreSQL database connection encapsulated by the
     <code>odb::pgsql::connection</code> class. For more information
     on <code>pgsql::connection</code>, refer to <a href="#14.3">Section
     14.3, "PostgreSQL Connection and Connection Factory"</a>.</p>

  <h2><a name="14.3">14.3 PostgreSQL Connection and Connection Factory</a></h2>

  <p>The <code>pgsql::connection</code> class has the following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace pgsql
  {
    class connection: public odb::connection
    {
    public:
      connection (database&amp;);
      connection (database&amp;, PGconn*);

      PGconn*
      handle ();
    };

    typedef details::shared_ptr&lt;connection> connection_ptr;
  }
}
  </pre>

  <p>For more information on the <code>odb::connection</code> interface,
     refer to <a href="#3.5">Section 3.5, "Connections"</a>. The first
     overloaded <code>pgsql::connection</code> constructor establishes a
     new PostgreSQL connection. The second constructor allows us to create
     a <code>connection</code> instance by providing an already connected
     native PostgreSQL handle. Note that the <code>connection</code>
     instance assumes ownership of this handle. The <code>handle()</code>
     accessor returns the PostgreSQL handle corresponding to the connection.</p>

  <p>The <code>pgsql::connection_factory</code> abstract class has the
     following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace pgsql
  {
    class connection_factory
    {
    public:
      virtual void
      database (database&amp;) = 0;

      virtual connection_ptr
      connect () = 0;
    };
  }
}
  </pre>

  <p>The <code>database()</code> function is called when a connection
     factory is associated with a database instance. This happens in
     the <code>odb::pgsql::database</code> class constructors. The
     <code>connect()</code> function is called whenever a database
     connection is requested.</p>

  <p>The two implementations of the <code>connection_factory</code>
     interface provided by the PostgreSQL ODB runtime are
     <code>new_connection_factory</code> and
     <code>connection_pool_factory</code>. You will need to include
     the <code>&lt;odb/pgsql/connection-factory.hxx></code>
     header file to make the <code>connection_factory</code> interface
     and these implementation classes available in your application.</p>

  <p>The <code>new_connection_factory</code> class creates a new
     connection whenever one is requested. When a connection is no
     longer needed, it is released and closed. The
     <code>new_connection_factory</code> class has the following
     interface:</p>

  <pre class="c++">
namespace odb
{
  namespace pgsql
  {
    class new_connection_factory: public connection_factory
    {
    public:
      new_connection_factory ();
    };
};
  </pre>

  <p>The <code>connection_pool_factory</code> class implements a
     connection pool. It has the following interface:</p>

  <pre class="c++">
namespace odb
{
  namespace pgsql
  {
    class connection_pool_factory: public connection_factory
    {
    public:
      connection_pool_factory (std::size_t max_connections = 0,
                               std::size_t min_connections = 0);

    protected:
      class pooled_connection: public connection
      {
      public:
        pooled_connection (database_type&amp;);
        pooled_connection (database_type&amp;, PGconn*);
      };

      typedef details::shared_ptr&lt;pooled_connection> pooled_connection_ptr;

      virtual pooled_connection_ptr
      create ();
    };
};
  </pre>

  <p>The <code>max_connections</code> argument in the
     <code>connection_pool_factory</code> constructor specifies the maximum
     number of concurrent connections that this pool factory will
     maintain. Similarly, the <code>min_connections</code> argument
     specifies the minimum number of available connections that
     should be kept open.</p>

  <p>Whenever a connection is requested, the pool factory first
     checks if there is an unused connection that can be returned.
     If there is none, the pool factory checks the
     <code>max_connections</code> value to see if a new connection
     can be created. If the total number of connections maintained
     by the pool is less than this value, then a new connection is
     created and returned. Otherwise, the caller is blocked until
     a connection becomes available.</p>

  <p>When a connection is released, the pool factory first checks
     if there are blocked callers waiting for a connection. If so, then
     one of them is unblocked and is given the connection. Otherwise,
     the pool factory checks whether the total number of connections
     maintained by the pool is greater than the <code>min_connections</code>
     value. If that's the case, the connection is closed. Otherwise, the
     connection is added to the pool of available connections to be
     returned on the next request. In other words, if the number of
     connections maintained by the pool exceeds <code>min_connections</code>
     and there are no callers waiting for a new connection,
     the pool will close the excess connections.</p>

  <p>If the <code>max_connections</code> value is 0, then the pool will
     create a new connection whenever all of the existing connections
     are in use. If the <code>min_connections</code> value is 0, then
     the pool will never close a connection and instead maintain all
     the connections that were ever created.</p>

  <p>The <code>create()</code> virtual function is called whenever the
     pool needs to create a new connection. By deriving from the
     <code>connection_pool_factory</code> class and overriding this
     function we can implement custom connection establishment
     and configuration.</p>

  <p>If you pass <code>NULL</code> as the connection factory to one of the
     <code>database</code> constructors, then the
     <code>connection_pool_factory</code> instance will be created by default
     with the min and max connections values set to <code>0</code>. The
     following code fragment shows how we can pass our own connection factory
     instance:</p>

  <pre class="c++">
#include &lt;odb/database.hxx>

#include &lt;odb/pgsql/database.hxx>
#include &lt;odb/pgsql/connection-factory.hxx>

int
main (int argc, char* argv[])
{
  auto_ptr&lt;odb::pgsql::connection_factory> f (
    new odb::pgsql::connection_pool_factory (20));

  auto_ptr&lt;odb::database> db (
    new pgsql::database (argc, argv, false, "", f));
}
  </pre>

  <h2><a name="14.4">14.4 PostgreSQL Exceptions</a></h2>

  <p>The PostgreSQL ODB runtime library defines the following
     PostgreSQL-specific exceptions:</p>

  <pre class="c++">
namespace odb
{
  namespace pgsql
  {
    class database_exception: odb::database_exception
    {
    public:
      const std::string&amp;
      message () const;

      const std::string&amp;
      sqlstate () const;

      virtual const char*
      what () const throw ();
    };

    class cli_exception: odb::exception
    {
    public:
      virtual const char*
      what () const throw ();
    };
  }
}
  </pre>

  <p>You will need to include the <code>&lt;odb/pgsql/exceptions.hxx></code>
     header file to make these exceptions available in your application.</p>

  <p>The <code>odb::pgsql::database_exception</code> is thrown if
     a PostgreSQL database operation fails. The PostgreSQL-specific error
     information is accessible via the <code>message()</code> and
     <code>sqlstate()</code> functions. All this information is also
     combined and returned in a human-readable form by the <code>what()</code>
     function.</p>

  <p>The <code>odb::pgsql::cli_exception</code> is thrown by the
     command line parsing constructor of the <code>odb::pgsql::database</code>
     class if the PostgreSQL option values are missing or invalid. The
     <code>what()</code> function returns a human-readable description
     of an error.</p>

  <h2><a name="14.5">14.5 PostgreSQL Limitations</a></h2>

  <p>The following sections describe PostgreSQL-specific limitations imposed
     by the current PostgreSQL and ODB runtime versions.</p>

  <h3><a name="14.5.1">14.5.1 Query Result Caching</a></h3>

  <p>The PostgreSQL ODB runtime implementation will always return a
     cached query result (<a href="#4.4">Section 4.4, "Query Result"</a>)
     even when explicitly requested not to. This is a limitation of the
     PostgreSQL client library (<code>libpq</code>) which does not
     support uncached (streaming) query results.</p>

  <h3><a name="14.5.2">14.5.2 Foreign Key Constraints</a></h3>

  <p>ODB relies on standard SQL behavior which requires that
     foreign key constraints checking is deferred until the
     transaction is committed. Default PostgreSQL behavior is
     to check such constraints immediately. As a result, when
     used with ODB, a custom database schema that defines foreign
     key constraints must declare such constraints as
     <code>INITIALLY DEFERRED</code>, as shown in the following example.
     Schemas generated by the ODB compiler meet this requirement
     automatically.</p>

  <pre class="sql">
CREATE TABLE Employee (
  ...
  employer BIGINT REFERENCES Employer (name) INITIALLY DEFERRED);
  </pre>

  <h3><a name="14.5.3">14.5.3 Date-Time Format</a></h3>

  <p>ODB expects the PostgreSQL server to use integers as a binary
     format for the date-time types, which is the default for most
     PostgreSQL configurations. When creating a connection, ODB
     examines the <code>integer_datetimes</code> PostgreSQL server
     parameter and if it is <code>false</code>,
     <code>odb::pgsql::database_exception</code> is thrown. You may
     check the value of this parameter for your server by executing
     the following SQL query:</p>

  <pre class="sql">
SHOW integer_datetimes
  </pre>

  <h3><a name="14.5.4">14.5.4 Timezones</a></h3>

  <p>ODB does not currently support the PostgreSQL date-time types
     with timezone information.</p>

  <h3><a name="14.5.5">14.5.5 <code>NUMERIC</code> Type Support</a></h3>

  <p>Support for the PostgreSQL <code>NUMERIC</code> type is limited
     to providing a binary buffer containing the binary representation
     of the value. For more information on the binary format used to
     store <code>NUMERIC</code> values refer to the PostgreSQL
     documentation.</p>

  <!-- PART -->


  <hr class="page-break"/>
  <h1><a name="III">PART III&nbsp;&nbsp;
      <span style="font-weight: normal;">PROFILES</span></a></h1>

  <p>Part III covers the integration of ODB with popular C++ frameworks
     and libraries. It consists of the following chapters.</p>

  <table class="toc">
    <tr><th>15</th><td><a href="#15">Profiles Introduction</a></td></tr>
    <tr><th>16</th><td><a href="#16">Boost Profile</a></td></tr>
    <tr><th>17</th><td><a href="#17">Qt Profile</a></td></tr>
  </table>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="15">15 Profiles Introduction</a></h1>

  <p>ODB profiles are a generic mechanism for integrating ODB with
     widely-used C++ frameworks and libraries. A profile provides glue
     code which allows you to seamlessly persist various components, such
     as smart pointers, containers, and value types found in these
     frameworks or libraries. The code necessary to implement a profile
     is packaged into the so called profile library. For example, the
     Boost profile implementation is provided by the <code>libodb-boost</code>
     profile library.</p>

  <p>Besides linking the profile library to our application, it is also
     necessary to let the ODB compiler know which profiles we
     are using. This is accomplished with the <code>--profile</code>
     (or <code>-p</code> alias) option. For example:</p>

  <pre class="terminal">
odb --profile boost ...
  </pre>

  <p>Some profiles, especially those covering frameworks or libraries that
     consist of multiple sub-libraries, provide sub-profiles that allow you
     to pick and choose which components you would like to use in your
     application. For example, the <code>boost</code> profile contains
     the <code>boost/data-time</code> sub-profile. If we are only
     interested in the <code>date_time</code> types, then we can
     pass <code>boost/data-time</code> instead of <code>boost</code>
     to the <code>--profile</code> option, for example:</p>

  <pre class="terminal">
odb --profile boost/date-time ...
  </pre>

  <p>To summarize, you will need to perform the following steps in order
     to make use of a profile in your application:</p>

  <ol>
    <li>ODB compiler: if necessary, specify the path to the profile library
        headers (<code>-I</code> option).</li>
    <li>ODB compiler: specify the profile you would like to use with
        the <code>--profile</code> option.</li>
    <li>C++ compiler: if necessary, specify the path to the profile library
        headers (normally <code>-I</code> option).</li>
    <li>Linker: link the profile library to the application.</li>
  </ol>

  <p>The remaining chapters in this part of the manual describe the
     standard profiles provided by ODB.</p>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="16">16 Boost Profile</a></h1>

  <p>The ODB profile implementation for Boost is provided by the
     <code>libodb-boost</code> library and consists of multiple sub-profiles
     corresponding to the individual Boost libraries. To enable all the
     available Boost sub-profiles, pass <code>boost</code> as the profile
     name to the <code>--profile</code> ODB compiler option. Alternatively,
     you can enable only specific sub-profiles by passing individual
     sub-profile names to <code>--profile</code>. The following sections in
     this chapter discuss each Boost sub-profile in detail. The
     <code>boost</code> example in the <code>odb-examples</code>
     package shows how to enable and use the Boost profile.</p>

  <p>Some sub-profiles may throw exceptions to indicate error conditions,
     such as the inability to store a specific value in a particular database
     system. All such exceptions derive from the
     <code>odb::boost::exception</code> class which in turn derives from
     the root of the ODB exception hierarchy, class <code>odb::exception</code>
     (<a href="#3.12">Section 3.12, "ODB Exceptions"</a>). The
     <code>odb::boost::exception</code> class is defined in the
     <code>&lt;odb/boost/exception.hxx></code> header file and has the
     same interface as <code>odb::exception</code>. The concrete exceptions
     that can be thrown by the Boost sub-profiles are described in the
     following sections.</p>

  <h2><a name="16.1">16.1 Smart Pointers Library</a></h2>

  <p>The <code>smart-ptr</code> sub-profile provides persistence
     support for a subset of smart pointers from the Boost
     <code>smart_ptr</code> library. To enable only this profile,
     pass <code>boost/smart-ptr</code> to the <code>--profile</code>
     ODB compiler option.</p>

  <p>The currently supported smart pointers are
     <code>boost::shared_ptr</code> and <code>boost::weak_ptr</code>. For
     more information on using smart pointers as pointers to objects and
     views, refer to <a href="#3.2">Section 3.2, "Object and View Pointers"</a>
     and <a href="#6">Chapter 6, "Relationships"</a>. For more information
     on using smart pointers as pointers to values, refer to
     <a href="#7.3">Section 7.3, "Pointers and <code>NULL</code> Value
     Semantics"</a>. When used as a pointer to a value, only
     <code>boost::shared_ptr</code> is supported. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db null
  boost::shared_ptr&lt;std::string> middle_name_;
};
  </pre>

  <p>To provide finer grained control over object relationship loading,
     the <code>smart-ptr</code> sub-profile also provides the lazy
     counterparts for the above  pointers: <code>odb::boost::lazy_shared_ptr</code> and
     <code>odb::boost::lazy_weak_ptr</code>. You will need to include the
     <code>&lt;odb/boost/lazy-ptr.hxx></code> header file to make the lazy
     variants available in your application. For the description of the lazy
     pointer interface and semantics refer to <a href="#6.3">Section 6.3,
     "Lazy Pointers"</a>. The following example shows how we can use these
     smart pointers to establish a relationship between persistent objects.</p>

<pre class="c++">
class employee;

#pragma db object
class position
{
  ...

  #pragma db inverse(position_)
  odb::boost::lazy_weak_ptr&lt;employee> employee_;
};

#pragma db object
class employee
{
  ...

  #pragma db not_null
  boost::shared_ptr&lt;position> position_;
};
</pre>

  <p>Besides providing persistence support for the above smart pointers,
     the <code>smart-ptr</code> sub-profile also changes the default
     pointer (<a href="#3.2">Section 3.2, "Object and View Pointers"</a>)
     to <code>boost::shared_ptr</code>. In particular, this means that
     database functions that return dynamically allocated objects and views
     will return them as <code>boost::shared_ptr</code> pointers.  To override
     this behavior, add the <code>--default-pointer</code> option specifying
     the alternative pointer type after the <code>--profile</code> option.</p>

  <h2><a name="16.2">16.2 Unordered Containers Library</a></h2>

  <p>The <code>unordered</code> sub-profile provides persistence support for
     the containers from the Boost <code>unordered</code> library. To enable
     only this profile, pass <code>boost/unordered</code> to
     the <code>--profile</code> ODB compiler option.</p>

  <p>The supported containers are <code>boost::unordered_set</code>,
     <code>boost::unordered_map</code>, <code>boost::unordered_multiset</code>,
     and <code>boost::unordered_multimap</code>. For more information on using
     the set and multiset containers with ODB refer to <a href="#5.2">Section
     5.2, "Set and Multiset Containers"</a>. For more information on using the
     map and multimap containers with ODB refer to <a href="#5.3"> Section
     5.3, "Map and Multimap Containers"</a>. The following example shows how
     the <code>unordered_set</code> container may be used within a persistent
     object.</p>

<pre class="c++">
#pragma db object
class person
{
  ...
  boost::unordered_set&lt;std::string&gt; emails_;
};
</pre>

  <h2><a name="16.3">16.3 Optional Library</a></h2>

  <p>The <code>optional</code> sub-profile provides persistence support for
     the <code>boost::optional</code> container from the Boost
     <code>optional</code> library. To enable only this profile, pass
     <code>boost/optional</code> to the <code>--profile</code> ODB compiler
     option.</p>

  <p>In a relational database <code>boost::optional</code> is mapped to
     a column that can have a <code>NULL</code> value. Similar to
     <code>odb::nullable</code> (<a href="#7.3">Section 7.3, "Pointers and
     <code>NULL</code> Value Semantics"</a>), it can be used to add the
     <code>NULL</code> semantics to existing C++ types. For example:</p>

  <pre class="c++">
#include &lt;boost/optional.hpp>

#pragma db object
class person
{
  ...

  std::string first_;                    // TEXT NOT NULL
  boost::optional&lt;std::string> middle_;  // TEXT NULL
  std::string last_;                     // TEXT NOT NULL
};
  </pre>

  <p>Note also that similar to <code>odb::nullable</code>, when
     this profile is used, the <code>NULL</code> values are automatically
     enabled for data members of the  <code>boost::optional</code> type.</p>

  <h2><a name="16.4">16.4 Date Time Library</a></h2>

  <p>The <code>date-time</code> sub-profile provides persistence support for a
     subset of types from the Boost <code>date_time</code> library. It is
     further subdivided into two sub-profiles, <code>gregorian</code>
     and <code>posix_time</code>. The <code>gregorian</code> sub-profile
     provides support for types from the <code>boost::gregorian</code>
     namespace, while the <code>posix-time</code> sub-profile provides support
     for types from the <code>boost::posix_time</code> namespace. To enable
     the entire <code>date-time</code> sub-profile, pass
     <code>boost/date-time</code> to the <code>--profile</code> ODB compiler
     option. To enable only the <code>gregorian</code> sub-profile, pass
     <code>boost/date-time/gregorian</code>, and to enable only the
     <code>posix-time</code> sub-profile, pass
     <code>boost/date-time/posix-time</code>.</p>

  <p>The only type that the <code>gregorian</code> sub-profile currently
     supports is <code>gregorian::date</code>. The types currently supported
     by the <code>posix-time</code> sub-profile are
     <code>posix_time::ptime</code> and
     <code>posix_time::time_duration</code>. The manner in which these types
     are persisted is database system dependent and is discussed in the
     sub-sections that follow. The example below shows how
     <code>gregorian::date</code> may be used within a persistent object.</p>

<pre class="c++">
#pragma db object
class person
{
  ...
  boost::gregorian::date date_of_birth_;
};
</pre>

  <p>The concrete exceptions that can be thrown by the <code>date-time</code>
     sub-profile implementation are presented below.</p>


<pre class="c++">
namespace odb
{
  namespace boost
  {
    namespace date_time
    {
      struct special_value: odb::boost::exception
      {
        virtual const char*
        what () const throw ();
      };

      struct value_out_of_range: odb::boost::exception
      {
        virtual const char*
        what () const throw ();
      };
    }
  }
}
</pre>

  <p>You will need to include the
     <code>&lt;odb/boost/date-time/exceptions.hxx&gt;</code> header file to
     make these exceptions available in your application.</p>

  <p>The <code>special_value</code> exception is thrown if an attempt is made
     to store a Boost date-time special value that cannot be represented in
     the target database. The <code>value_out_of_range</code> exception is
     thrown if an attempt is made to store a date-time value that is out of
     the target database range. The specific conditions under which these
     exceptions are thrown are database system dependent and are discussed in
     more detail in the following sub-sections.</p>

  <h3><a name="16.4.1">16.4.1 MySQL Database Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between the currently
     supported Boost <code>date_time</code> types and the MySQL database
     types.</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>Boost <code>date_time</code> Type</th>
      <th>MySQL Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>gregorian::date</code></td>
      <td><code>DATE</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>posix_time::ptime</code></td>
      <td><code>DATETIME</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>posix_time::time_duration</code></td>
      <td><code>TIME</code></td>
      <td><code>NULL</code></td>
    </tr>
  </table>

  <p>The Boost special value <code>date_time::not_a_date_time</code> is stored
     as a <code>NULL</code> value in a MySQL database.</p>

  <p>The <code>posix-time</code> sub-profile implementation also provides
     support for mapping <code>posix_time::ptime</code> to the
     <code>TIMESTAMP</code> MySQL type. However, this mapping has to be
     explicitly requested using the <code>db&nbsp;type</code> pragma
     (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>), as shown in
     the following example:</p>

<pre class="c++">
#pragma db object
class person
{
  ...
  #pragma db type("TIMESTAMP") not_null
  boost::posix_time::ptime updated_;
};
</pre>

  <p>Some valid Boost date-time values cannot be stored in a MySQL database.
     An attempt to persist any Boost date-time special value other than
     <code>date_time::not_a_date_time</code> will result in the
     <code>special_value</code> exception. An attempt to persist a Boost
     date-time value that is out of the MySQL type range will result in
     the <code>out_of_range</code> exception.  Refer to the MySQL
     documentation for more information on the MySQL data type ranges.</p>

  <h3><a name="16.4.2">16.4.2 SQLite Database Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between the currently
     supported Boost <code>date_time</code> types and the SQLite database
     types.</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>Boost <code>date_time</code> Type</th>
      <th>SQLite Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>gregorian::date</code></td>
      <td><code>TEXT</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>posix_time::ptime</code></td>
      <td><code>TEXT</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>posix_time::time_duration</code></td>
      <td><code>TEXT</code></td>
      <td><code>NULL</code></td>
    </tr>
  </table>

  <p>The Boost special value <code>date_time::not_a_date_time</code> is stored
     as a <code>NULL</code> value in an SQLite database.</p>

  <p>The <code>date-time</code> sub-profile implementation also provides
     support for mapping <code>gregorian::date</code> and
     <code>posix_time::ptime</code> to the <code>INTEGER</code> SQLite type,
     with the integer value representing the UNIX time. Similarly, an
     alternative mapping for <code>posix_time::time_duration</code> to the
     <code>INTEGER</code> type represents the duration as a number of
     seconds. These mappings have to be explicitly requested using the
     <code>db&nbsp;type</code> pragma (<a href="#11.4.3">Section 11.4.3,
     "<code>type</code>"</a>), as shown in the following example:</p>

<pre class="c++">
#pragma db object
class person
{
  ...
  #pragma db type("INTEGER")
  boost::gregorian::date born_;
};
</pre>

  <!--

  <p>The Boost UNIX time interface does not support 64 bit time arithmetic.
     As a result, the UNIX time representations of <code>gregorian::date</code>
     and <code>posix_time::ptime</code> are restricted to the 32 bit range.
     The minimum and maximum date representable by
     <code>gregorian::date</code> is 1901-12-14 and 2038-01-19 respectively,
     while the minimum and maximum date-time representable by
     <code>posix_time::ptime</code> is 1901-12-13&nbsp;20:45:54 GMT and
     2038-01-19&nbsp;03:14:07&nbsp;GMT respectively. Persisting and loading
     of values outside of these ranges will result in undefined behavior.</p>

  -->

  <p>Some valid Boost date-time values cannot be stored in an SQLite database.
     An attempt to persist any Boost date-time special value other than
     <code>date_time::not_a_date_time</code> will result in the
     <code>special_value</code> exception. An attempt to persist a negative
     <code>posix_time::time_duration</code> value as SQLite <code>TEXT</code>
     will result in the <code>out_of_range</code> exception.</p>


  <h3><a name="16.4.3">16.4.3 PostgreSQL Database Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between the currently
     supported Boost <code>date_time</code> types and the PostgreSQL database
     types.</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>Boost <code>date_time</code> Type</th>
      <th>PostgreSQL Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>gregorian::date</code></td>
      <td><code>DATE</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>posix_time::ptime</code></td>
      <td><code>TIMESTAMP</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>posix_time::time_duration</code></td>
      <td><code>TIME</code></td>
      <td><code>NULL</code></td>
    </tr>
  </table>

  <p>The Boost special value <code>date_time::not_a_date_time</code> is stored
     as a <code>NULL</code> value in a PostgreSQL database.
     <code>posix_time::ptime</code> values representing the special values
     <code>date_time::pos_infin</code> and <code>date_time::neg_infin</code>
     are stored as the special PostgreSQL TIMESTAMP values
     <code>infinity</code> and <code>-infinity</code>, respectively.</p>

  <p>Some valid Boost date-time values cannot be stored in a PostgreSQL
     database. The PostgreSQL TIME type represents a clock time, and can
     therefore only store positive durations with a total length of time less
     than 24 hours. An attempt to persist a
     <code>posix_time::time_duration</code> value outside of this range will
     result in the <code>value_out_of_range</code> exception. An attempt to
     persist a <code>posix_time::time_duration</code> value representing any
     special value other than <code>date_time::not_a_date_time</code>  will
     result in the <code>special_value</code> exception.</p>


  <!-- CHAPTER -->


  <hr class="page-break"/>
  <h1><a name="17">17 Qt Profile</a></h1>

  <p>The ODB profile implementation for Qt is provided by the
     <code>libodb-qt</code> library and consists of multiple sub-profiles
     corresponding to the common type groups within Qt. Currently,
     only types from the <code>QtCore</code> module are supported. To
     enable all the available Qt sub-profiles, pass <code>qt</code> as the
     profile name to the <code>--profile</code> ODB compiler  option.
     Alternatively, you can enable only specific sub-profiles by passing
     individual sub-profile names to <code>--profile</code>. The following
     sections in this chapter discuss each Qt sub-profile in detail. The
     <code>qt</code> example in the <code>odb-examples</code>
     package shows how to enable and use the Qt profile.</p>

  <p>Some sub-profiles may throw exceptions to indicate error conditions,
     such as the inability to store a specific value in a particular database
     system. All such exceptions derive from the
     <code>odb::qt::exception</code> class which in turn derives from
     the root of the ODB exception hierarchy, class <code>odb::exception</code>
     (<a href="#3.12">Section 3.12, "ODB Exceptions"</a>). The
     <code>odb::qt::exception</code> class is defined in the
     <code>&lt;odb/qt/exception.hxx></code> header file and has the
     same interface as <code>odb::exception</code>. The concrete exceptions
     that can be thrown by the Qt sub-profiles are described in the
     following sections.</p>

  <h2><a name="17.1">17.1 Basic Types</a></h2>

  <p>The <code>basic</code> sub-profile provides persistence support for basic
     types defined by Qt. To enable only this profile, pass
     <code>qt/basic</code> to the <code>--profile</code> ODB compiler
     option.</p>

  <p>The currently supported basic types are <code>QString</code> and
    <code>QByteArray</code>. The manner in which these types
     are persisted is database system dependent and is discussed in the
     sub-sections that follow. The example below shows how
     <code>QString</code> may be used within a persistent object.</p>

<pre class="c++">
#pragma db object
class Person
{
  ...
  QString name_;
};
</pre>

  <h3><a name="17.1.1">17.1.1 MySQL Database Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between the currently
     supported basic Qt types and the MySQL database types.</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>Qt Type</th>
      <th>MySQL Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>QString</code></td>
      <td><code>TEXT/VARCHAR(255)</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>QByteArray</code></td>
      <td><code>BLOB</code></td>
      <td><code>NULL</code></td>
    </tr>
  </table>

  <p>Instances of the <code>QString</code> and <code>QByteArray</code> types
     are stored as a NULL value if their <code>isNull()</code> member
     function returns <code>true</code>.</p>

  <p>Note also that the <code>QString</code> type is mapped
     differently depending on whether the member of this type
     is an object id or not. If the member is an object id,
     then for this member <code>QString</code> is mapped
     to the <code>VARCHAR(255)</code> MySQL type. Otherwise,
     it is mapped to <code>TEXT</code>.</p>


  <h3><a name="17.1.2">17.1.2 SQLite Database Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between the currently
     supported basic Qt types and the SQLite database types.</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>Qt Type</th>
      <th>SQLite Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>QString</code></td>
      <td><code>TEXT</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>QByteArray</code></td>
      <td><code>BLOB</code></td>
      <td><code>NULL</code></td>
    </tr>
  </table>

  <p>Instances of the <code>QString</code> and <code>QByteArray</code> types
     are stored as a NULL value if their <code>isNull()</code> member
     function returns <code>true</code>.</p>

  <h3><a name="17.1.3">17.1.3 PostgreSQL Database Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between the currently
     supported basic Qt types and the PostgreSQL database types.</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>Qt Type</th>
      <th>PostgreSQL Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>QString</code></td>
      <td><code>TEXT</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>QByteArray</code></td>
      <td><code>BYTEA</code></td>
      <td><code>NULL</code></td>
    </tr>
  </table>

  <p>Instances of the <code>QString</code> and <code>QByteArray</code> types
     are stored as a NULL value if their <code>isNull()</code> member
     function returns <code>true</code>.</p>

  <h2><a name="17.2">17.2 Smart Pointers</a></h2>

  <p>The <code>smart-ptr</code> sub-profile provides persistence support the
     Qt smart pointers. To enable only this profile, pass
     <code>qt/smart-ptr</code> to the <code>--profile</code> ODB compiler
     option.</p>

  <p>The currently supported smart pointers are
     <code>QSharedPointer</code> and <code>QWeakPointer</code>.
     For more information on using smart pointers as pointers to objects
     and views, refer to <a href="#3.2">Section 3.2, "Object and View
     Pointers"</a> and <a href="#6">Chapter 6, "Relationships"</a>. For
     more information on using smart pointers as pointers to values, refer
     to <a href="#7.3">Section 7.3, "Pointers and <code>NULL</code> Value
     Semantics"</a>. When used as a pointer to a value, only
     <code>QSharedPointer</code> is supported. For example:</p>

  <pre class="c++">
#pragma db object
class person
{
  ...

  #pragma db null
  QSharedPointer&lt;QString> middle_name_;
};
  </pre>

  <p>To provide finer grained control over object relationship loading,
     the <code>smart-ptr</code> sub-profile also provides the lazy
     counterparts for the above pointers: <code>QLazySharedPointer</code>
     and <code>QLazyWeakPointer</code>. You will need to include the
     <code>&lt;odb/qt/lazy-ptr.hxx></code> header file to make the lazy
     variants available in your application. For the description of the lazy
     pointer interface and semantics refer to <a href="#6.3">Section 6.3,
     "Lazy Pointers"</a>. The following example shows how we can use these
     smart pointers to establish a relationship between persistent objects.</p>

<pre class="c++">
class Employee;

#pragma db object
class Position
{
  ...

  #pragma db inverse(position_)
  QLazyWeakPointer&lt;Employee> employee_;
};

#pragma db object
class Employee
{
  ...

  #pragma db not_null
  QSharedPointer&lt;Position> position_;
};
</pre>

  <p>Besides providing persistence support for the above smart pointers,
     the <code>smart-ptr</code> sub-profile also changes the default
     pointer (<a href="#3.2">Section 3.2, "Object and View Pointers"</a>)
     to <code>QSharedPointer</code>.  In particular, this means that
     database functions that return dynamically allocated objects and views
     will return them as <code>QSharedPointer</code> pointers. To override
     this behavior, add the <code>--default-pointer</code> option specifying
     the alternative pointer type after the <code>--profile</code> option.</p>

  <h2><a name="17.3">17.3 Containers Library</a></h2>

  <p>The <code>container</code> sub-profile provides persistence support for
     Qt containers. To enable only this profile, pass
     <code>qt/containers</code> to the <code>--profile</code> ODB compiler
     option.</p>

  <p>The currently supported ordered containers are <code>QVector</code>,
     <code>QList</code>, and <code>QLinkedList</code>. Supported map
     containers are <code>QMap</code>, <code>QMultiMap</code>,
     <code>QHash</code>, and <code>QMultiHash</code>. The supported set
     container is <code>QSet</code>. For more information on using
     containers with ODB refer to <a href="#5">Chapter 5, "Containers"</a>.
     The following example shows how the <code>QSet</code> container may
     be used within a persistent object.</p>

<pre class="c++">
#pragma db object
class Person
{
  ...
  QSet&lt;QString> emails_;
};
</pre>

  <h2><a name="17.4">17.4 Date Time Types</a></h2>

  <p>The <code>date-time</code> sub-profile provides persistence support for
     the Qt date-time types. To enable only this profile, pass
     <code>qt/date-time</code> to the <code>--profile</code> ODB compiler
     option.</p>

  <p>The currently supported date-time types are <code>QDate</code>,
     <code>QTime</code>, and <code>QDateTime</code>. The manner in which
     these types are persisted is database system dependent and is
     discussed in the sub-sections that follow. The example below shows how
     <code>QDate</code> may be used within a persistent object.</p>

<pre class="c++">
#pragma db object
class Person
{
  ...
  QDate dateOfBirth_;
};
</pre>

  <p>The single concrete exception that can be thrown by the
     <code>date-time</code> sub-profile implementation is presented below.</p>


<pre class="c++">
namespace odb
{
  namespace qt
  {
    namespace date_time
    {
      struct value_out_of_range: odb::qt::exception
      {
        virtual const char*
        what () const throw ();
      };
    }
  }
}
</pre>

  <p>You will need to include the
     <code>&lt;odb/qt/date-time/exceptions.hxx&gt;</code> header file to
     make this exception available in your application.</p>

  <p>The <code>value_out_of_range</code> exception is thrown if an attempt
     is made to store a date-time value that is out of the target database
     range. The specific conditions under which it is thrown is database
     system dependent and is discussed in more detail in the
     following sub-sections.</p>

  <h3><a name="17.4.1">17.4.1 MySQL Database Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between the currently
     supported Qt date-time types and the MySQL database types.</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>Qt Date Time Type</th>
      <th>MySQL Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>QDate</code></td>
      <td><code>DATE</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>QTime</code></td>
      <td><code>TIME</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>QDateTime</code></td>
      <td><code>DATETIME</code></td>
      <td><code>NULL</code></td>
    </tr>
  </table>

  <p>Instances of the <code>QDate</code>, <code>QTime</code>, and
     <code>QDateTime</code> types are stored as a NULL value if their
     <code>isNull()</code> member function returns true.</p>

  <p>The <code>date-time</code> sub-profile implementation also provides
     support for mapping <code>QDateTime</code> to the <code>TIMESTAMP</code>
     MySQL type. However, this mapping has to be explicitly requested using
     the <code>db&nbsp;type</code> pragma
     (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>), as shown in
     the following example:</p>

<pre class="c++">
#pragma db object
class Person
{
  ...
  #pragma db type("TIMESTAMP") not_null
  QDateTime updated_;
};
</pre>

  <p>Some valid Qt date-time values cannot be stored in a MySQL database.  An
     attempt to persist a Qt date-time value that is out of the MySQL type
     range will result in the <code>out_of_range</code> exception.  Refer to
     the MySQL documentation for more information on the MySQL data type
     ranges.</p>

  <h3><a name="17.4.2">17.4.2 SQLite Database Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between the currently
     supported Qt date-time types and the SQLite database types.</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>Qt Date Time Type</th>
      <th>SQLite Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>QDate</code></td>
      <td><code>TEXT</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>QTime</code></td>
      <td><code>TEXT</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>QDateTime</code></td>
      <td><code>TEXT</code></td>
      <td><code>NULL</code></td>
    </tr>
  </table>

  <p>Instances of the <code>QDate</code>, <code>QTime</code>, and
     <code>QDateTime</code> types are stored as a NULL value if their
     <code>isNull()</code> member function returns true.</p>

  <p>The <code>date-time</code> sub-profile implementation also provides
     support for mapping <code>QDate</code> and <code>QDateTime</code> to the
     SQLite <code>INTEGER</code> type, with the integer value representing the
     UNIX time. Similarly, an alternative mapping for <code>QTime</code> to
     the <code>INTEGER</code> type represents a clock time as the number of
     seconds since midnight. These mappings have to be explicitly requested
     using the <code>db&nbsp;type</code> pragma
     (<a href="#11.4.3">Section 11.4.3, "<code>type</code>"</a>), as shown
     in the following example:</p>

<pre class="c++">
#pragma db object
class Person
{
  ...
  #pragma db type("INTEGER")
  QDate born_;
};
</pre>

  <p>Some valid Qt date-time values cannot be stored in an SQLite database.
     An attempt to persist any Qt date-time value representing a negative UNIX
     time (any point in time prior to the 1970-01-01&nbsp;00:00:00 UNIX time
     epoch) as an SQLite <code>INTEGER</code> will result in the
     <code>out_of_range</code> exception.</p>

  <h3><a name="17.4.3">17.4.3 PostgreSQL Database Type Mapping</a></h3>

  <p>The following table summarizes the default mapping between the currently
     supported Qt date-time types and the PostgreSQL database types.</p>

  <!-- border="1" is necessary for html2ps -->
  <table id="mapping" border="1">
    <tr>
      <th>Qt Date Time Type</th>
      <th>PostgreSQL Type</th>
      <th>Default <code>NULL</code> Semantics</th>
    </tr>

    <tr>
      <td><code>QDate</code></td>
      <td><code>DATE</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>QTime</code></td>
      <td><code>TIME</code></td>
      <td><code>NULL</code></td>
    </tr>

    <tr>
      <td><code>QDateTime</code></td>
      <td><code>TIMESTAMP</code></td>
      <td><code>NULL</code></td>
    </tr>
  </table>

  <p>Instances of the <code>QDate</code>, <code>QTime</code>, and
     <code>QDateTime</code> types are stored as a NULL value if their
     <code>isNull()</code> member function returns true.</p>

  <p>Some valid Qt date-time values cannot be stored in a PostgreSQL database.
     An attempt to persist a <code>QDateTime</code> value representing a
     negative UNIX time (any point in time prior to the
     1970-01-01&nbsp;00:00:00 UNIX time epoch) as a PostgreSQL
     <code>TIMESTAMP</code> will result in the <code>out_of_range</code>
     exception.</p>

  </div>
</div>

</body>
</html>
